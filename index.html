<!DOCTYPE html>
<html lang="en">
<head>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prodigy 2.6 - Hacking Simulator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
body {
    background: linear-gradient(135deg, #0a0e1a 0%, #1a2332 50%, #0f1a29 100%);
    font-family: 'Rajdhani', sans-serif;
    overflow-x: hidden;  
    overflow-y: auto;    
    width: 100vw;
    min-height: 100vh;   
    user-select: none;
    -webkit-user-select: none;
}
.grid-bg {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        linear-gradient(rgba(140, 224, 35, 0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(140, 224, 35, 0.03) 1px, transparent 1px);
    background-size: 50px 50px;
    animation: gridMove 20s linear infinite;
    pointer-events: none;
    z-index: 0;
}

@keyframes gridMove {
    0% { transform: translate(0, 0); }
    100% { transform: translate(50px, 50px); }
}
.particles {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1;
}

.particle {
    position: absolute;
    width: 3px;
    height: 3px;
    background: #8ce023;
    border-radius: 50%;
    box-shadow: 0 0 10px #8ce023;
    animation: float 15s infinite;
}

@keyframes float {
    0%, 100% { transform: translateY(0) translateX(0); opacity: 0; }
    10% { opacity: 1; }
    90% { opacity: 1; }
    100% { transform: translateY(-100vh) translateX(50px); opacity: 0; }
}
        
        #game-container {
 position: relative;
    z-index: 2;
    max-width: 1400px;
    margin: 0 auto;
    padding: 20px;
        }
        
#menu {
    text-align: center;
    color: white;
    overflow-y: auto;    /* ADD THIS - allow scrolling inside menu */
    max-height: none;    /* REMOVE height restriction */
    padding: 20px;
    width: 100%;
    box-sizing: border-box;
}

#menu h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 4rem;
    font-weight: 900;
    background: linear-gradient(135deg, #8ce023 0%, #5da817 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: 0 0 30px rgba(140, 224, 35, 0.5);
    margin-bottom: 10px;
    letter-spacing: 3px;
}

#menu h2 {
    font-size: 1.5rem;
    color: #8ce023;
    font-weight: 300;
    letter-spacing: 2px;
    text-transform: uppercase;
}
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

.section-title {
    font-size: 1.5em;
    color: #ff6b6b; /* Change to red for Comic Book Store */
    margin: 30px 0 20px 0;
    grid-column: 1 / -1;
    text-align: center;
    text-shadow: 2px 2px 0 rgba(0,0,0,0.7);
}

/* Comic Book Store - Yellow */
/* Comic Book Store - RED */
.section-title:first-of-type {
    color: #ff0000;
    text-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
    font-weight: 900;
    letter-spacing: 2px;
}

/* Boosting Section - Blue theme */  
.section-title:last-of-type {
    color: #4dabf7; /* Blue */
    text-shadow: 0 0 10px rgba(77, 171, 247, 0.5);
}

.game-cards-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 20px;
    margin-top: 40px;
    max-width: 1400px;
    margin-left: auto;
    margin-right: auto;
    padding: 0 20px;
}

.game-card {
    background: linear-gradient(135deg, rgba(20, 30, 48, 0.9) 0%, rgba(15, 25, 40, 0.9) 100%);
    border: 2px solid rgba(140, 224, 35, 0.3);
    border-radius: 15px;
    padding: 0;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
    min-height: 400px; /* Increased from 280px */
    display: flex;
    flex-direction: column;
}


.game-card-image {
    background: transparent;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    border-bottom: 1px solid rgba(140, 224, 35, 0.2);
    flex: 0 0 auto;
    height: 200px; 
}

.game-card-image img {
    width: 100%;
    height: 100%;
    object-fit: fill;
    border-radius: 8px;
}

/* Larger bottom text area with background */
.game-card-content {
    background: 
        linear-gradient(135deg, rgba(20, 30, 48, 0.85) 0%, rgba(15, 25, 40, 0.85) 100%),
        url('assets/comic_book.png') center/cover;
    padding: 20px; /* More padding */
    flex: 1;
    display: flex;
    flex-direction: column;
    justify-content: flex-start; /* Changed to top-align for more text */
    position: relative;
    min-height: 190px; /* Ensure enough space for background */
}

/* Comic Book Store Games */
.game-card[data-game="breakout"] .game-card-content,
.game-card[data-game="asteroids"] .game-card-content,
.game-card[data-game="hanoi"] .game-card-content, 
.game-card[data-game="wordle"] .game-card-content {
    background: 
        linear-gradient(135deg, rgba(20, 30, 48, 0.85) 0%, rgba(15, 25, 40, 0.85) 100%),
        url('assets/comic_book.png') center/cover;
}

/* Boosting Section - BLUE theme */  
.section-title:nth-of-type(2) {
    color: #0066ff; /* Electric blue */
    text-shadow: 0 0 15px rgba(0, 102, 255, 0.7);
}

/* Boosting Games */
.game-card[data-game="firewall"] .game-card-content,
.game-card[data-game="power"] .game-card-content,
.game-card[data-game="bypass"] .game-card-content,
.game-card[data-game="block-signal"] .game-card-content,
.game-card[data-game="avoid-obstacles"] .game-card-content,
.game-card[data-game="avoid-walls"] .game-card-content,
.game-card[data-game="avoid-safety"] .game-card-content, 
.game-card[data-game="gather-blocks"] .game-card-content,
.game-card[data-game="osu"] .game-card-content,
.game-card[data-game="cuff-hack"] .game-card-content {
    background: 
        linear-gradient(135deg, rgba(20, 30, 48, 0.85) 0%, rgba(15, 25, 40, 0.85) 100%),
        url('assets/boosting.png') center/cover;
}

/* Adjust text elements for more space */
.game-card-content p {
    margin-bottom: 15px;
    line-height: 1.5;
    min-height: 60px; /* Ensure paragraph has enough space */
}

.game-stats {
    margin: 10px 0;
}

.game-card::before {
    content: '';
    position: absolute;
    top: -2px;
    left: -2px;
    right: -2px;
    bottom: -2px;
    background: linear-gradient(45deg, rgba(140, 224, 35, 0.3), rgba(93, 168, 23, 0.2), rgba(140, 224, 35, 0.3));
    border-radius: 15px;
    opacity: 0;
    transition: opacity 0.3s;
    z-index: -1;
}

.game-card:hover::before {
    opacity: 0.5;
}

.game-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(140, 224, 35, 0.2);
    border-color: rgba(140, 224, 35, 0.6);
}

.game-card img {
    width: 100%;            /* Use full width of card */
    height: 180px;          /* Fixed height for consistency */
    object-fit: fit;      /* Crop to fill area */
    border-radius: 8px;
}

.game-card h3 {
    font-size: 1rem;
    margin-bottom: 8px;
    color: #8ce023;
}

.game-card p {
    font-size: 0.8rem;
    color: #a0a0a0;
    line-height: 1.4;
    margin-bottom: 0;
}
  
/* PDM Section - Red/Blue gradient */
.section-title:nth-of-type(3) {
    background: linear-gradient(90deg, #ff0000 0%, #ff0000 45%, #0000ff 55%, #0000ff 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-shadow: none;
    font-weight: 900;
}

/* PDM Games */
.game-card[data-game="connect-pipes"] .game-card-content,
.game-card[data-game="find-pairs"] .game-card-content,
.game-card[data-game="block-external-signal"] .game-card-content,
.game-card[data-game="electricity-panel"] .game-card-content,
.game-card[data-game="memory-sequence"] .game-card-content,
.game-card[data-game="unlock-garage"] .game-card-content {
    background: 
        linear-gradient(135deg, rgba(20, 30, 48, 0.85) 0%, rgba(15, 25, 40, 0.85) 100%),
        url('assets/pdm.png') center/cover;
}

/* Jewelry Store Section - Gold/Yellow */
.section-title:nth-of-type(4) {
    color: #ffd700; /* Gold/Yellow */
    text-shadow: 0 0 15px rgba(255, 215, 0, 0.7);
    margin-top: 40px; /* Add some spacing from previous section */
}

/*JEWELRY Games*/
.game-card[data-game="color-memory"] .game-card-content,
.game-card[data-game="math-compare"] .game-card-content,
.game-card[data-game="lock-picking"] .game-card-content{
    background: 
        linear-gradient(135deg, rgba(20, 30, 48, 0.85) 0%, rgba(15, 25, 40, 0.85) 100%),
        url('assets/jewelry_store.png') center/cover;
}

/* About Sections */
.about-section, .opensource-section, .faq-section {
    padding: 60px 20px;
    background: rgba(10, 14, 26, 0.8);
    border-top: 1px solid rgba(140, 224, 35, 0.2);
    border-bottom: 1px solid rgba(140, 224, 35, 0.2);
}

.container {
    max-width: 1200px;
    margin: 0 auto;
}

.about-section .section-title {
    color: #8ce023;
    text-shadow: 0 0 15px rgba(140, 224, 35, 0.5);
    margin-bottom: 40px;
}

.opensource-section .section-title {
    color: #8ce023;
    text-shadow: 0 0 15px rgba(140, 224, 35, 0.5);
    margin-bottom: 40px;
}

.faq-section .section-title {
    color: #8ce023;
    text-shadow: 0 0 15px rgba(140, 224, 35, 0.5);
    margin-bottom: 40px;
}

/* About Text */
.about-text p, .opensource-content p {
    color: #e0e0e0;
    font-size: 1.1rem;
    line-height: 1.8;
    margin-bottom: 25px;
    font-family: 'Rajdhani', sans-serif;
}

/* FAQ Grid */
.faq-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
    gap: 30px;
}

.faq-item {
    background: rgba(20, 30, 48, 0.9);
    border: 1px solid rgba(140, 224, 35, 0.3);
    border-radius: 10px;
    padding: 25px;
    transition: all 0.3s;
}

.faq-item:hover {
    border-color: rgba(140, 224, 35, 0.6);
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(140, 224, 35, 0.2);
}

.faq-item h3 {
    color: #8ce023;
    font-family: 'Orbitron', sans-serif;
    font-size: 1.2rem;
    margin-bottom: 15px;
    font-weight: 700;
}

.faq-item p {
    color: #a0a0a0;
    line-height: 1.6;
    font-family: 'Rajdhani', sans-serif;
    font-size: 1rem;
}
      
        #game-screen {
            display: none;
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #game-canvas {
            border: 3px solid #ffd700;
            background: #0a1628;
            margin: 10px;
            display: block;
        }
        
#game-ui {
    position: absolute;
    top: 20px;
    left: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    align-items: flex-start;
    z-index: 100;
}

#lives-display {
    position: absolute;
    top:20px;
    right: 20px;
    font-size: 2em;
    font-family: 'Press Start 2P', 'Courier New', monospace;
    display: flex;
    gap: 10px;
    z-index: 100;
}


   .ui-element {
    background: transparent;
    color: white;
    padding: 10px 15px;
    font-size: 1.5em;
    display: flex;
    align-items: center;
    gap: 8px;
    font-family: 'Press Start 2P', 'Courier New', monospace;
}
        
        #game-info {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.3em;
            margin: 10px;
            display: flex;
            gap: 30px;
            align-items: center;
        }
        
#back-btn {
background: linear-gradient(135deg, #8ce023 0%, #5da817 100%);
    border: none;
    color: #0a0e1a;
    padding: 15px 40px;
    font-size: 1.1rem;
    font-weight: 700;
    text-transform: uppercase;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
    font-family: 'Orbitron', sans-serif;
}
    
#back-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(140, 224, 35, 0.6);
 background: rgba(0,255,0,1);
}
    
#play-again-inline-btn {
background: linear-gradient(135deg, #8ce023 0%, #5da817 100%);
    border: none;
    color: #0a0e1a;
    padding: 15px 40px;
    font-size: 1.1rem;
    font-weight: 700;
    text-transform: uppercase;
    border-radius: 5px;
    cursor: pointer;
    transition: all 0.3s;
    font-family: 'Orbitron', sans-serif;
}

#play-again-inline-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 0 30px rgba(140, 224, 35, 0.6);
}
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            font-size: 2em;
            z-index: 999;
            display: none;
        }

        .game-over button {
            margin-top: 20px;
            padding: 15px 30px;
            font-size: 0.8em;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        
        #discord-status {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            color: #00ff00;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.9em;
            display: none;
        }
     
#settings-menu {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20, 30, 48, 0.95);
    border: 2px solid rgba(140, 224, 35, 0.6);
    border-radius: 15px;
    padding: 30px;
    color: white;
    z-index: 1000;
    width: 500px;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 50px rgba(140, 224, 35, 0.3);
}
   
#settings-icon {
    position: fixed;
    top: 20px;
    right: 20px;
    z-index: 1000;
}

#settings-btn {
    background: linear-gradient(135deg, rgba(20, 30, 48, 0.9) 0%, rgba(15, 25, 40, 0.9) 100%);
    border: 2px solid rgba(140, 224, 35, 0.3);
    border-radius: 50%;
    width: 60px;
    height: 60px;
    font-size: 1.5rem;
    color: #8ce023;
    cursor: pointer;
    transition: all 0.3s;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
}

#settings-btn:hover {
    transform: scale(1.1) rotate(90deg);
    box-shadow: 0 6px 20px rgba(140, 224, 35, 0.4);
    border-color: #8ce023;
    background: linear-gradient(135deg, rgba(30, 40, 58, 0.9) 0%, rgba(25, 35, 50, 0.9) 100%);
}
        
        .settings-section {
            margin-bottom: 25px;
        }
        
        .settings-section h3 {
            margin-bottom: 15px;
            color: #ffd700;
        }
        
        .control-setting {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 8px 0;
        }
        
        .control-setting label {
            font-size: 1.1em;
        }
        
        .control-setting select {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 1em;
        }
        
        #close-settings {
            background: #f44336;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 20px;
            width: 100%;
        }
        
        .dragging {
            opacity: 0.7;
        }
#matrix-bg {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    z-index: -1;
}
    </style>
</head>
<body>
<div class="grid-bg"></div>
    <div class="particles" id="particles"></div>
    <div id="game-container">
        <!-- Discord Status Indicator -->
        <div id="discord-status">Discord Activity</div>

   <div id="game-container">
    <!-- Discord Status Indicator -->
    <div id="discord-status">Discord Activity</div>
    
    <!-- Settings Icon -->
    <div id="settings-icon">
        <button id="settings-btn">‚öôÔ∏è</button>
    </div>
       
        <!-- Main Menu -->
<div id="menu">
    <h1>PRODIGY 2.7</h1>
    <h2>HACKING SIMULATOR</h2>
    
    <div class="game-cards-grid">
        <h3 class="section-title">COMIC BOOK STORE HEIST</h3>

        <div class="game-card" data-game="brick-demolisher">
    <div class="game-card-image">
            <img src="assets/breakout.jpg" alt="Brick Demolisher">
</div>
 <div class="game-card-content">
            <h3>GAME 1: BRICK DEMOLISHER</h3>
            <p>Break all blocks ‚Ä¢ 3 Lives ‚Ä¢ Classic arcade action</p>
        </div>
</div>
        <div class="game-card" data-game="asteroid-hunter">
    <div class="game-card-image">
            <img src="assets/asteroid_hunter.jpg" alt="Asteroid Hunter">
</div>
 <div class="game-card-content">
            <h3>GAME 2: ASTEROID HUNTER</h3>
            <p>Destroy asteroids ‚Ä¢ Avoid bombs ‚Ä¢ 5 Lives</p>
        </div>
</div>
        <div class="game-card" data-game="hanoi">
    <div class="game-card-image">
            <img src="assets/hanoi.jpg" alt="Tower of Hanoi">
</div>
 <div class="game-card-content">
            <h3>GAME 3: TOWER OF HANOI</h3>
            <p>Move 5 rings ‚Ä¢ 65 seconds ‚Ä¢ Classic puzzle</p>
        </div>
</div>
        <div class="game-card" data-game="wordle">
    <div class="game-card-image">
            <img src="assets/wordle.png" alt="Wordle">
</div>
 <div class="game-card-content">
            <h3>GAME 4: WORDLE</h3>
            <p>Guess the word ‚Ä¢ 10 minutes ‚Ä¢ Daily challenge</p>
        </div>
        </div>
        <h3 class="section-title">BOOSTING</h3>
        <div class="game-card" data-game="firewall">
    <div class="game-card-image">
            <img src="assets/destroy_firewall.jpg" alt="Destroy Firewall">
</div>
 <div class="game-card-content">
            <h3>DESTROY FIREWALL</h3>
            <p>Shoot 50 asteroids ‚Ä¢ Vertical shooter ‚Ä¢ Unlimited ammo</p>
        </div>
</div>
        <div class="game-card" data-game="power">
    <div class="game-card-image">
            <img src="assets/snake.jpg" alt="Gather Power">
</div>
 <div class="game-card-content">
            <h3>GATHER POWER</h3>
            <p>Snake game ‚Ä¢ Collect 10 squares ‚Ä¢ Don't hit walls</p>
        </div>
</div>
        <div class="game-card" data-game="bypass">
    <div class="game-card-image">
            <img src="assets/music_hero.jpg" alt="Bypass Firewall">
</div>
 <div class="game-card-content">
            <h3>BYPASS THE FIREWALL</h3>
            <p>Hit 50 blocks ‚Ä¢ Rhythm game ‚Ä¢ Perfect timing</p>
        </div>
</div>
      <div class="game-card" data-game="block-signal">
    <div class="game-card-image">
    <img src="assets/block_signal.png" alt="Block Signal">
</div>
 <div class="game-card-content">
    <h3>BLOCK SIGNAL</h3>
    <p>Complete the circle ‚Ä¢ Avoid gaps ‚Ä¢ Timing challenge</p>
</div>
</div>
<div class="game-card" data-game="avoid-obstacles">
    <div class="game-card-image">
    <img src="assets/avoid_obstacles.png" alt="Avoid Obstacles">
</div>
 <div class="game-card-content">
    <h3>AVOID OBSTACLES</h3>
    <p>Navigate radar ‚Ä¢ Dodge threats ‚Ä¢ Stay alive</p>
</div>
</div>
<div class="game-card" data-game="avoid-walls">
    <div class="game-card-image">
    <img src="assets/avoid_walls.png" alt="Avoid Walls">
</div>
 <div class="game-card-content">
    <h3>AVOID WALLS</h3>
    <p>Navigate circles ‚Ä¢ Arrow keys ‚Ä¢ Don't touch walls</p>
</div>
</div>
<div class="game-card" data-game="avoid-safety">
    <div class="game-card-image">
    <img src="assets/avoid_safety.png" alt="Avoid Safety Features">
</div>
 <div class="game-card-content">
    <h3>AVOID SAFETY FEATURES</h3>
    <p>Dodge cars ‚Ä¢ Navigate traffic ‚Ä¢ Survive the road</p>
</div>
</div>  

<div class="game-card" data-game="gather-blocks">
    <div class="game-card-image">
        <img src="assets/drill.png" alt="Color Drilling">
    </div>
    <div class="game-card-content">
        <h3>COLOR DRILLING</h3>
        <p>Match drill color ‚Ä¢ Drill through 20 blocks ‚Ä¢ Use arrows</p>
    </div>
</div>

<div class="game-card" data-game="osu">
    <div class="game-card-image">
        <img src="assets/osu.png" alt="Rhythm Hack">
    </div>
    <div class="game-card-content">
        <h3>RHYTHM HACK</h3>
        <p>Click circles in order ‚Ä¢ Follow the rhythm ‚Ä¢ Score 3000 points</p>
    </div>
</div>

<div class="game-card" data-game="cuff-hack">
    <div class="game-card-image">
        <img src="assets/cuff_hack.png" alt="Lockpick Handcuffs">
    </div>
    <div class="game-card-content">
        <h3>LOCKPICK HANDCUFFS</h3>
        <p>Press E to match boxes ‚Ä¢ Perfect timing ‚Ä¢ 3 difficulties</p>
    </div>
</div>

<h3 class="section-title">PDM</h3>

<div class="game-card" data-game="connect-pipes">
    <div class="game-card-image">
        <img src="assets/connect_pipes.png" alt="Connect Pipes">
    </div>
    <div class="game-card-content">
        <h3>CONNECT PIPES</h3>
        <p>Connect pipes ‚Ä¢ 50 seconds ‚Ä¢ Start to end</p>
    </div>
</div>

<!-- After DESTROY FIREWALL game card -->
<div class="game-card" data-game="find-pairs">
    <div class="game-card-image">
        <img src="assets/find_pairs.png" alt="Find Pairs">
    </div>
    <div class="game-card-content">
        <h3>FIND PAIRS</h3>
        <p>Match 5 pairs ‚Ä¢ 7x7 grid ‚Ä¢ 50 seconds</p>
    </div>
</div>

<div class="game-card" data-game="block-external-signal">
    <div class="game-card-image">
        <img src="assets/block_external_signal.png" alt="Block External Signal">
    </div>
    <div class="game-card-content">
        <h3>BLOCK EXTERNAL SIGNAL</h3>
        <p>Avoid pipes ‚Ä¢ Survive 50 seconds ‚Ä¢ Spacebar to jump</p>
    </div>
</div>

<div class="game-card" data-game="electricity-panel">
    <div class="game-card-image">
        <img src="assets/electricity_panel.png" alt="Electricity Panel">
    </div>
    <div class="game-card-content">
        <h3>ELECTRICITY PANEL</h3>
        <p>Match circuits ‚Ä¢ Memorize patterns ‚Ä¢ 4 rounds</p>
    </div>
</div>

<div class="game-card" data-game="memory-sequence">
    <div class="game-card-image">
        <img src="assets/memory_sequence.png" alt="Memory Sequence">
    </div>
    <div class="game-card-content">
        <h3>MEMORY SEQUENCE</h3>
        <p>Remember pattern ‚Ä¢ Compare cells ‚Ä¢ Perfect recall</p>
    </div>
</div>

<div class="game-card" data-game="unlock-garage">
    <div class="game-card-image">
        <img src="assets/unlock_garage.png" alt="Unlock Garage">
    </div>
    <div class="game-card-content">
        <h3>üîì UNLOCK GARAGE</h3>
        <p>Memorize codes ‚Ä¢ 4 rounds ‚Ä¢ Fast typing</p>
    </div>
</div>

<h3 class="section-title">JEWELRY STORE</h3>

<div class="game-card" data-game="color-memory">
    <div class="game-card-image">
        <img src="assets/color_memory.png" alt="Color Memory">
    </div>
    <div class="game-card-content">
        <h3>COLOR MEMORY</h3>
        <p>Remember colors ‚Ä¢ Answer quickly ‚Ä¢ Perfect recall</p>
    </div>
</div>

<div class="game-card" data-game="math-compare">
    <div class="game-card-image">
        <img src="assets/math_compare.png" alt="Math Comparison">
    </div>
    <div class="game-card-content">
        <h3>MATH COMPARISON</h3>
        <p>Compare equations ‚Ä¢ Beat the clock ‚Ä¢ Perfect logic</p>
    </div>
</div>

<div class="game-card" data-game="lock-picking">
    <div class="game-card-image">
        <img src="assets/lock_picking.png" alt="Lock Picking">
    </div>
    <div class="game-card-content">
        <h3>LOCK PICKING</h3>
        <p>Find the sequence ‚Ä¢ Press P or Q ‚Ä¢ Beat the timer</p>
    </div>
</div>

    </div>
</div>

<!-- About Section -->
<section id="about" class="about-section">
    <div class="container">
        <h2 class="section-title">About Prodigy 2.7 Hacking Simulator</h2>
        <div class="about-content">
            <div class="about-text">
                <p>Welcome to the most comprehensive Prodigy 2.7 hacking simulator available online. This platform provides authentic replicas of the challenging minigames featured in the popular FiveM roleplay server, Prodigy. Whether you're a seasoned criminal looking to hone your skills or a curious newcomer wanting to experience the thrill of virtual heists, this simulator offers the perfect training ground.</p>

                <p>Prodigy is renowned for its intricate and demanding hacking mechanics that add an exciting layer of challenge to various criminal activities within the server. From breaking into the Comic Book Store to boosting high-end vehicles, each minigame requires precision, quick thinking, and practice. Our simulator recreates these experiences with pixel-perfect accuracy, allowing you to practice and improve your skills without the pressure of in-game consequences.</p>

                <p>Each minigame has been carefully crafted to match the look, feel, and mechanics of the original Prodigy 2.7 implementations. Test your reflexes with the Firewall Breach, demonstrate your pattern recognition with the Password Crack, or prove your coordination with the Lockpick Sequence. Practice at your own pace to master these essential skills.</p>
            </div>
        </div>
    </div>
</section>

<!-- Open Source Section -->
<section id="opensource" class="opensource-section">
    <div class="container">
        <h2 class="section-title">Open Source & Community</h2>
        <div class="opensource-content">
            <p>This project is completely open source and available on GitHub. We welcome contributions from the community, whether it's bug reports, feature suggestions, or code contributions. The codebase is built with modern web technologies including HTML5, CSS3, and JavaScript, making it easy for developers to understand and contribute.</p>
            
            <p>If you find this simulator helpful, consider starring the repository on GitHub or sharing it with your fellow Prodigy enthusiasts. Your support helps us continue to improve and maintain this free resource for the community. We're constantly working to add new features, improve existing minigames, and ensure the simulator stays up-to-date with the latest Prodigy updates.</p>
        </div>
    </div>
</section>

<!-- FAQ Section -->
<section id="faq" class="faq-section">
    <div class="container">
        <h2 class="section-title">Frequently Asked Questions</h2>
        <div class="faq-grid">
            <div class="faq-item">
                <h3>What is Prodigy 2.7?</h3>
                <p>Prodigy 2.7 is the latest version of the popular FiveM roleplay server, featuring advanced hacking mechanics and challenging minigames that players must master to succeed in various criminal activities.</p>
            </div>
            
            <div class="faq-item">
                <h3>How accurate are these minigame replicas?</h3>
                <p>Our simulators are pixel-perfect replicas with identical mechanics, timing, and difficulty levels to the actual Prodigy 2.7 minigames. We regularly update them to match any changes on the server.</p>
            </div>
            
            <div class="faq-item">
                <h3>Is this practice tool free to use?</h3>
                <p>Yes! All minigames are completely free to play with unlimited practice attempts. No registration or payment required.</p>
            </div>
            
            <div class="faq-item">
                <h3>Which minigames are available?</h3>
                <p>We offer practice for Comic Book Store Heist games (Brick Demolisher, Asteroid Hunter, Hanoi, Wordle) and Boosting games (Firewall, Power, Bypass, Signal Blocker, and more) - all essential skills for Prodigy 2.7 gameplay.</p>
            </div>
            
            <div class="faq-item">
                <h3>Do I need to download anything?</h3>
                <p>No downloads necessary! The simulator runs entirely in your web browser. Just visit the site and start practicing immediately.</p>
            </div>
        </div>
    </div>
</section>

<!-- Game Screen -->
<div id="game-screen">
    <div style="position: relative; display: inline-block;">
        <canvas id="game-canvas" width="1200" height="600" tabindex="0"></canvas>
        <div id="game-ui"></div>
        <div id="lives-display"></div>
    </div>
    <div id="game-buttons-container">
        <button id="play-again-inline-btn">üîÑ PLAY AGAIN</button>
        <button id="back-btn">‚Üê BACK TO MENU</button>
    </div>
</div>

        <!-- Settings Menu -->
<div id="settings-menu">
            <h2 style="text-align: center; margin-bottom: 20px; color: #ffd700;">SETTINGS</h2>
            
            <div class="settings-section">
                <h3>COMIC BOOK STORE HEIST</h3>
                
                <div class="control-setting">
                    <label>Control Scheme:</label>
                    <select id="heist-controls">
                        <option value="arrows">Arrow Keys</option>
                        <option value="wasd">WASD</option>
                    </select>
                </div>
                
                <div style="font-size: 0.8em; color: #aaa; margin-top: 10px; line-height: 1.4;">
                    Breakout: Left/Right to move, SPACE to launch<br>
                    Space Shooter: Up/Down to move, SPACE to shoot
                </div>
            </div>
            
            <div class="settings-section">
                <h3>BOOSTING GAMES</h3>
                
                <div class="control-setting">
                    <label>Control Scheme:</label>
                    <select id="boosting-controls">
                        <option value="arrows">Arrow Keys</option>
                        <option value="wasd">WASD</option>
                    </select>
                </div>
                
                <div style="font-size: 0.8em; color: #aaa; margin-top: 10px; line-height: 1.4;">
                    Destroy Firewall: Left/Right to move, SPACE to shoot<br>
                    Gather Power: Arrow keys/WASD to move snake<br>
                    Bypass Firewall: Press A, S, K, L when blocks align
                </div>
            </div>
            
            <div class="settings-section">
                <h3>GAMEPLAY</h3>
                
                <div class="control-setting">
                    <label>Skip Intro Screens:</label>
                    <select id="skip-intros">
                        <option value="false">No</option>
                        <option value="true">Yes</option>
                    </select>
                </div>
            </div>
            
            <button id="close-settings">CLOSE SETTINGS</button>
        </div>

        <div class="game-over" id="game-over-screen">
            <div id="game-over-text"></div>
            <button id="play-again-btn">PLAY AGAIN</button>
            <button id="menu-btn" style="background: #f44336; margin-left: 10px;">MENU</button>
        </div>
    </div>

    <script>
// Create floating particles
const particlesContainer = document.getElementById('particles');
for (let i = 0; i < 30; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.left = Math.random() * 100 + '%';
    particle.style.animationDelay = Math.random() * 15 + 's';
    particle.style.animationDuration = (10 + Math.random() * 10) + 's';
    particlesContainer.appendChild(particle);
}
        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const menu = document.getElementById('menu');
        const gameScreen = document.getElementById('game-screen');
        const gameInfo = document.getElementById('game-info');
        const gameUI = document.getElementById('game-ui');
        const gameOverScreen = document.getElementById('game-over-screen');
        const discordStatus = document.getElementById('discord-status');
        const settingsMenu = document.getElementById('settings-menu');
        
// Game State
let currentGame = null;
let gameState = {};
let gameLoopId = null;
let currentScene = 'intro'; // 'intro', 'countdown', 'playing'
let countdownStart = 0;

// Load sprites
const sprites = {
    ship: new Image(),
    bullet: new Image(),
    heart: new Image(),
    earth: new Image()
};

sprites.ship.src = 'assets/green_ship.png';
sprites.bullet.src = 'assets/green_laser.png';
sprites.heart.src = 'assets/life.png';
sprites.earth.src = 'assets/earth.png';

// Load background images for boosting games
const backgrounds = {
    boosting: new Image(),
    trojanOS: new Image()
};

backgrounds.boosting.src = 'assets/boosting.png';
backgrounds.trojanOS.src = 'assets/trojanOS.png';

// Load car sprites
const carSprites = {
    purple: new Image(),
    orange: new Image(),
    green: new Image(),
    cyan: new Image(),

    yellow_car: new Image(),
    red_car: new Image(),
    white_car: new Image(),
    blue_car: new Image(),
};


carSprites.purple.src = 'assets/purple_car.png';
carSprites.orange.src = 'assets/orange_car.png';
carSprites.green.src = 'assets/green_car.png';
carSprites.cyan.src = 'assets/cyan_car.png';
carSprites.yellow_car.src = "assets/yellow_car.png";
carSprites.red_car.src = "assets/red_car.png";
carSprites.white_car.src = "assets/white_car.png";
carSprites.blue_car.src = "assets/blue_car.png";

let spritesLoaded = false;
let spritesLoadedCount = 0;

function checkSpritesLoaded() {
    spritesLoadedCount++;
    if (spritesLoadedCount === 4) {
        spritesLoaded = true;
    }
}

sprites.ship.onload = checkSpritesLoaded;
sprites.bullet.onload = checkSpritesLoaded;
sprites.heart.onload = checkSpritesLoaded;
sprites.earth.onload = checkSpritesLoaded;

let settings = {
    breakout: {
        left: 'ArrowLeft',
        right: 'ArrowRight'
    },
    asteroids: {
        up: 'ArrowUp',
        down: 'ArrowDown',
        shoot: 'Space'
    },
    boosting: {  
        left: 'ArrowLeft',
        right: 'ArrowRight',
        up: 'ArrowUp',
        down: 'ArrowDown',
        shoot: 'Space'
    },
     osuGameSettings: {},
    skipIntros: false
};
        // Word List
const WORDS = [
    'SWIFT', 'REACT', 'CODER', 'SNAKE', 'APPLE', 'BRAIN', 'CLOUD', 'DRONE',
    'EAGLE', 'FLAME', 'GHOST', 'HUMAN', 'IVORY', 'JUMBO', 'KOALA', 'LEMON',
    'MAGIC', 'NINJA', 'OCEAN', 'PIANO', 'QUEEN', 'ROBOT', 'SPACE', 'TIGER',
    'ULTRA', 'VOICE', 'WATER', 'XENON', 'YACHT', 'ZEBRA', 'ALPHA', 'BETA',
    'GAMMA', 'DELTA', 'OMEGA', 'SIGMA', 'THETA', 'KAPPA', 'LASER', 'MUSIC',
    'NIGHT', 'PARTY', 'QUICK', 'RIVER', 'STORM', 'TRAIN', 'UNITY', 'VIDEO',
    'WORLD', 'YOUTH', 'ZESTY', 'ANGEL', 'BEACH', 'CANDY', 'DREAM', 'EARTH',
    'FRUIT', 'GRAPE', 'HEART', 'IMAGE', 'JUICE', 'KNIFE', 'LIGHT', 'MOUSE',
    'NOVEL', 'OLIVE', 'PEARL', 'QUILT', 'RADIO', 'SALAD', 'TOWER', 'UMBRA',
    'VITAL', 'WHEAT', 'XEROX', 'YIELD', 'ZONED', 'ABOVE', 'BELOW', 'CHASE',
    'DANCE', 'ENTRY', 'FLASH', 'GLASS', 'HOUSE', 'INPUT', 'JOKER', 'KNOCK',
    'LATCH', 'MARCH', 'NORTH', 'PILOT', 'QUOTE', 'ROUTE', 'SHINE', 'TRACE',
    'USAGE', 'VALUE', 'WHALE', 'ACORN', 'BLEND', 'CRANE', 'DWELL', 'ELBOW',
    'FLINT', 'GRASP', 'HONEY', 'JELLY', 'KNEEL', 'LLAMA', 'MERRY', 'NYMPH',
    'OVERT', 'PRISM', 'QUART', 'ROYAL', 'SLATE', 'TULIP', 'URBAN', 'VIVID',
    'WALTZ', 'ALBUM', 'BLUFF', 'CLIMB', 'DWARF', 'EMBER', 'FJORD', 'GLIDE',
    'HASTE', 'IGLOO', 'KAYAK', 'LYRIC', 'MOUND', 'NUDGE', 'OPERA', 'PLUCK',
    'QUIRK', 'ROBIN', 'SLOPE', 'TWIST', 'VOWEL', 'WRIST', 'XYLEM', 'YOGIC',
    'ZIPPY', 'ADEPT', 'BLISS', 'CRISP', 'DUSKY', 'EPOCH', 'FLUME', 'GLEAM',
    'HUMID', 'INEPT', 'JOUST', 'KITTY', 'LOFTY', 'MOURN', 'NASTY', 'OVOID',
    'PLUME', 'QUAIL', 'ROGUE', 'SNARL', 'TRUCE', 'USURP', 'VENOM', 'WRATH',
    'AGILE', 'BLARE', 'CIVIC', 'DROLL', 'EVOKE', 'FROST', 'GRIME', 'HAVOC',
    'IRATE', 'JUICY', 'LURCH', 'MIRTH', 'NOBLE', 'OPTIC', 'PLUSH', 'QUAKE',
    'RUSTY', 'SNOWY', 'THUMB', 'UNCLE', 'VIGOR', 'WISPY', 'XENIA', 'YOGUR',
    'ZILCH', 'AMBER', 'BRIEF', 'CLOVE', 'DRIFT', 'ELATE', 'FROCK', 'GROVE',
    'HINGE', 'ITCHY', 'KNEAD', 'LEASH', 'MOSSY', 'NICHE', 'OUTDO', 'PERCH',
    'QUILL', 'ROAST', 'SCOUT', 'TRAIT', 'UNZIP', 'VAPOR', 'WOODY', 'ANVIL',
    'BROOM', 'CABIN', 'DITTO', 'ENVOY', 'FLASK', 'GRUNT', 'KINKY', 'LUMEN',
    'MAGMA', 'OXBOW', 'PETAL', 'RODEO', 'SWIRL', 'TROVE', 'UNFED', 'VYING',
    'WOVEN', 'XERIC', 'YOKEL', 'ZONAL', 'APRON', 'BLOAT', 'CREDO', 'DRAIN',
    'GRAVY', 'HUMUS', 'INLAY', 'NYLON', 'OVARY', 'PLANK', 'QUASH', 'SLOSH',
    'TRIPE', 'USHER', 'VOMIT', 'WHIFF', 'ALIBI', 'GLEAN', 'PEACE', 'QUEST',
    'ROUND', 'SMART', 'TABLE', 'ZONES', 'ABOUT', 'BLANK', 'CRAFT', 'DEPTH',
    'ERROR', 'FRESH', 'GLOBE', 'IDEAL', 'JOINT', 'KNOWN', 'LUNAR', 'METAL',
    'NERVE', 'ORBIT', 'PRIME', 'QUITE', 'SOUND', 'TRUST', 'WORTH', 'ARISE',
    'BRAVE', 'CHESS', 'EMPTY', 'FOCUS', 'GIANT', 'HONOR', 'JUDGE', 'KARMA',
    'LUNCH', 'NEXUS', 'OWNER', 'PROVE', 'QUERY', 'RELAX', 'SHADE', 'TORCH',
    'WIDTH', 'YOUNG', 'ADAPT', 'BOOST', 'DEALT', 'ENTER', 'FIELD', 'GUARD',
    'HABIT', 'INDEX', 'JEWEL', 'KNACK', 'LABEL', 'MOUTH', 'NOISE', 'OFFER',
    'PATCH', 'THICK', 'VAULT', 'WRECK', 'CHART', 'FINAL', 'GRADE', 'HELPS',
    'INTRO', 'LAYER', 'MIXER', 'OPENS', 'PIXEL', 'QUOTA', 'RAZOR', 'SHIFT',
    'TEMPO', 'UPSET', 'WORRY', 'BADGE', 'CROWN', 'DAILY', 'EQUAL', 'FAINT',
    'GAINS', 'HANDY', 'INFER', 'KIOSK', 'LEGAL', 'MANGO', 'OASIS', 'RANCH',
    'SILKY', 'TANGO', 'UNIFY', 'VIRAL', 'WASTE', 'YEARN', 'ARENA', 'BURST',
    'CLAIM', 'DECOR', 'EAGER', 'FLOCK', 'HURRY', 'IMPLY', 'JEANS', 'LEASE',
    'MOTOR', 'ONION', 'PLUMB', 'RATIO', 'THANK', 'UNITE', 'VALID', 'WEARY',
    'DENIM', 'FRAME', 'GRIND', 'HOBBY', 'IRONY', 'JUMPS', 'KITES', 'MINER',
    'NOTCH', 'ORDER', 'PRANK', 'RINGS', 'STUNT', 'UTTER', 'VINYL', 'WHISK',
    'YELLS', 'ACTOR', 'CREEK', 'DEMOS', 'FLUID', 'GRILL', 'HARSH', 'JOLTS',
    'LODGE', 'MOTTO', 'NINTY', 'OUTER', 'PLAYS', 'QUEUE', 'REALM', 'SWORD',
    'TYPES', 'USUAL', 'WINGS', 'YARDS', 'ARROW', 'BLAZE', 'CHIPS', 'DRAFT',
    'FERNS', 'ICONS', 'MEALS', 'ORGAN', 'PLOTS', 'SLOTS', 'TUNES', 'WOODS',
    'YOURS', 'ALERT', 'BLOOM', 'DOVES', 'EXITS', 'FONTS', 'GREET', 'HINTS',
    'ITEMS', 'KINGS', 'LANDS', 'MINTS', 'NOTES', 'OUNCE', 'PILES', 'ROADS',
    'SCALE', 'TILES', 'UMBER', 'VENUE', 'WAVES', 'YEAST', 'AFTER', 'BONUS',
    'ARDOR', 'CHIME', 'ELOPE', 'GLOSS', 'HASTY', 'INNER', 'LOOPY', 'TWANG',
    'WRING', 'ABIDE', 'BRICK', 'CHEER', 'DINER', 'EVADE', 'FABLE', 'GIANT',
    'HORSE', 'ISSUE', 'JOLLY', 'KETCH', 'LOGIC', 'MINOR', 'NERVE', 'OUGHT',
    'PASTE', 'QUOTH', 'REBEL', 'SETUP', 'TRICK', 'UNITE', 'VAGUE', 'WEAVE',
    'XEROX', 'YEARN', 'ZONED', 'ALIEN', 'BLAME', 'CARGO', 'DEVIL', 'EIGHT',
    'FAVOR', 'GLOVE', 'HOVER', 'INFER', 'JAUNT', 'KNELT', 'LOVED', 'MIXER',
    'NOBLE', 'ORBIT', 'PHASE', 'QUERY', 'RIDER', 'SHELL', 'TIMID', 'URBAN',
    'VALID', 'WITCH', 'XENON', 'YOUTH', 'ZONES', 'AWFUL', 'BENCH', 'CROSS',
    'DOUGH', 'ERASE', 'FUNGI', 'GHOST', 'HITCH', 'INKED', 'JOINT', 'KNOTS',
    'LOOSE', 'MATIC', 'NERVY', 'OPENS', 'PRUNE', 'QUEST', 'RISKY', 'SALTY',
    'TAXES', 'UPPED', 'VIXEN', 'WAGER', 'XYLAN', 'YUCKY', 'ZONES', 'ALBUM',
    'BUMPY', 'CLASP', 'DOWNY', 'ELFIN', 'FOGGY', 'GIZMO', 'HAMMY', 'ICIER',
    'JAZZY', 'KLUTZ', 'LUMPY', 'MADLY', 'NERDS', 'OAKEN', 'PUSHY', 'QUIRK',
    'RAMPS', 'SASSY', 'TOPAZ', 'UNMET', 'VIPER', 'WIMPY', 'XRAYS', 'YODEL',
    'ZIPPY', 'ACTED', 'BLUNT', 'CRANK', 'DINGY', 'EVENT', 'FUNKY', 'GRIMM',
    'HIPPO', 'IDIOM', 'JUROR', 'KNOBS', 'LUMPS', 'MYTHS', 'NEXUS', 'OVENS',
    'PIVOT', 'QUEST', 'RETRY', 'SKUNK', 'TACOS', 'UNDER', 'VELDT', 'WALTZ',
    'XYLOS', 'YOLKS', 'ZEROS', 'ALLEY', 'BLOBS', 'CLUBS', 'DADDY', 'EXCEL',
    'FIFTH', 'GOOFY', 'HOBBY', 'IRONY', 'JOKED', 'KIDDO', 'LEAKY', 'MACHO',
    'NUTTY', 'ODDLY', 'PENNY', 'QUIPS', 'RATTY', 'SILLY', 'TITTY', 'UNDUE',
    'VERGE', 'WIMPS', 'XEROX', 'YUCKY', 'ZESTS'
];
        // Check if running in Discord
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('frame_id') || urlParams.get('instance_id')) {
            discordStatus.style.display = 'block';
            console.log('Running in Discord Activity!');
        }

// ============= GAME 1: BREAKOUT =============
function initBreakout() {
    gameState = {
        paddle: { x: 550, y: 550, width: 100, height: 15, speed: 8 },
        ball: { x: 600, y: 535, vx: 0, vy: 0, radius: 8, launched: false },
        bricks: [],
        lives: 3,
        keys: { left: false, right: false, launch: false }
    };

    // Create bricks (8 rows x 14 columns) - centered with 20px margins
    const brickAreaWidth = 1200 - 40;
    const brickWidth = 70;
    const brickSpacing = 10;
    const bricksPerRow = Math.floor((brickAreaWidth - brickSpacing) / (brickWidth + brickSpacing));
    const startX = (1200 - (bricksPerRow * (brickWidth + brickSpacing) - brickSpacing)) / 2;
    
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < bricksPerRow; col++) {
            gameState.bricks.push({
                x: startX + col * (brickWidth + brickSpacing),
                y: row * 30 + 50,
                width: brickWidth,
                height: 25,
                alive: true,
                hit: false
            });
        }
    }
    
    updateUI();
}

function updateBreakout() {
    if (gameState.gameOver) return;
    
    const { paddle, ball, bricks } = gameState;

    // Paddle movement
    if (gameState.keys.left && paddle.x > 20) paddle.x -= paddle.speed;
    if (gameState.keys.right && paddle.x < 1200 - paddle.width - 20) paddle.x += paddle.speed;

    // Launch ball with space
    if (!ball.launched && gameState.keys.launch) {
        ball.vx = 7;
        ball.vy = -7;
        ball.launched = true;
        gameState.keys.launch = false;
    }

    // Keep ball on paddle before launch
    if (!ball.launched) {
        ball.x = paddle.x + paddle.width / 2;
        ball.y = paddle.y - ball.radius;
    } else {
        // Ball movement
        ball.x += ball.vx;
        ball.y += ball.vy;

        // Wall collision
        if (ball.x - ball.radius < 20 || ball.x + ball.radius > 1200 - 20) ball.vx *= -1;
        if (ball.y - ball.radius < 0) ball.vy *= -1;

        // Paddle collision
        if (ball.y + ball.radius > paddle.y && 
            ball.x > paddle.x && ball.x < paddle.x + paddle.width &&
            ball.vy > 0) {
            ball.vy *= -1;
            const hitPos = (ball.x - paddle.x) / paddle.width;
            ball.vx = (hitPos - 0.5) * 14;
        }

        // Brick collision - only check alive bricks
        for (let brick of bricks) {
            if (!brick.alive) continue;
            
            if (ball.x + ball.radius > brick.x && ball.x - ball.radius < brick.x + brick.width &&
                ball.y + ball.radius > brick.y && ball.y - ball.radius < brick.y + brick.height) {
                brick.alive = false;
                brick.hit = true;
                ball.vy *= -1;
                break;
            }
        }

        // Ball falls
        if (ball.y > 600) {
            gameState.lives--;
            if (gameState.lives <= 0) {
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('GAME OVER!', 'You ran out of lives!');
                }, 100);
            } else {
                // Reset ball on paddle
                ball.x = paddle.x + paddle.width / 2;
                ball.y = paddle.y - ball.radius;
                ball.vx = 0;
                ball.vy = 0;
                ball.launched = false;
            }
            updateUI();
            return;
        }
    }

    // Win condition - break all bricks
    if (bricks.every(b => !b.alive)) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('YOU WIN!', 'All bricks destroyed!');
        }, 100);
        return;
    }

    updateUI();
}

function drawBreakout() {
    // Same background as space shooter
    const gradient = ctx.createLinearGradient(0, 0, 0, 800);
    gradient.addColorStop(0, '#0a1628');      // Dark blue top
    gradient.addColorStop(0.5, '#0d1b2a');    // Dark blue-green middle
    gradient.addColorStop(0.5, '#0f2027');    // Dark green-blue middle
    gradient.addColorStop(1, '#0a3d2c');      // Dark green bottom
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1200, 800);

    const { paddle, ball, bricks } = gameState;

    // Draw bricks - only draw alive ones, broken ones show as green briefly
    for (let brick of bricks) {
        if (!brick.alive && brick.hit) {
            // Draw broken brick as green (briefly visible)
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
            ctx.strokeStyle = '#00cc00';
            ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
        } else if (brick.alive) {
            // Draw alive brick as white
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
            ctx.strokeStyle = '#cccccc';
            ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
        }
    }

    // Draw paddle (white)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

    // Draw ball (WHITE instead of red)
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();

    // Draw launch instruction - centered for 1200px
    if (!gameState.ball.launched) {
        ctx.fillStyle = '#ffff00';
        ctx.font = '20px Arial';
        ctx.fillText('Press SPACE to launch ball', 500, 300);
    }
}

        // ============= GAME 2: SPACE SHOOTER =============
        function initAsteroids() {
            gameState = {
                ship: { y: 300, speed: 6 },
                asteroids: [],
                bullets: [],
                ammo: 30,
                lives: 3,
                asteroidsDestroyed: 0,
                asteroidsToDestroy: 50,
                spawnTimer: 0,
                keys: { up: false, down: false, shoot: false }
            };
            
            updateUI();
        }
function updateAsteroids() {
    if (gameState.gameOver) return;
    const { ship, asteroids, bullets } = gameState;

    // Ship movement
    if (gameState.keys.up && ship.y > 20) ship.y -= ship.speed;
    if (gameState.keys.down && ship.y < 580) ship.y += ship.speed;

    // Shooting
    if (gameState.keys.shoot && gameState.ammo > 0) {
        bullets.push({ x: 80, y: ship.y });
        gameState.ammo--;
        gameState.keys.shoot = false;
    }

    // Spawn asteroids
    gameState.spawnTimer++;
    if (gameState.spawnTimer > 40) {
        gameState.spawnTimer = 0;
        
        const rand = Math.random();
        let type = 'regular';
        if (rand < 0.10) type = 'bomb';
        else if (rand < 0.25) type = 'ammo';
        
        asteroids.push({
            x: 1200,
            y: Math.random() * 560 + 20,
            speed: Math.random() * 3 + 2,
            type: type,
            size: 20
        });
    }

    // Update bullets
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].x += 10;
        if (bullets[i].x > 1200) bullets.splice(i, 1);
    }

    // Update asteroids
    for (let i = asteroids.length - 1; i >= 0; i--) {
        asteroids[i].x -= asteroids[i].speed;
        
        // Check bullet collision
        for (let j = bullets.length - 1; j >= 0; j--) {
            const dx = asteroids[i].x - bullets[j].x;
            const dy = asteroids[i].y - bullets[j].y;
            if (Math.sqrt(dx*dx + dy*dy) < 20) {
                if (asteroids[i].type === 'bomb') {
                    const bombToShipDx = asteroids[i].x - 80;
                    const bombToShipDy = asteroids[i].y - ship.y;
                    const actualDistance = Math.sqrt(bombToShipDx*bombToShipDx + bombToShipDy*bombToShipDy);
                    
                    if (actualDistance <= 25) {
                        gameState.lives -= 2;
                    }
                    asteroids.splice(i, 1);
                    bullets.splice(j, 1);
                    break;
                } else if (asteroids[i].type === 'ammo') {
                    gameState.ammo += 5;
                    gameState.asteroidsDestroyed++;
                    asteroids.splice(i, 1);
                    bullets.splice(j, 1);
                    break;
                } else {
                    gameState.ammo += 2;
                    gameState.asteroidsDestroyed++;
                    asteroids.splice(i, 1);
                    bullets.splice(j, 1);
                    break;
                }
            }
        }
        
        if (!asteroids[i]) continue;

        // Direct collision with ship
        if (asteroids[i].type === 'bomb') {
            const bombToShipDx = asteroids[i].x - 80;
            const bombToShipDy = asteroids[i].y - ship.y;
            const actualDistance = Math.sqrt(bombToShipDx*bombToShipDx + bombToShipDy*bombToShipDy);
            
            if (actualDistance <= 25) {
                gameState.lives -= 2;
                asteroids.splice(i, 1);
                continue;
            }
        }

        // Asteroid/Bomb passed left side
        if (asteroids[i].x < -30) {
            if (asteroids[i].type === 'regular' || asteroids[i].type === 'ammo') {
                gameState.lives -= 1;
            }
            asteroids.splice(i, 1);
        }
    }
    
    // Check win/lose conditions
    if (gameState.lives <= 0) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('GAME OVER!', `Asteroids Destroyed: ${gameState.asteroidsDestroyed}/50`);
        }, 100);
        return;
    }
    
    if (gameState.asteroidsDestroyed >= gameState.asteroidsToDestroy) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('YOU WIN!', `Destroyed all ${gameState.asteroidsToDestroy} asteroids!`);
        }, 100);
        return;
    }

    updateUI();
}

        function drawAsteroids() {
    // Background
    const gradient = ctx.createLinearGradient(0, 0, 0, 800);
    gradient.addColorStop(0, '#0a1628');      // Dark blue top
    gradient.addColorStop(0.5, '#0d1b2a');    // Dark blue-green middle
    gradient.addColorStop(0.5, '#0f2027');    // Dark green-blue middle
    gradient.addColorStop(1, '#0a3d2c');      // Dark green bottom
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1200, 800);

    const { ship, asteroids, bullets } = gameState;

// Draw ship with rotation
if (spritesLoaded && sprites.ship.complete) {
    ctx.save();
    ctx.translate(65, ship.y); // Move to ship position
    ctx.rotate(Math.PI / 2); // Rotate 90 degrees clockwise
    ctx.drawImage(sprites.ship, -25, -20, 50, 40); // Center the image
    ctx.restore();
} else {
    // Fallback triangle
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.moveTo(50, ship.y);
    ctx.lineTo(80, ship.y - 15);
    ctx.lineTo(80, ship.y + 15);
    ctx.closePath();
    ctx.fill();
}

// Draw bullets (replace the rectangle code)
for (let bullet of bullets) {
    if (spritesLoaded && sprites.bullet.complete) {
        ctx.drawImage(sprites.bullet, bullet.x, bullet.y - 5, 20, 10); // x, y, width, height
    } else {
        // Fallback rectangle if sprite not loaded
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(bullet.x, bullet.y - 2, 15, 4);
    }
}

    // Draw asteroids with different types
    for (let ast of asteroids) {
        if (ast.type === 'bomb') {
            // Yellow egg-shaped bomb
            ctx.fillStyle = '#FFD700';
            ctx.strokeStyle = '#FFA500';
            ctx.lineWidth = 2;
            
            // Draw egg/oval shape
            ctx.beginPath();
            ctx.ellipse(ast.x, ast.y, ast.size * 0.9, ast.size * 1.1, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Add darker yellow spots for texture
            ctx.fillStyle = '#FFB700';
            ctx.beginPath();
            ctx.arc(ast.x - 5, ast.y - 5, 4, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ast.x + 6, ast.y + 4, 3, 0, Math.PI * 2);
            ctx.fill();
            
        } else {
            // Regular/Ammo asteroid - circular with craters
            ctx.fillStyle = '#888';
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.arc(ast.x, ast.y, ast.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Add darker craters for texture
            ctx.fillStyle = '#666';
            ctx.beginPath();
            ctx.arc(ast.x - 4, ast.y - 3, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(ast.x + 5, ast.y + 2, 2, 0, Math.PI * 2);
            ctx.fill();
            
            // Add green center for ammo type
            if (ast.type === 'ammo') {
                ctx.fillStyle = '#00ff00';
                ctx.strokeStyle = '#00cc00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(ast.x, ast.y, ast.size * 0.35, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
    }
}

        // ============= GAME 3: TOWER OF HANOI =============
function initHanoi() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        towers: [
            [5, 4, 3, 2, 1],
            [],
            []
        ],
        dragging: null,
        moves: 0,
        timeLeft: 65,
        startTime: settings.skipIntros ? Date.now() : null
    };
    
    updateUI();
}

function updateHanoi() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene === 'playing' && gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        gameState.timeLeft = Math.max(0, 65 - elapsedSeconds);
        
        if (gameState.timeLeft <= 0) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('TIME UP!', `Moves: ${gameState.moves}`);
            }, 100);
            return;
        }

        // FIXED: Proper win condition check
        if (gameState.towers[2].length === 5) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK COMPLETED', `Moves: ${gameState.moves} | Time: ${Math.floor(65 - gameState.timeLeft)}s`);
            }, 100);
            return; // Add return to stop further execution
        }
    }
    
    updateUI();
}

function drawHanoi() {
//Win screen
if (currentScene === 'success') {
    ctx.fillStyle = '#35330f';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.fillStyle = '#00ff00';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('COMIC_BOOK __HEIST__', 30, 50);
    
    ctx.textAlign = 'right';
    ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
    
    const buttonX = 60;
    const buttonY = 230;
    
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#00ff00';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('//SUCCESS', buttonX + 40, buttonY + 8);
    
    return;
}
    // Intro screen
    if (currentScene === 'intro') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 800);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('COMIC_BOOK __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('CHANGE_PERMS', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Countdown screen
    if (currentScene === 'countdown') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 800);
        
        ctx.strokeStyle = '#00ff0030';
        ctx.lineWidth = 1;
        for (let x = 0; x < 1200; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, 800);
            ctx.stroke();
        }
        for (let y = 0; y < 800; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(1200, y);
            ctx.stroke();
        }
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GET READY', 600, 380);
        
        const elapsed = (Date.now() - countdownStart) / 1000;
        const progress = Math.max(0, 1 - (elapsed / 5));
        
        const barWidth = 800;
        const barX = 200;
        const barY = 550;
        
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(barX, barY, barWidth, 25);
        
        const currentWidth = barWidth * progress;
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, currentWidth, 25);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(barX, barY, barWidth, 25);
        
        return;
    }
    
    // Playing screen
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, 1200, 800);
    
    ctx.strokeStyle = '#00ff0030';
    ctx.lineWidth = 1;
    for (let x = 0; x < 1200; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 800);
        ctx.stroke();
    }
    for (let y = 0; y < 800; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(1200, y);
        ctx.stroke();
    }

    ctx.fillStyle = '#00ff00';
    ctx.font = '32px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SOLVE THE PUZZLE', 600, 50);

   // Timer - match Avoid Obstacles style and position below horizontal line
const timerWidth = 800;
const timerX = (1200 - timerWidth) / 2;
const timerY = 90; // KEEP THIS THE SAME - timer stays in original position
const progress = Math.max(0, gameState.timeLeft / 65);

ctx.fillStyle = '#2a2a2a';
ctx.fillRect(timerX, timerY, timerWidth, 15);

const currentWidth = timerWidth * progress;
ctx.fillStyle = '#8ce023';
ctx.fillRect(timerX, timerY, currentWidth, 15);


    // Draw towers (MOVED UP - adjusted Y positions)
    for (let t = 0; t < 3; t++) {
        const x = 300 + t * 300;
        
        const poleGradient = ctx.createLinearGradient(x - 15, 300, x + 15, 300); // CHANGED from 350 to 300
        poleGradient.addColorStop(0, '#00ff0060');
        poleGradient.addColorStop(0.5, '#0066ff');
        poleGradient.addColorStop(1, '#00ff0060');
        
        ctx.fillStyle = poleGradient;
        ctx.fillRect(x - 15, 300, 30, 250); // CHANGED from 350 to 300
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(x - 15, 300, 30, 250); // CHANGED from 350 to 300

        const tower = gameState.towers[t];
        for (let i = 0; i < tower.length; i++) {
            const ringSize = tower[i];
            const width = ringSize * 40 + 40;
            const height = 35;
            const y = 515 - i * 40; // CHANGED from 565 to 515
            
            const ringGradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
            ringGradient.addColorStop(0, '#00ff0020');
            ringGradient.addColorStop(0.5, '#00ff0040');
            ringGradient.addColorStop(1, '#00ff0020');
            
            ctx.fillStyle = ringGradient;
            ctx.fillRect(x - width/2, y, width, height);
            
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 4;
            ctx.strokeRect(x - width/2, y, width, height);
        }
    }
    
    const platformY = 550; // CHANGED from 600 to 550
    const platformWidth = 900;
    const platformX = (1200 - platformWidth) / 2;
    const platformHeight = 30;
    
    const platformGradient = ctx.createLinearGradient(platformX, platformY, platformX, platformY + platformHeight);
    platformGradient.addColorStop(0, '#00ff0060');
    platformGradient.addColorStop(0.5, '#0066ff');
    platformGradient.addColorStop(1, '#00ff0060');
    
    ctx.fillStyle = platformGradient;
    ctx.fillRect(platformX, platformY, platformWidth, platformHeight);
    
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.strokeRect(platformX, platformY, platformWidth, platformHeight);
    
    if (gameState.dragging) {
        const ringSize = gameState.dragging.ring;
        const width = ringSize * 40 + 40;
        const height = 35;
        const x = gameState.dragging.x;
        const y = gameState.dragging.y;
        
        const dragGradient = ctx.createLinearGradient(x - width/2, y, x + width/2, y);
        dragGradient.addColorStop(0, '#00ff0040');
        dragGradient.addColorStop(0.5, '#00ff0080');
        dragGradient.addColorStop(1, '#00ff0040');
        
        ctx.fillStyle = dragGradient;
        ctx.fillRect(x - width/2, y, width, height);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 4;
        ctx.strokeRect(x - width/2, y, width, height);
    }
}

function getTowerAt(x, y) {
    // Updated Y bounds to match new tower positions (300 instead of 350)
    if (y < 300 || y > 550) return -1; // CHANGED from 350/650 to 300/550
    
    if (x > 220 && x < 380) return 0;
    else if (x > 520 && x < 680) return 1;
    else if (x > 820 && x < 980) return 2;
    
    return -1;
}

function getRingAt(x, y) {
    for (let t = 0; t < 3; t++) {
        const tower = gameState.towers[t];
        if (tower.length === 0) continue;
        
        const towerX = 300 + t * 300;
        const topRingIndex = tower.length - 1;
        const ringSize = tower[topRingIndex];
        const width = ringSize * 40 + 40;
        const height = 35;
        const ringY = 515 - topRingIndex * 40; // CHANGED from 565 to 515
        
        if (x >= towerX - width/2 && x <= towerX + width/2 &&
            y >= ringY && y <= ringY + height) {
            return { towerIndex: t, ringIndex: topRingIndex };
        }
    }
    return null;
}
        function startDragHanoi(x, y) {
            const ringInfo = getRingAt(x, y);
            if (!ringInfo) return;
            
            const ring = gameState.towers[ringInfo.towerIndex][ringInfo.ringIndex];
            
            gameState.dragging = {
                ring: ring,
                fromTower: ringInfo.towerIndex,
                x: x,
                y: y
            };
            
            // Remove from tower immediately when dragging starts
            gameState.towers[ringInfo.towerIndex].pop();
        }

        function dropHanoi(x, y) {
            if (!gameState.dragging) return;
            
            const toTower = getTowerAt(x, y);
            const ring = gameState.dragging.ring;
            
            if (toTower !== -1) {
                const topRing = gameState.towers[toTower].length > 0 
                    ? gameState.towers[toTower][gameState.towers[toTower].length - 1] 
                    : null;
                
                // Valid move?
                if (!topRing || ring < topRing) {
                    gameState.towers[toTower].push(ring);
                    gameState.moves++;
                } else {
                    // Invalid move, return to original tower
                    gameState.towers[gameState.dragging.fromTower].push(ring);
                }
            } else {
                // Dropped outside valid area, return to original tower
                gameState.towers[gameState.dragging.fromTower].push(ring);
            }
            
            gameState.dragging = null;
        }

        // ============= GAME 4: WORDLE =============
function initWordle() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        targetWord: WORDS[Math.floor(Math.random() * WORDS.length)],
        guesses: Array(6).fill().map(() => ({ letters: Array(5).fill(''), result: Array(5).fill('') })),
        currentGuess: '',
        currentRow: 0,
        gameOver: false,
        timeLeft: 600,
        startTime: settings.skipIntros ? Date.now() : null
    };
    console.log('Target word:', gameState.targetWord);
    updateUI();
}
function updateWordle() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene === 'playing' && gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        gameState.timeLeft = Math.max(0, 600 - elapsedSeconds);
        
        if (gameState.timeLeft <= 0) {
            endGame('TIME UP!', `The password was: ${gameState.targetWord}`);
            return;
        }
    }
    
    updateUI();
}

function drawWordle() {
//Win screen
if (currentScene === 'success') {
    ctx.fillStyle = '#35330f';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.fillStyle = '#00ff00';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('COMIC_BOOK __HEIST__', 30, 50);
    
    ctx.textAlign = 'right';
    ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
    
    const buttonX = 60;
    const buttonY = 230;
    
    ctx.fillStyle = '#00ff00';
    ctx.beginPath();
    ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = '#00ff00';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('//SUCCESS', buttonX + 40, buttonY + 8);
    
    return;
}
    // Intro screen
    if (currentScene === 'intro') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 800);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('COMIC_BOOK __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('OPEN_SAFE', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Countdown screen
    if (currentScene === 'countdown') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 800);
        
        ctx.strokeStyle = '#00ff0030';
        ctx.lineWidth = 1;
        for (let x = 0; x < 1200; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, 800);
            ctx.stroke();
        }
        for (let y = 0; y < 800; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(1200, y);
            ctx.stroke();
        }
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GET READY', 600, 380);
        
        const elapsed = (Date.now() - countdownStart) / 1000;
        const progress = Math.max(0, 1 - (elapsed / 5));
        
        const barWidth = 800;
        const barX = 200;
        const barY = 550;
        
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(barX, barY, barWidth, 25);
        
        const currentWidth = barWidth * progress;
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, currentWidth, 25);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(barX, barY, barWidth, 25);
        
        return;
    }
    
    // Playing screen
    ctx.fillStyle = '#121213';
    ctx.fillRect(0, 0, 1200, 800);

    ctx.fillStyle = '#fff';
    ctx.font = '32px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GUESS THE PASSWORD', 600, 60);
    
    const timerWidth = 800;
    const timerX = 200;
    const timerY = 80;
    const progress = Math.max(0, gameState.timeLeft / 600);
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 20);
    
    const currentWidth = timerWidth * progress;
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(timerX, timerY, currentWidth, 20);
    
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 3;
    ctx.strokeRect(timerX, timerY, timerWidth, 20);

    const boardWidth = 5 * 80;
    const startX = (1200 - boardWidth) / 2;
    
    for (let i = 0; i < 6; i++) {
        const guess = gameState.guesses[i];
        for (let j = 0; j < 5; j++) {
            const x = startX + j * 80;
            const y = 120 + i * 80;
            
            let color = '#3a3a3c';
            if (guess.result[j] === 'correct') color = '#538d4e';
            else if (guess.result[j] === 'present') color = '#b59f3b';

            ctx.fillStyle = color;
            ctx.fillRect(x, y, 70, 70);
            
            if (guess.letters[j]) {
                ctx.fillStyle = '#fff';
                ctx.font = '32px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(guess.letters[j], x + 35, y + 48);
            }
        }
    }

    if (!gameState.gameOver) {
        const row = gameState.currentRow;
        for (let j = 0; j < 5; j++) {
            const x = startX + j * 80;
            const y = 120 + row * 80;
            
            ctx.strokeStyle = '#565758';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, 70, 70);
            
            if (j < gameState.currentGuess.length) {
                ctx.fillStyle = '#fff';
                ctx.font = '32px "Press Start 2P", monospace';
                ctx.textAlign = 'center';
                ctx.fillText(gameState.currentGuess[j], x + 35, y + 48);
            }
        }
    }

    ctx.fillStyle = '#818384';
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('TYPE AND PRESS ENTER', 600, 720);
}

function handleWordleKey(key) {
    if (gameState.gameOver || currentScene !== 'playing') return; // Add scene check

    if (key === 'BACKSPACE') {
        gameState.currentGuess = gameState.currentGuess.slice(0, -1);
    } else if (key === 'ENTER') {
        if (gameState.currentGuess.length === 5) {
            checkWordleGuess();
        }
    } else if (key.length === 1 && /[A-Z]/.test(key) && gameState.currentGuess.length < 5) {
        gameState.currentGuess += key;
    }
}

       function checkWordleGuess() {
    if (gameState.gameOver) return; // Prevent checking if game is over
    
    const guess = gameState.currentGuess;
    const target = gameState.targetWord;
    
    // Create result array
    const result = Array(5).fill('absent');
    const targetLetters = target.split('');
    const guessLetters = guess.split('');
    
    // First pass: mark correct letters
    for (let i = 0; i < 5; i++) {
        if (guessLetters[i] === targetLetters[i]) {
            result[i] = 'correct';
            targetLetters[i] = null; // Mark as used
        }
    }
    
    // Second pass: mark present letters
    for (let i = 0; i < 5; i++) {
        if (result[i] !== 'correct' && targetLetters.includes(guessLetters[i])) {
            result[i] = 'present';
            targetLetters[targetLetters.indexOf(guessLetters[i])] = null; // Mark as used
        }
    }
    
    // Update current row
    gameState.guesses[gameState.currentRow] = {
        letters: guess.split(''),
        result: result
    };
    
    gameState.currentGuess = '';
    gameState.currentRow++;
    
    if (guess === target) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('YOU WIN!', `Guesses: ${gameState.currentRow}`);
        }, 100);
    } else if (gameState.currentRow >= 6) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('GAME OVER!', `The word was: ${gameState.targetWord}`);
        }, 100);
    }
}

// ============= GAME 5: DESTROY FIREWALL =============
function initFirewall() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        ship: { x: 600, speed: 8 },
        asteroids: [],
        bullets: [],
        asteroidsDestroyed: 0,
        asteroidsToDestroy: 50,
        spawnTimer: 0,
        shootCooldown: 0,  // ADD THIS LINE
        keys: { left: false, right: false, shoot: false }
    };
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}

function updateFirewall() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    const { ship, asteroids, bullets } = gameState;

    // Ship movement (horizontal)
    if (gameState.keys.left && ship.x > 20) ship.x -= ship.speed;
    if (gameState.keys.right && ship.x < 1180) ship.x += ship.speed;

    // Shooting (unlimited) - can rapid fire while holding
    if (gameState.keys.shoot) {
        if (!gameState.shootCooldown || gameState.shootCooldown <= 0) {
            bullets.push({ x: ship.x, y: 580 });
            gameState.shootCooldown = 0.5;
        }
    }

    // Update cooldown
    if (gameState.shootCooldown > 0) {
        gameState.shootCooldown--;
    }

// Reset cooldown when spacebar is released
    if (!gameState.keys.shoot) {
        gameState.shootCooldown = 0;
    }

    // Spawn asteroids from top
    gameState.spawnTimer++;
    if (gameState.spawnTimer > 30 && gameState.asteroidsDestroyed < 50) {
        gameState.spawnTimer = 0;
        
        const zigzag = Math.random() < 0.5;
        
        asteroids.push({
            x: Math.random() * 1160 + 20,
            y: 0,
            speed: Math.random() * 1 + 1.5,
            size: 20,
            zigzag: zigzag,
            zigzagDirection: 1,
            zigzagTimer: 0,
            zigzagSpeed: Math.random() * 2 + 3
        });
    }

    // Update bullets (move up)
    for (let i = bullets.length - 1; i >= 0; i--) {
        bullets[i].y -= 15;
        if (bullets[i].y < 0) bullets.splice(i, 1);
    }

    // Update asteroids (move down)
    for (let i = asteroids.length - 1; i >= 0; i--) {
        asteroids[i].y += asteroids[i].speed;
        
        // Zigzag movement with bounds checking
        if (asteroids[i].zigzag) {
            asteroids[i].zigzagTimer++;
            if (asteroids[i].zigzagTimer > 40) {
                asteroids[i].zigzagDirection *= -1;
                asteroids[i].zigzagTimer = 0;
            }
            asteroids[i].x += asteroids[i].zigzagDirection * asteroids[i].zigzagSpeed;
            
            if (asteroids[i].x < 20) {
                asteroids[i].x = 20;
                asteroids[i].zigzagDirection = 1;
            } else if (asteroids[i].x > 1180) {
                asteroids[i].x = 1180;
                asteroids[i].zigzagDirection = -1;
            }
        }
        
        // Check bullet collision
        for (let j = bullets.length - 1; j >= 0; j--) {
            const dx = asteroids[i].x - bullets[j].x;
            const dy = asteroids[i].y - bullets[j].y;
            if (Math.sqrt(dx*dx + dy*dy) < 20) {
                gameState.asteroidsDestroyed++;
                asteroids.splice(i, 1);
                bullets.splice(j, 1);
                break;
            }
        }
        
        if (!asteroids[i]) continue;
        
        // Asteroid passed bottom
        if (asteroids[i].y > 600) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK FAILED!', `Asteroids Destroyed: ${gameState.asteroidsDestroyed}/50`);
            }, 100);
            return;
        }
    }

    // Win condition
    if (gameState.asteroidsDestroyed >= 50) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK COMPLETED', `All ${gameState.asteroidsToDestroy} destroyed!`);
        }, 100);
        return;
    }

    updateUI();
}


function drawFirewall() {
    // Intro/Countdown screens
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('DESTROY FIREWALL', currentScene === 'countdown');
        return;
    }
    
    // Smaller game area that fits in 600px height, moved up
    const gameWidth = 400;
    const gameHeight = 558;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 40;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Game area background (semi-transparent)
    ctx.fillStyle = 'rgba(26, 26, 26, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);

    // Title above game area
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('DESTROY FIREWALL', 600, 25);

    const { ship, asteroids, bullets } = gameState;

    // Draw ship with sprite (pointing DOWN - no rotation needed)
    const shipX = offsetX + (ship.x / 1200) * gameWidth;
    const shipY = offsetY + gameHeight - 30;
    
    if (spritesLoaded && sprites.ship.complete) {
        // Draw ship normally (pointing down)
        ctx.drawImage(sprites.ship, shipX - 25, shipY - 20, 50, 40);
    } else {
        // Fallback triangle pointing down
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(shipX, shipY + 15); // Tip at bottom
        ctx.lineTo(shipX - 10, shipY - 10); // Top left
        ctx.lineTo(shipX + 10, shipY - 10); // Top right
        ctx.closePath();
        ctx.fill();
    }

    // Draw bullets (pointing UP - vertical rectangles)
    for (let bullet of bullets) {
        const bx = offsetX + (bullet.x / 1200) * gameWidth;
        const by = offsetY + (bullet.y / 600) * gameHeight;
        
        if (spritesLoaded && sprites.bullet.complete) {
            // Draw bullet sprite normally (horizontal)
            ctx.drawImage(sprites.bullet, bx - 10, by - 5, 20, 10);
        } else {
            // Fallback vertical rectangle pointing up
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(bx - 2, by - 15, 4, 15); // Tall rectangle pointing up
        }
    }

    // Draw asteroids (scaled)
    for (let ast of asteroids) {
        const ax = offsetX + (ast.x / 1200) * gameWidth;
        const ay = offsetY + (ast.y / 600) * gameHeight;
        
        ctx.fillStyle = '#888';
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(ax, ay, ast.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
    }
}


// ============= GAME 6: GATHER POWER (SNAKE) =============
function initPower() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    const gridSize = 20;
    const playableWidth = 20;  // 20 columns playable area
    const playableHeight = 20; // 20 rows playable area
    const paddingLeft = 1;     // 1 square padding left
    const paddingRight = 1;    // 1 square padding right
    const paddingTop = 2;      // 2 squares padding top
    const paddingBottom = 3;   // 3 squares padding bottom
    
    const totalWidth = paddingLeft + playableWidth + paddingRight;   // 22 total
    const totalHeight = paddingTop + playableHeight + paddingBottom; // 25 total
    const gameWidth = totalWidth * gridSize;    // 440px
    const gameHeight = totalHeight * gridSize;  // 500px
    
    gameState = {
        snake: [{ x: 10, y: 10 }], // Center of playable area
        direction: { x: 1, y: 0 },
        nextDirection: { x: 1, y: 0 },
        food: null,
        score: 0,
        targetScore: 10,
        moveTimer: 0,
        gridSize: gridSize,
        gridWidth: playableWidth,
        gridHeight: playableHeight,
        paddingLeft: paddingLeft,
        paddingTop: paddingTop,
        gameWidth: gameWidth,
        gameHeight: gameHeight
    };
    if (settings.skipIntros) gameState.startTime = Date.now();
    spawnFood();
    updateUI();
}

function spawnFood() {
    let validPosition = false;
    let food;
    
    // Use the actual grid dimensions from gameState
    while (!validPosition) {
        food = {
            x: Math.floor(Math.random() * gameState.gridWidth),
            y: Math.floor(Math.random() * gameState.gridHeight)
        };
        
        validPosition = !gameState.snake.some(segment => 
            segment.x === food.x && segment.y === food.y
        );
    }
    
    gameState.food = food;
}

function updatePower() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    gameState.moveTimer++;
    if (gameState.moveTimer < 8) return;
    gameState.moveTimer = 0;
    
    // Update direction
    gameState.direction = { ...gameState.nextDirection };
    
    // Move snake
    const head = { ...gameState.snake[0] };
    head.x += gameState.direction.x;
    head.y += gameState.direction.y;
    
    // Check wall collision using grid dimensions
    if (head.x < 0 || head.x >= gameState.gridWidth || 
        head.y < 0 || head.y >= gameState.gridHeight) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED!', `Power Collected: ${gameState.score}/10`);
        }, 100);
        return;
    }
    
    // Check self collision
    if (gameState.snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED!', `Power Collected: ${gameState.score}/10`);
        }, 100);
        return;
    }
    
    gameState.snake.unshift(head);
    
    // Check food collision
    if (head.x === gameState.food.x && head.y === gameState.food.y) {
        gameState.score++;
        if (gameState.score >= 10) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK COMPLETED', 'All power collected!');
            }, 100);
            return;
        }
        spawnFood();
    } else {
        gameState.snake.pop();
    }
    
    updateUI();
}


function drawPower() {
    // Intro/Countdown screens
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('GATHER POWER', currentScene === 'countdown');
        return;
    }
    
    // Calculate game area based on actual playable grid
    const gridSize = gameState.gridSize; // 20px
    const playableWidth = gameState.gridWidth * gridSize; // 20 * 20 = 400px
    const playableHeight = gameState.gridHeight * gridSize; // 20 * 20 = 400px
    
    // Border margins
    const borderLeft = 1;
    const borderRight = 1;
    const borderTop = 3;
    const borderBottom = 3;
    
    // Total canvas size with borders
    const totalCanvasWidth = playableWidth + (borderLeft + borderRight) * gridSize;
    const totalCanvasHeight = playableHeight + (borderTop + borderBottom) * gridSize;
    
    const canvasOffsetX = (1200 - totalCanvasWidth) / 2;
    const canvasOffsetY = 50;
    
    // Playable area offset (inside the border)
    const offsetX = canvasOffsetX + borderLeft * gridSize;
    const offsetY = canvasOffsetY + borderTop * gridSize;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Draw transparent black border around playable area
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(canvasOffsetX, canvasOffsetY, totalCanvasWidth, totalCanvasHeight);
    
    // Game area background - exact size of playable area
    ctx.fillStyle = 'rgba(42, 42, 42, 0.7)';
    ctx.fillRect(offsetX, offsetY, playableWidth, playableHeight);
    
    // Draw grid pattern - only for playable area
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Vertical lines - exactly 20 columns
    for (let col = 0; col <= gameState.gridWidth; col++) {
        ctx.beginPath();
        ctx.moveTo(offsetX + col * gridSize, offsetY);
        ctx.lineTo(offsetX + col * gridSize, offsetY + playableHeight);
        ctx.stroke();
    }
    
    // Horizontal lines - exactly 20 rows
    for (let row = 0; row <= gameState.gridHeight; row++) {
        ctx.beginPath();
        ctx.moveTo(offsetX, offsetY + row * gridSize);
        ctx.lineTo(offsetX + playableWidth, offsetY + row * gridSize);
        ctx.stroke();
    }
    
    // Title above game area
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GATHER POWER', 600, 80);
    
    // Draw CONTINUOUS snake body as SQUARES (no gaps)
    for (let i = 0; i < gameState.snake.length; i++) {
        const segment = gameState.snake[i];
        
        // Head is brighter green, body is darker green
        ctx.fillStyle = i === 0 ? '#00ff00' : '#00cc00';
        ctx.fillRect(
            offsetX + segment.x * gridSize, 
            offsetY + segment.y * gridSize, 
            gridSize, 
            gridSize
        );
    }
    
    // Draw food (white square)
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(
        offsetX + gameState.food.x * gridSize, 
        offsetY + gameState.food.y * gridSize, 
        gridSize, 
        gridSize
    );
// Platform bars below game area - fit to playable area width
    const platformY = canvasOffsetY + totalCanvasHeight + 10; // Below the canvas with border
    const platformHeight = 5;
    const platformGap = 2; // Small gap between bars
    
    // Calculate bar width to fit exactly in playable area
    const totalGaps = 9; // 9 gaps between 10 bars
    const platformBarWidth = (playableWidth - (totalGaps * platformGap)) / 10;
    
    // Black horizontal bar background (full width of playable area)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    ctx.fillRect(offsetX, platformY, playableWidth, platformHeight);
    
    // Draw green bars for score (on top of black bar)
    for (let i = 0; i < gameState.score; i++) {
        const barX = offsetX + i * (platformBarWidth + platformGap);
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, platformY, platformBarWidth, platformHeight);
    }
}

// ============= GAME 7: BYPASS THE FIREWALL (RHYTHM) =============
function initBypass() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        blocks: [],
        keys: { KeyA: false, KeyS: false, KeyK: false, KeyL: false },
        score: 0,
        targetScore: 50,
        spawnTimer: 0,
        lastSpawnTime: 0,
        spawnDelay: 800,
    };
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}

function updateBypass() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Spawn blocks with PROGRESSIVE DIFFICULTY (EASIER VERSION)
    const now = Date.now();
    if (gameState.blocks.length < 50 && now - gameState.lastSpawnTime > gameState.spawnDelay) {
        const keyOptions = ['KeyA', 'KeyS', 'KeyK', 'KeyL'];
        const randomKey = keyOptions[Math.floor(Math.random() * 4)];
        const colors = { KeyA: '#ff8800', KeyS: '#00ff00', KeyK: '#00ccff', KeyL: '#ff00ff' };
        
        gameState.blocks.push({
            key: randomKey,
            y: 0,
            color: colors[randomKey],
            speed: 3
        });
        gameState.lastSpawnTime = now;
        
        // EASIER DIFFICULTY: Start at 800ms, decrease by only 5ms per hit, minimum 400ms
        gameState.spawnDelay = Math.max(400, 800 - (gameState.score * 5));
    }

    // Update blocks
    const gameHeight = 558;
    const offsetY = 40;
    const targetY = offsetY + gameHeight - 50;
    
    for (let i = gameState.blocks.length - 1; i >= 0; i--) {
        gameState.blocks[i].y += gameState.blocks[i].speed;
        
        // Calculate scaled Y position
        const scaledY = offsetY + (gameState.blocks[i].y / 600) * gameHeight;
        
        // Block passed bottom without being hit - game over
        if (scaledY > targetY + 30) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK FAILED!', `Blocks Hit: ${gameState.score}/50`);
            }, 100);
            return;
        }
    }

    updateUI();
}

function drawBypass() {
    // Intro/Countdown screens
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('BYPASS THE FIREWALL', currentScene === 'countdown');
        return;
    }
    
    // Smaller game area that fits in 600px height, moved up
    const gameWidth = 400;
    const gameHeight = 558;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 40;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Game area background
    ctx.fillStyle = 'rgba(26, 26, 26, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);

    // Title above game area
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('BYPASS THE FIREWALL', 600, 25);

    // Draw target boxes at bottom
    const boxWidth = 60;
    const boxHeight = 40;
    const boxY = offsetY + gameHeight - 50;
    const spacing = 80;
    const startX = offsetX + (gameWidth - (spacing * 3 + boxWidth)) / 2;
    
    const positions = { 
        KeyA: startX + spacing * 0 + boxWidth/2, 
        KeyS: startX + spacing * 1 + boxWidth/2, 
        KeyK: startX + spacing * 2 + boxWidth/2, 
        KeyL: startX + spacing * 3 + boxWidth/2 
    };
    const colors = { KeyA: '#ff8800', KeyS: '#00ff00', KeyK: '#00ccff', KeyL: '#ff00ff' };
    const labels = { KeyA: 'A', KeyS: 'S', KeyK: 'K', KeyL: 'L' };

    for (let key in positions) {
        ctx.strokeStyle = colors[key];
        ctx.lineWidth = 2;
        ctx.strokeRect(positions[key] - boxWidth/2, boxY, boxWidth, boxHeight);
        
        ctx.fillStyle = colors[key];
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.fillText(labels[key], positions[key], boxY + 28);
    }

    // Draw falling blocks (simple rectangles)
    for (let block of gameState.blocks) {
        const x = positions[block.key];
        const scaledY = offsetY + (block.y / 600) * gameHeight;
        
        const fallingBlockWidth = 30;
        const fallingBlockHeight = 10;
        
        ctx.fillStyle = block.color;
        ctx.fillRect(x - fallingBlockWidth/2, scaledY, fallingBlockWidth, fallingBlockHeight);
    }
}

// Helper function for boosting game intros
function drawBoostingIntro(title, isCountdown) {
    // Fill with black first
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw background image based on scene with transparency
    ctx.globalAlpha = 0.3; // 30% opacity
    if (!isCountdown && backgrounds.boosting.complete) {
        // Click to start scene - show boosting.png
        ctx.drawImage(backgrounds.boosting, 0, 0, 1200, 600);
    } else if (isCountdown && backgrounds.trojanOS.complete) {
        // Countdown/loading scene - show trojanOS.png
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0; // Reset opacity
    
    if (!isCountdown) {
        // Intro screen - just show title
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(title, 600, 300);
        
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.fillText('CLICK TO START', 600, 340);
    } else {
        // Countdown screen
        const elapsed = (Date.now() - countdownStart) / 1000;
        const progress = Math.min(1, elapsed / 5); // 0 to 1 (loading up)
        const percentage = Math.floor(progress * 100);
        
        // Progress bar settings
        const barWidth = 400;
        const barX = (1200 - barWidth) / 2;
        const barY = 280;
        const barHeight = 20;
        
        // //LOADING IN and percentage on same line above bar
        ctx.fillStyle = '#ffffff';
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//LOADING IN', barX, barY - 15);
        ctx.textAlign = 'right';
        ctx.fillText(`${percentage}%`, barX + barWidth, barY - 15);
        
        // Chunked progress bar (bullet style)
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        const chunkCount = 20;
        const chunkWidth = (barWidth - (chunkCount - 1) * 4) / chunkCount;
        const filledChunks = Math.floor(progress * chunkCount);
        
        ctx.fillStyle = '#00ff00';
        for (let i = 0; i < filledChunks; i++) {
            const chunkX = barX + i * (chunkWidth + 4);
            ctx.fillRect(chunkX, barY, chunkWidth, barHeight);
        }
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // HACK STARTING below bar
        ctx.fillStyle = '#ffffff';
        ctx.font = '18px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('HACK STARTING', 600, barY + 50);
        
        // GET READY below HACK STARTING
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.fillText('GET READY', 600, barY + 80);
    }
}

// Helper function for boosting game end screens
function drawBoostingEndScreen() {
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    if (currentScene === 'hack-success') {
        // Green checkmark
        ctx.fillStyle = '#00ff00';
        ctx.font = '64px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('‚úì', 600, 250);
        
        // HACK COMPLETED text
        ctx.fillStyle = '#ffffff';
        ctx.font = '32px "Press Start 2P", monospace';
        ctx.fillText(gameState.endTitle, 600, 320);
        
        // Subtitle
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText(gameState.endSubtitle, 600, 360);
    } else {
        // Red X for failure
        ctx.fillStyle = '#ff0000';
        ctx.font = '64px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('‚úó', 600, 250);
        
        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = '32px "Press Start 2P", monospace';
        ctx.fillText(gameState.endTitle, 600, 320);
        
        // Subtitle
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText(gameState.endSubtitle, 600, 360);
    }
}

// ============= GAME 8: BLOCK SIGNAL =============
function initBlockSignal() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        circleAngle: 45, // Current angle
        targetAngle: 45, // Target angle for smooth animation
        colors: ['#00ff00', '#ff00ff', '#ff8800', '#00ccff'], // green, purple, orange, cyan
        currentBlock: null,
        score: 0,
        targetScore: 20,
        waitTimer: 0,
        blockSpeed: 2,
        keys: { left: false, right: false }
    };
    
    spawnBlock();
    if (settings.skipIntros) {
    currentScene = 'playing';
    gameState.startTime = Date.now();
    gameState.gameStarted = true;
}
    updateUI();
}

function spawnBlock() {
    const positions = ['top', 'bottom', 'left', 'right'];
    const colors = ['#00ff00', '#ff00ff', '#ff8800', '#00ccff'];
    
    gameState.currentBlock = {
        position: positions[Math.floor(Math.random() * 4)],
        color: colors[Math.floor(Math.random() * 4)],
        distance: 250
    };
}

function updateBlockSignal() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Handle wait timer
    if (gameState.waitTimer > 0) {
        gameState.waitTimer--;
        if (gameState.waitTimer === 0) {
            spawnBlock();
        }
        return;
    }
    
    // Smooth rotation animation - FIXED to handle 360¬∞ wrapping
    if (gameState.circleAngle !== gameState.targetAngle) {
        // Calculate the shortest angular difference
        let diff = gameState.targetAngle - gameState.circleAngle;
        
        // Normalize diff to be between -180 and 180
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        
        const step = 6;
        
        if (Math.abs(diff) < step) {
            gameState.circleAngle = gameState.targetAngle;
        } else if (diff > 0) {
            gameState.circleAngle += step;
        } else {
            gameState.circleAngle -= step;
        }
        
        // Keep circleAngle in 0-360 range
        gameState.circleAngle = (gameState.circleAngle + 360) % 360;
    }
    
    // Move block towards center (slower)
    if (gameState.currentBlock) {
        gameState.currentBlock.distance -= gameState.blockSpeed;
        
        // Check collision when block reaches the circle
        if (gameState.currentBlock.distance <= 100) {
            const blockPosition = gameState.currentBlock.position;
            const blockColor = gameState.currentBlock.color;
            
            // Map position to base angle (0¬∞ = right, 90¬∞ = bottom, 180¬∞ = left, 270¬∞ = top)
            const positionAngles = {
                'right': 0,
                'bottom': 90,
                'left': 180,
                'top': 270
            };
            
            // Get the angle where the block is hitting
            const blockAngle = positionAngles[blockPosition];
            
            // Calculate which segment is at that angle considering circle rotation
            // Normalize the combined angle to 0-360 range
            const hitAngle = (blockAngle - gameState.circleAngle + 360) % 360;
            
            // Determine which segment (0-3) based on the hit angle
            const hitSegment = Math.floor(hitAngle / 90);
            
            if (gameState.colors[hitSegment] === blockColor) {
                // Correct match!
                gameState.score++;
                if (gameState.score >= 20) {
                    gameState.gameOver = true;
                    setTimeout(() => {
                        endGame('HACK COMPLETED', 'All blocks matched!');
                    }, 100);
                    return;
                }
                gameState.waitTimer = 30;
                gameState.currentBlock = null;
            } else {
                // Wrong color - fail
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK FAILED!', `Blocks Matched: ${gameState.score}/20`);
                }, 100);
                return;
            }
        }
    }
    
    updateUI();
}

function getBlockAngle(position) {
    // Return the exact angle for each position
    switch(position) {
        case 'top': return 0;      // 0¬∞ - top
        case 'right': return 90;   // 90¬∞ - right  
        case 'bottom': return 180; // 180¬∞ - bottom
        case 'left': return 270;   // 270¬∞ - left
        default: return 0;
    }
}
function drawBlockSignal() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('BLOCK SIGNAL', currentScene === 'countdown');
        return;
    }
    
    const gameWidth = 400;
    const gameHeight = 558;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 40;
    
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    ctx.fillStyle = 'rgba(26, 26, 26, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('BLOCK SIGNAL', 600, 25);
    
    const centerX = 600;
    const centerY = 320;
    const radius = 100;
    
   // Draw 4-color circle with gaps - aligned with segment logic
const segmentSize = 80; // 80 degrees per color
const gapSize = 10; // 10 degrees gap

for (let i = 0; i < 4; i++) {
    // Start from right (0¬∞) and go counter-clockwise
    const startAngle = (i * 90 + gameState.circleAngle + gapSize/2) * Math.PI / 180;
    const endAngle = ((i + 1) * 90 + gameState.circleAngle - gapSize/2) * Math.PI / 180;
    
    ctx.strokeStyle = gameState.colors[i];
    ctx.lineWidth = 15;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, startAngle, endAngle);
    ctx.stroke();
}
    
    // Draw incoming block
    if (gameState.currentBlock) {
        const blockAngle = getBlockAngle(gameState.currentBlock.position);
        const rad = (blockAngle - 90) * Math.PI / 180;
        const x = centerX + Math.cos(rad) * gameState.currentBlock.distance;
        const y = centerY + Math.sin(rad) * gameState.currentBlock.distance;
        
        ctx.fillStyle = gameState.currentBlock.color;
        ctx.fillRect(x - 15, y - 15, 30, 30);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 15, y - 15, 30, 30);
    }
}

// ============= GAME 9: AVOID OBSTACLES =============
function initAvoidObstacles() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    // Game area positioning
    const gameAreaX = (1200 - 480) / 2; // 360
    const gameAreaY = (600 - 480) / 2; // 60

    gameState = {
        cannonAngle: Math.PI / 2, // Start pointing up (90 degrees)
        bullets: [],
        gameWon: false,
        keys: { left: false, right: false, shoot: false },
        
        // Timer for 50 seconds
        timeLeft: 50,
        startTime: settings.skipIntros ? Date.now() : null,
        
        // Ammo system
        ammo: 12,
        maxAmmo: 12,
        lastShotTime: 0,
        reloadDelay: 2000, // 2 seconds in milliseconds
        
        // Targets (black circles on each protractor) - RANDOM STARTING ANGLES
        radii: [100, 200, 320, 420],
        targets: [
            { 
                arcIndex: 0, 
                angle: Math.random() * Math.PI, // RANDOM starting angle
                radius: 100, 
                speed: 0.005, 
                hit: false, 
                size: 8, 
                color: '#000000' 
            },
            { 
                arcIndex: 1, 
                angle: Math.random() * Math.PI, // RANDOM starting angle
                radius: 200, 
                speed: 0.0075, 
                hit: false, 
                size: 8, 
                color: '#000000' 
            },
            { 
                arcIndex: 2, 
                angle: Math.random() * Math.PI, // RANDOM starting angle
                radius: 320, 
                speed: 0.008, 
                hit: false, 
                size: 8, 
                color: '#000000' 
            },
            { 
                arcIndex: 3, 
                angle: Math.random() * Math.PI, // RANDOM starting angle
                radius: 420, 
                speed: 0.006, // SLOWER SPEED
                hit: false, 
                size: 8, 
                color: '#000000' 
            }
        ],
        
        // Game settings
        centerX: 240, // Center of the 480px game area
        centerY: 480, // Bottom of the 480px game area
        gameAreaX: gameAreaX,
        gameAreaY: gameAreaY,
        gameOver: false
    };
    
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}

function updateAvoidObstacles() {
    if (gameState.gameOver || gameState.gameWon) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Update timer
    if (gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        gameState.timeLeft = Math.max(0, 50 - elapsedSeconds);
        
        if (gameState.timeLeft <= 0) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK FAILED!', `Targets Hit: ${gameState.targets.filter(t => t.hit).length}/4`);
            }, 100);
            return;
        }
    }
    
    const { cannonAngle, targets, bullets, centerX, centerY } = gameState;

    // Cannon rotation
    if (gameState.keys.left) {
        gameState.cannonAngle -= 0.03;
    }
    if (gameState.keys.right) {
        gameState.cannonAngle += 0.03;
    }
    
    // Clamp angle between 0¬∞ (left) and 180¬∞ (right)
    gameState.cannonAngle = Math.max(0, Math.min(Math.PI, gameState.cannonAngle));

       // Shooting with ammo system
    if (gameState.keys.shoot) {
        const currentTime = Date.now();
        
        // Check if we have ammo and enough time has passed since last shot
        if (gameState.ammo > 0 && (currentTime - gameState.lastShotTime) > 200) {
            const bulletSpeed = 5;
            const angle = Math.PI - cannonAngle;
            
            bullets.push({
                x: centerX,
                y: centerY,
                vx: Math.cos(angle) * bulletSpeed,
                vy: -Math.sin(angle) * bulletSpeed,
                radius: 3
            });
            
            gameState.ammo--;
            gameState.lastShotTime = currentTime;
            gameState.keys.shoot = false;
        }
    }
    
    // Reload system - automatically reload after 2 seconds when ammo is 0
    if (gameState.ammo === 0) {
        const currentTime = Date.now();
        if ((currentTime - gameState.lastShotTime) >= gameState.reloadDelay) {
            gameState.ammo = gameState.maxAmmo; // Reload to full ammo
        }
    }

// Update targets with proper boundary checking - ALL TARGETS MOVE (even when hit)
targets.forEach(target => {
    target.angle += target.speed;
    
    const radius = target.radius;
    const targetSize = target.size;
    
    // Calculate angle limits where target stays within 480px width
    // At the edges, target.x should be at least targetSize from edge
    const minX = targetSize;
    const maxX = 480 - targetSize;
    
    // Convert X limits to angles
    // x = centerX + cos(PI - angle) * radius
    // Solve for angle when x = minX and x = maxX
    const leftAngle = Math.PI - Math.acos(Math.max(-1, Math.min(1, (minX - centerX) / radius)));
    const rightAngle = Math.PI - Math.acos(Math.max(-1, Math.min(1, (maxX - centerX) / radius)));
    
    const minAngle = isNaN(leftAngle) ? 0 : Math.max(0, leftAngle);
    const maxAngle = isNaN(rightAngle) ? Math.PI : Math.min(Math.PI, rightAngle);
    
    // Bounce between the calculated visible limits
    if (target.angle > maxAngle) {
        target.angle = maxAngle;
        target.speed = -Math.abs(target.speed);
    } else if (target.angle < minAngle) {
        target.angle = minAngle;
        target.speed = Math.abs(target.speed);
    }
});

// Update bullets
for (let i = bullets.length - 1; i >= 0; i--) {
    bullets[i].x += bullets[i].vx;
    bullets[i].y += bullets[i].vy;
    
    // Remove if out of bounds (relative to game area)
    if (bullets[i].x < 0 || bullets[i].x > 480 || 
        bullets[i].y < 0 || bullets[i].y > 480) {
        bullets.splice(i, 1);
        continue;
    }

    const centerX = gameState.centerX + gameState.gameAreaX;
    const centerY = gameState.centerY + gameState.gameAreaY;
    
    // Check collision with targets - bullets pass through, only change target color
    for (let j = 0; j < targets.length; j++) {
        const target = targets[j];
        if (!target.hit) {
            const targetX = centerX + Math.cos(Math.PI - target.angle) * target.radius;
            const targetY = centerY - Math.sin(target.angle) * target.radius;
            
            const bulletX = bullets[i].x + gameState.gameAreaX;
            const bulletY = bullets[i].y + gameState.gameAreaY;
            
            const dist = Math.sqrt((bulletX - targetX) ** 2 + (bulletY - targetY) ** 2);
            
            if (dist < bullets[i].radius + target.size) {
                target.hit = true; // Change target to green
                
                // Check if all targets are hit
                if (targets.every(t => t.hit)) {
                    gameState.gameWon = true;
                    gameState.gameOver = true;
                    setTimeout(() => {
                        endGame('HACK COMPLETED', 'All targets destroyed!');
                    }, 100);
                    return;
                }
            }
        }
    }
}

updateUI();
}

function drawAvoidObstacles() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('AVOID OBSTACLES', currentScene === 'countdown');
        return;
    }
    
// Black background
ctx.fillStyle = '#000000';
ctx.fillRect(0, 0, 1200, 600);

// Draw trojanOS background with transparency
ctx.globalAlpha = 0.3;
if (backgrounds.trojanOS.complete) {
    ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
}
ctx.globalAlpha = 1.0;


    // Create a 480x480 game area centered in the 1200x600 canvas
    const gameAreaX = (1200 - 480) / 2; // 360
    const gameAreaY = (600 - 480) / 2; // 60
    
// For a 480x480 game area (same as your current setup)
const playableWidth = 480;
const playableHeight = 480;
const gridSize = 20; // Use same grid size as power game

// Border margins (same as power game)
const borderLeft = 1;
const borderRight = 1;
const borderTop = 3;
const borderBottom = 3;

// Total canvas size with borders
const totalCanvasWidth = playableWidth + (borderLeft + borderRight) * gridSize;  //
const totalCanvasHeight = playableHeight + (borderTop + borderBottom) * gridSize; // 

// Position to center the entire bordered area
const canvasOffsetX = (1200 - totalCanvasWidth) / 2 ;  // 
const canvasOffsetY = (600 - totalCanvasHeight) / 2;  // 

// Playable area offset (inside the border)
const offsetX = canvasOffsetX + borderLeft * gridSize;   // 
const offsetY = canvasOffsetY + borderTop * gridSize;    // 

// Draw transparent black border around playable area
ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
ctx.fillRect(canvasOffsetX, canvasOffsetY, totalCanvasWidth, totalCanvasHeight);

// Game area background - exact size of playable area
ctx.fillStyle = 'rgba(42, 42, 42, 0.7)';
ctx.fillRect(offsetX, offsetY, playableWidth, playableHeight);

    ctx.save();
    ctx.beginPath();
    ctx.rect(gameAreaX, gameAreaY, 480, 480);
    ctx.clip();
    
// Draw gradient background inside the game area - from pitch black at top to green at bottom
const gradient = ctx.createLinearGradient(
    gameAreaX, gameAreaY,           // Start at top
    gameAreaX, gameAreaY + 480      // End at bottom
);
gradient.addColorStop(0, '#000000');    // 1. Complete black at top
gradient.addColorStop(0.2, '#000d00');  // 2. Mostly black with hint of green
gradient.addColorStop(0.4, '#001a00');  // 3. Black with some green
gradient.addColorStop(0.7, '#006600');  // 4. Only green no dark
gradient.addColorStop(1, '#00aa00');    // 5. Only green at bottom
ctx.fillStyle = gradient;
ctx.fillRect(gameAreaX, gameAreaY, 480, 480);

    const { cannonAngle, targets, bullets, radii } = gameState;

    const centerX = gameAreaX + 240;
    const centerY = gameAreaY + 480;
  
    // Draw protractors (semi-circles) - GLOWY VERSION
    radii.forEach((radius, index) => {
        // Add glow effect to protractors
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#0f0';
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, Math.PI, 0);
        ctx.stroke();
    });

    // Reset shadow before drawing targets
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    // Draw targets 
    targets.forEach(target => {
        const x = centerX + Math.cos(Math.PI - target.angle) * target.radius;
        const y = centerY - Math.sin(target.angle) * target.radius;
        
        // Minimal glow for targets
        ctx.shadowBlur = 5;
        ctx.shadowColor = target.hit ? '#0f0' : '#000';
        
        ctx.fillStyle = target.hit ? '#0f0' : '#000'; // Black when unhit, Green when hit
        ctx.strokeStyle = target.hit ? '#0f0' : '#0f0'; // White border when unhit, Green when hit
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, target.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
    });

    // Reset shadow completely
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    // Restore context (remove clipping)
    ctx.restore();

    // Draw bullets (outside clipping so they can move freely)
    ctx.fillStyle = '#fff';
    bullets.forEach(bullet => {
        const adjustedX = bullet.x + gameAreaX;
        const adjustedY = bullet.y + gameAreaY;
        ctx.beginPath();
        ctx.arc(adjustedX, adjustedY, bullet.radius, 0, Math.PI * 2);
        ctx.fill();
    });

// Draw cannon (smaller 2D cannon style)
ctx.save();
ctx.translate(centerX, centerY);
ctx.rotate(cannonAngle - Math.PI / 2);

// Cannon barrel (smaller rectangle)
const barrelLength = 30;  // Reduced from 60
const barrelWidth = 5;    // Reduced from 12

ctx.fillStyle = '#00ff00';
ctx.strokeStyle = '#00cc00';
ctx.lineWidth = 2;
ctx.fillRect(-barrelWidth/2, -barrelLength, barrelWidth, barrelLength);
ctx.strokeRect(-barrelWidth/2, -barrelLength, barrelWidth, barrelLength);

// Cannon base (smaller circle)
ctx.fillStyle = '#00ff00';
ctx.strokeStyle = '#00ff00';
ctx.beginPath();
ctx.arc(0, 0, 10, 0, Math.PI * 2);  // Reduced from 15
ctx.fill();
ctx.stroke();

// Wheel decoration (smaller)
ctx.strokeStyle = '#333';
ctx.lineWidth = 1;
for (let i = 0; i < 6; i++) {
    const angle = (Math.PI * 2 / 6) * i;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(Math.cos(angle) * 8, Math.sin(angle) * 8);  // Reduced from 12
    ctx.stroke();
}

ctx.restore();
    
    ctx.shadowBlur = 0;
    ctx.restore();

    // Draw green border around the game area - with glow
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#000';
    ctx.strokeStyle = '#000';
    ctx.strokeRect(gameAreaX, gameAreaY, 480, 480);
    ctx.shadowBlur = 0;

    // Draw title (above the game area)
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('AVOID OBSTACLES', 600, 60);

 // Progress bar timer at bottom (50 seconds) - depleting right to left like Hanoi
    const timerWidth = 480; // Same width as playable area
    const timerX = offsetX; // Align with playable area
    const timerY = offsetY + playableHeight + 25; // Below the game area
    
    // Calculate time progress (assuming you have a timeLeft variable in gameState)
    const totalTime = 50; // 50 seconds total
    const timeLeft = gameState.timeLeft || totalTime; // Use existing or default
    const progress = Math.max(0, timeLeft / totalTime);
    
    // Timer background (full width)
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 5);
    
    // Timer progress (depleting from right to left)
    const currentWidth = timerWidth * progress;
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(timerX, timerY, currentWidth, 5);
    
    // Timer border
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1;
    ctx.strokeRect(timerX, timerY, timerWidth, 5);
    
}

// ============= GAME 10: AVOID WALLS =============

let lastGapAngle = Math.random() * 360;
let lastGapSize = 120; // initial value

function initAvoidWalls() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
  gameState = {
        player: { angle: 0, speed: 12 }, 
        walls: [],
        spawnTimer: 0,
        wallSpeed: 2.6, // Slower wall approach
        score: 0,
        targetScore: 70,
        timerDuration: 50,
        keys: { left: false, right: false }
    };
    
    // Generate initial walls with more spacing
    for (let i = 0; i < 3; i++) {
        spawnWall( i * 90); // More space between walls
    }
    
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}

function spawnWall(distance) {
    const baseGap = 90;
    const scoreFactor = Math.min(gameState.score, 20); // max difficulty scaling
    const gapReduction = scoreFactor * 2; // reduce gap by 2¬∞ per wall
    const variation = Math.random() * 20 - 10; // ¬±10¬∞
    const gapSize = baseGap - gapReduction + variation; 


const minOffset = 40; // min shift so player has to move
const maxOffset = lastGapSize < 110 ? 70 : 110; // max shift allowed
const offset = (Math.random() * (maxOffset - minOffset) + minOffset) * (Math.random() < 0.5 ? 1 : -1);
const gapAngle = (lastGapAngle + offset + 360) % 360;

    lastGapAngle = gapAngle;
    lastGapSize = gapSize;

    const rotationSpeed = (Math.random() * 0.8 + 0.5) * (Math.random() < 0.5 ? 1 : -1);

    gameState.walls.push({
        distance: distance,
        gapAngle: gapAngle,
        gapSize: gapSize,
        currentGapSize: gapSize,
        rotation: 0,
        rotationSpeed: rotationSpeed,
        passed: false
    });
}


function updateAvoidWalls() {
 if (!gameState.startTime) gameState.startTime = Date.now();

    // --- VISUAL TIMER ONLY ---
    gameState.survivedTime = (Date.now() - gameState.startTime) / 1000;
    gameState.remainingTime = Math.max(0, gameState.timerDuration - gameState.survivedTime);
// ========== WIN BY SURVIVING TIMER ==========
if (gameState.remainingTime <= 0 && !gameState.gameOver) {
    gameState.gameOver = true;

   setTimeout(() => {
    endGame("HACK COMPLETED", "Survived all 50 seconds!", true); // last 'true' = show checkmark
}, 100);


    return; 
}


     if (gameState.gameOver) return;
 
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Player rotation
// Player rotation
    if (gameState.keys.left) gameState.player.angle -= gameState.player.speed;
    if (gameState.keys.right) gameState.player.angle += gameState.player.speed;  
    // Update walls (move toward center)
    for (let i = gameState.walls.length - 1; i >= 0; i--) {
        gameState.walls[i].distance -= gameState.wallSpeed;
        // Freeze rotation when walls get close (prevents unfair rotation)
if (gameState.walls[i].distance > 100) {
    // slow rotation while far
    gameState.walls[i].gapAngle = (gameState.walls[i].gapAngle + gameState.walls[i].rotationSpeed * 0.5 + 360) % 360;
} else {
    // freeze rotation and gap
    gameState.walls[i].rotationSpeed = 0;
    gameState.walls[i].currentGapSize = gameState.walls[i].gapSize;
}

        // Check collision
        if (gameState.walls[i].distance <= 30 && gameState.walls[i].distance >= 0) {
            const playerAngle = (gameState.player.angle + 360) % 360;
            const gapStart = (gameState.walls[i].gapAngle - gameState.walls[i].gapSize / 2 + 360) % 360;
            const gapEnd = (gameState.walls[i].gapAngle + gameState.walls[i].gapSize / 2) % 360;
            
            let inGap = false;
            if (gapStart < gapEnd) {
                if (playerAngle >= gapStart && playerAngle <= gapEnd) inGap = true;
            } else {
                if (playerAngle >= gapStart || playerAngle <= gapEnd) inGap = true;
            }
            
            if (!inGap && !gameState.walls[i].passed) {
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK FAILED!', `Walls Passed: ${gameState.score}/70`);
                }, 100);
                return;
            }
        }
        
        // Mark as passed
        if (gameState.walls[i].distance < 0 && !gameState.walls[i].passed) {
            gameState.walls[i].passed = true;
            gameState.score++;    
        }
        
        // Remove walls that are too far past
        if (gameState.walls[i].distance < -50) {
            gameState.walls.splice(i, 1);
        }
    }
    
    // Spawn new walls
 
const baseSpacing = 120;
const scoreFactor = Math.min(gameState.score, 20);

// Check if we need to spawn the next wall based on last wall's distance
let lastWall = gameState.walls[gameState.walls.length - 1];
if (!lastWall || lastWall.distance < 250) { 
    const spawnDistance = lastWall ? lastWall.distance + baseSpacing - scoreFactor * 2 : 150;
    spawnWall(spawnDistance);

        if (gameState.score % 3 === 0 && gameState.wallSpeed < 3) {
    gameState.wallSpeed += 0.015; // every 5 walls, slightly faster
}

    }
    
    updateUI();
}


function drawAvoidWalls() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('AVOID WALLS', currentScene === 'countdown');
        return;
    }
    
    const gameWidth = 600;
    const gameHeight = 600;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = -20;
    
    // BLACK BACKGROUND FIRST
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // THEN trojanOS with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // THEN game area overlay (semi-transparent so trojanOS shows through)
    ctx.fillStyle = 'rgba(26, 26, 26, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
  
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('AVOID WALLS', 600, 25);
    
    const centerX = 600;
    const centerY = 320;
    
    // Draw walls as circles with gaps
    for (let wall of gameState.walls) {
        if (wall.distance < -20 || wall.distance > 250) continue;
        
        const radius = Math.max(10, wall.distance);
        
        ctx.strokeStyle = '#888888';
        ctx.lineWidth = 12;
        
        const segments = 360;
        for (let i = 0; i < segments; i++) {
            const angle = i;
            const gapStart = (wall.gapAngle - wall.currentGapSize / 2 + 360) % 360;
            const gapEnd = (wall.gapAngle + wall.currentGapSize / 2) % 360;
            let inGap = false;
            if (gapStart < gapEnd) {
                if (angle >= gapStart && angle <= gapEnd) inGap = true;
            } else {
                if (angle >= gapStart || angle <= gapEnd) inGap = true;
            }
            
            if (!inGap) {
                const startAngle = (i - 90) * Math.PI / 180;
                const endAngle = (i + 1 - 90) * Math.PI / 180;
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.stroke();
            }
        }
    }
    
    const circleRadius = 25;
    const arrowLength = 15;
    const arrowAngleWidth = Math.PI / 6;
    
    // Draw glowing hollow green circle
    ctx.save();
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#00ff00';
    ctx.strokeStyle = '#00ff00';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(centerX, centerY, circleRadius, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
    
    // Draw glowing white arrow head
    const angleRad = (gameState.player.angle - 90) * Math.PI / 180;
    const tipX = centerX + Math.cos(angleRad) * (circleRadius + arrowLength);
    const tipY = centerY + Math.sin(angleRad) * (circleRadius + arrowLength);
    
    ctx.save();
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ffffff';
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.moveTo(tipX, tipY);
    ctx.lineTo(
        tipX - Math.cos(angleRad - arrowAngleWidth) * arrowLength,
        tipY - Math.sin(angleRad - arrowAngleWidth) * arrowLength
    );
    ctx.lineTo(
        tipX - Math.cos(angleRad + arrowAngleWidth) * arrowLength,
        tipY - Math.sin(angleRad + arrowAngleWidth) * arrowLength
    );
    ctx.closePath();
    ctx.fill();
    ctx.restore();
    
    // Timer bar
    const barWidth = 300;
    const barHeight = 5;
    const barX = 600 - barWidth / 2;
    const barY = offsetY + gameHeight - 20;
    const t = gameState.remainingTime / gameState.timerDuration;
    const fillWidth = barWidth * t;
    
    ctx.fillStyle = '#222';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(barX, barY, fillWidth, barHeight);

}


// GAME 11 : AVOID SAFETY FEATURES
const carColors = { 
    purple: '#ff00ff', 
    orange: '#ff8800', 
    green: '#00ff00', 
    cyan: '#00ccff',
};
function initAvoidSafety() {
    const colors = ['purple','orange','green','cyan'];
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        player: { x: 580, y: 480, width: 50, height: 60, lane: 2, targetX: 580, rotation: 0 },
        playerColor: colors[Math.floor(Math.random() * colors.length)],
        cars: [],
        roadOffset: 0,
        spawnTimer: 0,
        score: 0,
        targetScore: 30,
        lanes: [440, 520, 600, 680, 760],
        laneWidth: 60,
        keys: { left: false, right: false }
    };
    
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}

function updateAvoidSafety() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Treadmill effect - move road
    gameState.roadOffset += 3;
    if (gameState.roadOffset > 35) gameState.roadOffset = 0;
    
    // Player lane switching (only when centered in lane)
    const isCentered = Math.abs(gameState.player.x - gameState.player.targetX) < 2;

    if (isCentered && gameState.keys.left && gameState.player.lane > 0) {
        gameState.player.lane--;
        gameState.player.targetX = gameState.lanes[gameState.player.lane];
        gameState.keys.left = false;
    }
    if (isCentered && gameState.keys.right && gameState.player.lane < 4) {
        gameState.player.lane++;
        gameState.player.targetX = gameState.lanes[gameState.player.lane];
        gameState.keys.right = false;
    }
    
    // Smooth lane transition with rotation
    const moveSpeed = 8;
    if (gameState.player.x < gameState.player.targetX) {
        gameState.player.x = Math.min(gameState.player.x + moveSpeed, gameState.player.targetX);
        gameState.player.rotation = Math.min(gameState.player.rotation + 0.15, 0.25); // Tilt right
    } else if (gameState.player.x > gameState.player.targetX) {
        gameState.player.x = Math.max(gameState.player.x - moveSpeed, gameState.player.targetX);
        gameState.player.rotation = Math.max(gameState.player.rotation - 0.15, -0.25); // Tilt left
    } else {
        // Return to center when not moving
        if (gameState.player.rotation > 0) {
            gameState.player.rotation = Math.max(0, gameState.player.rotation - 0.15);
        } else if (gameState.player.rotation < 0) {
            gameState.player.rotation = Math.min(0, gameState.player.rotation + 0.15);
        }
    }
    
    // Spawn cars with varied patterns (STRICT max 5 cars total)
    gameState.spawnTimer++;
    const spawnRate = Math.max(45, 80 - Math.floor(gameState.score / 5) * 5);

    // Count ALL cars in the array
    const totalCars = gameState.cars.length;

    if (gameState.spawnTimer > spawnRate && totalCars < 5) {
        gameState.spawnTimer = 0;
        
        const rand = Math.random();
        const carTypes = ['purple', 'orange', 'green', 'cyan'];
        const baseSpeed = 3.5 + Math.random() * 0.5;
        
        // Calculate how many cars we can spawn
        const carsWeCanSpawn = 5 - totalCars;

        // Pattern 1: Single car in random lane (40%)
        if (rand < 0.4 && carsWeCanSpawn >= 1) {
            const lane = Math.floor(Math.random() * 5);
            gameState.cars.push({
                x: gameState.lanes[lane],
                y: -100,
                      width: 50,
height: 60,
                speed: baseSpeed, 
                type: carTypes[Math.floor(Math.random() * carTypes.length)]
            });
        }
        // Pattern 2: Two cars side by side with gap (30%)
        else if (rand < 0.7 && carsWeCanSpawn >= 2) {
            const startLane = Math.floor(Math.random() * 3);
            const gapLane = startLane + Math.floor(Math.random() * 3) + 1;
            
            let spawned = 0;
            for (let i = startLane; i < startLane + 3 && spawned < carsWeCanSpawn; i++) {
                if (i !== gapLane) {
                    gameState.cars.push({
                        x: gameState.lanes[i],
                        y: -100,
                      width: 50,
height: 60,
                        speed: baseSpeed, 
                        type: carTypes[Math.floor(Math.random() * carTypes.length)]
                    });
                    spawned++;
                }
            }
        }
        // Pattern 3: Diagonal/staggered formation (20%)
        else if (rand < 0.9 && carsWeCanSpawn >= 2) {
            const numCars = Math.min(2 + Math.floor(Math.random() * 2), carsWeCanSpawn); // 2-3 cars, but respect limit
            const usedLanes = new Set();
            
            for (let i = 0; i < numCars; i++) {
                let lane;
                do {
                    lane = Math.floor(Math.random() * 5);
                } while (usedLanes.has(lane));
                usedLanes.add(lane);
                
                gameState.cars.push({
                    x: gameState.lanes[lane],
                    y: -100 - i * 80, // Staggered vertically
                      width: 50,
height: 60,
                    speed: baseSpeed, 
                    type: carTypes[Math.floor(Math.random() * carTypes.length)]
                });
            }
        }
        // Pattern 4: Block with one escape route (10%)
        else if (carsWeCanSpawn >= 4) {
            const escapeLane = Math.floor(Math.random() * 5);
            for (let i = 0; i < 5 && gameState.cars.length < 5; i++) {
                if (i !== escapeLane) {
                    gameState.cars.push({
                        x: gameState.lanes[i],
                        y: -100,
                      width: 50,
height: 60,
                        speed: baseSpeed, 
                        type: carTypes[Math.floor(Math.random() * carTypes.length)]
                    });
                }
            }
        }
    }
    
    // Update cars (move down with their own speed)
    for (let i = gameState.cars.length - 1; i >= 0; i--) {
        const car = gameState.cars[i];
        
        // Check if there's another car ahead in the same lane
        let carAhead = null;
        let minDistance = Infinity;
        
        for (let j = 0; j < gameState.cars.length; j++) {
            if (i !== j && Math.abs(gameState.cars[j].x - car.x) < 20) {
                const distance = gameState.cars[j].y - car.y;
                if (distance > 0 && distance < minDistance) {
                    minDistance = distance;
                    carAhead = gameState.cars[j];
                }
            }
        }
        
        // Adjust speed to avoid collision with car ahead
        if (carAhead && minDistance < 100) {
            // Match speed with car ahead or go slightly slower
            car.speed = Math.min(car.speed, carAhead.speed * 0.95);
        } else {
            // Random deceleration only if no car ahead (30% chance to slow down slightly)
            if (Math.random() < 0.3) {
                car.speed = Math.max(2.0, car.speed - 0.02);
            }
        }
        
        car.y += car.speed;
        
        // Check collision
        if (Math.abs(gameState.cars[i].x - gameState.player.x) < 40 &&
            Math.abs(gameState.cars[i].y - gameState.player.y) < 60) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK FAILED!', `Cars Avoided: ${gameState.score}/30`);
            }, 100);
            return;
        }
        
        // Remove if off screen and count
        if (gameState.cars[i].y > 600) {
            gameState.cars.splice(i, 1);
            gameState.score++;
            
            if (gameState.score >= 30) {
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK COMPLETED', 'All cars avoided!');
                }, 100);
                return;
            }
        }
    }
    
    updateUI();
}

function drawAvoidSafety() {
const colors = { 
    purple: '#ff00ff', 
    orange: '#ff8800', 
    green: '#00ff00', 
    cyan: '#00ccff',
};

    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('AVOID SAFETY FEATURES', currentScene === 'countdown');
        return;
    }
    
    const gameWidth = 400;
    const gameHeight = 558;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 40;
    
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Road background
    ctx.fillStyle = '#000000';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('AVOID SAFETY FEATURES', 600, 25);
    
    // Draw road lanes with treadmill animation
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.setLineDash([20, 15]);
    
for (let i = 1; i < 5; i++) { 
    const x = offsetX + (gameWidth / 5) * i;

    ctx.save();
    ctx.translate(0, gameState.roadOffset);
    ctx.beginPath();
    ctx.moveTo(x, offsetY);
    ctx.lineTo(x, offsetY + gameHeight);
    ctx.stroke();
    ctx.restore();
}

    ctx.setLineDash([]);
    
// Draw cars
for (let car of gameState.cars) {
    // Draw light beam FIRST (behind car) - single beam from FRONT bumper
    ctx.globalAlpha = 0.1;  // More transparent
    ctx.fillStyle = '#ffff66';
    
    // Single centered light beam from FRONT bumper - SPREADS OUT (smaller)
    ctx.beginPath();
    ctx.moveTo(car.x - 10, car.y - car.height / 2); // top left - NARROW
    ctx.lineTo(car.x + 10, car.y - car.height / 2); // top right - NARROW
    ctx.lineTo(car.x + 18, car.y - car.height / 2 - 30); // ahead - WIDE (smaller)
    ctx.lineTo(car.x - 18, car.y - car.height / 2 - 30); // ahead - WIDE (smaller)
    ctx.closePath();
    ctx.fill();
    
    ctx.globalAlpha = 1.0;
    
    // Draw car body
    const carSprite = carSprites[car.type];
    if (carSprite && carSprite.complete) {
        ctx.drawImage(carSprite, car.x - car.width / 2, car.y - car.height / 2, car.width, car.height);
    } else {
        ctx.fillStyle = colors[car.type];
        ctx.fillRect(car.x - car.width / 2, car.y - car.height / 2, car.width, car.height);
        ctx.strokeStyle = '#ffffff';
        ctx.strokeRect(car.x - car.width / 2, car.y - car.height / 2, car.width, car.height);
    }
}

// Draw player car with rotation
const playerCarSprite = carSprites[gameState.playerColor];
ctx.save();
ctx.translate(gameState.player.x, gameState.player.y);
ctx.rotate(gameState.player.rotation);

if (playerCarSprite && playerCarSprite.complete) {
    ctx.drawImage(playerCarSprite, -gameState.player.width / 2, 
                 -gameState.player.height / 2, 
                 gameState.player.width, gameState.player.height);
} else {
    ctx.fillStyle = colors[gameState.playerColor];
    ctx.fillRect(-gameState.player.width / 2, 
                 -gameState.player.height / 2, 
                 gameState.player.width, gameState.player.height);
    ctx.strokeStyle = '#ffffff';
    ctx.strokeRect(-gameState.player.width / 2, 
                   -gameState.player.height / 2, 
                   gameState.player.width, gameState.player.height);
}

ctx.restore();

// Draw player light beam from FRONT bumper - SPREADS OUT
ctx.globalAlpha = 0.1;  // More transparent
ctx.fillStyle = '#ffff66';

// Single centered light beam from FRONT bumper - SPREADS OUT (smaller)
ctx.beginPath();
ctx.moveTo(gameState.player.x - 10, gameState.player.y - gameState.player.height / 2); // top left - NARROW
ctx.lineTo(gameState.player.x + 10, gameState.player.y - gameState.player.height / 2); // top right - NARROW
ctx.lineTo(gameState.player.x + 18, gameState.player.y - gameState.player.height / 2 - 30); // ahead - WIDE (smaller)
ctx.lineTo(gameState.player.x - 18, gameState.player.y - gameState.player.height / 2 - 30); // ahead - WIDE (smaller)
ctx.closePath();
ctx.fill();

ctx.globalAlpha = 1.0;
}

// ============= GAME 12: COLOR DRILLING =============
function initGatherBlocks() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    gameState = {
        drill: { 
            x: 200, 
            laneIndex: 1, // 0, 1, 2, 3 for 4 lanes
            colorIndex: 0,
            colors: ['#0000ff', '#ffff00', '#00ff00', '#ff0000'], // blue, yellow, green, red
            colorNames: ['BLUE', 'YELLOW', 'GREEN', 'RED']
        },
        blockRow: null,
        score: 0,
        targetScore: 20,
        blockSpeed: 5,
        keys: { left: false, right: false },
        collisionEffect: null 
    };
    
    spawnBlockRow();
    
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}

function spawnBlockRow() {
    // Create a row of 4 colored blocks (shuffled)
    const colors = [0, 1, 2, 3]; // indices
    // Shuffle
    for (let i = colors.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [colors[i], colors[j]] = [colors[j], colors[i]];
    }
    
    gameState.blockRow = {
        y: -100,
        blocks: colors.map((colorIndex, index) => ({
            colorIndex: colorIndex,
            color: gameState.drill.colors[colorIndex],
            x: index // lane position 0, 1, 2, 3
        }))
    };
    
    // Set random drill color for next round
    gameState.drill.colorIndex = Math.floor(Math.random() * 4);
}

function updateGatherBlocks() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
  if (currentScene !== 'playing') return;
    
    // Move drill left/right with half-steps (8 positions instead of 4)
    if (gameState.keys.left && gameState.drill.laneIndex > 0) {
        gameState.drill.laneIndex -= 0.5; // CHANGED: Move by 0.5 instead of 1
        gameState.keys.left = false;
    }
    if (gameState.keys.right && gameState.drill.laneIndex < 3.5) { // CHANGED: Max is now 3.5
        gameState.drill.laneIndex += 0.5; // CHANGED: Move by 0.5 instead of 1
        gameState.keys.right = false;
    }
    
    // UPDATE COLLISION EFFECT ANIMATION
    if (gameState.collisionEffect) {
        gameState.collisionEffect.radius += 3;
        gameState.collisionEffect.alpha -= 0.05;
        
        if (gameState.collisionEffect.alpha <= 0) {
            gameState.collisionEffect = null;
        }
    }
    
    // Move blocks down
    if (gameState.blockRow) {
        gameState.blockRow.y += gameState.blockSpeed;
        
        // UPDATED COLLISION DETECTION - at triangle tip
        const gameWidth = 400;
        const gameHeight = 558;
        const offsetX = (1200 - gameWidth) / 2;
        const offsetY = 40;
        const laneWidth = gameWidth / 4; // Full width divided by 4
        const lanesStartX = offsetX;
        
        const drillLaneX = lanesStartX + gameState.drill.laneIndex * laneWidth + laneWidth / 2;
        const drillTipY = offsetY + gameHeight - 50 - 20; // Triangle tip Y position
        
        const blockHeight = 20;
        const blockY = offsetY + gameState.blockRow.y;
        
        // Check if drill tip hits any block
        if (drillTipY >= blockY && drillTipY <= blockY + blockHeight) {
            const blockInLane = gameState.blockRow.blocks.find(b => b.x === gameState.drill.laneIndex);
            
            if (blockInLane) {
                const blockCenterX = lanesStartX + blockInLane.x * laneWidth + laneWidth / 2;
                
                // CREATE COLLISION EFFECT
                gameState.collisionEffect = {
                    x: blockCenterX,
                    y: blockY + blockHeight / 2,
                    radius: 0,
                    maxRadius: 50,
                    alpha: 1,
                    color: blockInLane.color
                };
                
                if (blockInLane.colorIndex === gameState.drill.colorIndex) {
                    // Correct color - success!
                    gameState.score++;
                    
                    if (gameState.score >= gameState.targetScore) {
                        gameState.gameOver = true;
                        setTimeout(() => {
                            endGame('HACK COMPLETED', 'Drilled through all blocks!');
                        }, 100);
                        return;
                    }
                    
                    // Spawn new row
                    spawnBlockRow();
                } else {
                    // Wrong color - game over
                    gameState.gameOver = true;
                    setTimeout(() => {
                        endGame('HACK FAILED!', `Wrong color! Score: ${gameState.score}/20`);
                    }, 100);
                    return;
                }
            }
        }
    }
    
    updateUI();
}

function drawGatherBlocks() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('COLOR DRILLING', currentScene === 'countdown');
        return;
    }
    
    const gameWidth = 400;
    const gameHeight = 558;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 40;
    
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Game area background 
    ctx.fillStyle = '#101d27'; 
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
    
    // Draw tablet at top
    const tabletWidth = 300;
    const tabletHeight = 120;
    const tabletX = offsetX + (gameWidth - tabletWidth) / 2;
    const tabletY = offsetY + 20;
      
    
    // "Match the colors" text
    ctx.fillStyle = '#ffff00';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Match the colors', tabletX + tabletWidth / 2, tabletY + 30);

    // UPDATED: Draw 4 lanes covering full width
    const laneWidth = gameWidth / 4; // Full width divided by 4
    const lanesStartX = offsetX; // Start from the edge
    
    // Draw falling blocks
    if (gameState.blockRow) {
        const blockWidth = laneWidth - 4; // Small gap between blocks
        const blockHeight = 20;
        
        for (let block of gameState.blockRow.blocks) {
            const blockX = lanesStartX + block.x * laneWidth + 2;
            const blockY = offsetY + gameState.blockRow.y;
            
            ctx.fillStyle = block.color;
            ctx.fillRect(blockX, blockY, blockWidth, blockHeight);
            
            ctx.strokeStyle = block.color;
            ctx.lineWidth = 3;
            ctx.strokeRect(blockX, blockY, blockWidth, blockHeight);
        }
    }
    
    // DRAW COLLISION EFFECT
    if (gameState.collisionEffect) {
        const effect = gameState.collisionEffect;
        ctx.save();
        ctx.globalAlpha = effect.alpha;
        ctx.strokeStyle = effect.color;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.radius, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner circle
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(effect.x, effect.y, effect.radius * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
    }
    
    // Draw drill at bottom (bullet shape with diagonal lines)
    const drillLaneX = lanesStartX + gameState.drill.laneIndex * laneWidth + laneWidth / 2;
    const drillY = offsetY + gameHeight;
    const drillWidth = 30;
    const drillHeight = 50;

    // 3 Diagonal lines inside the drill body (20¬∞ angle, top-right to bottom-left)
    ctx.strokeStyle = gameState.drill.colors[gameState.drill.colorIndex];
    ctx.lineWidth = 2;

    const angle = 20 * Math.PI / 180; // Convert 20¬∞ to radians
    const lineSpacing = drillHeight / 4; // Divide height into 4 sections for 3 lines
    const upwardOffset = 5; // Move lines up by 5 pixels

    for (let i = 1; i <= 3; i++) {
        const centerY = drillY - drillHeight + i * lineSpacing - upwardOffset;
        const halfLength = drillWidth / 2;
        const verticalOffset = halfLength * Math.tan(angle);
        
        ctx.beginPath();
        ctx.moveTo(drillLaneX + halfLength, centerY - verticalOffset);
        ctx.lineTo(drillLaneX - halfLength, centerY + verticalOffset);
        ctx.stroke();
    }

    // Outer border with color
    ctx.strokeStyle = gameState.drill.colors[gameState.drill.colorIndex];
    ctx.lineWidth = 3;

    // Left side of rectangle
    ctx.beginPath();
    ctx.moveTo(drillLaneX - drillWidth/2, drillY);
    ctx.lineTo(drillLaneX - drillWidth/2, drillY - drillHeight);
    ctx.stroke();

    // Right side of rectangle
    ctx.beginPath();
    ctx.moveTo(drillLaneX + drillWidth/2, drillY);
    ctx.lineTo(drillLaneX + drillWidth/2, drillY - drillHeight);
    ctx.stroke();

    // Bottom of rectangle only
    ctx.beginPath();
    ctx.moveTo(drillLaneX - drillWidth/2, drillY);
    ctx.lineTo(drillLaneX + drillWidth/2, drillY);
    ctx.stroke();

    // Triangle outline (not filled)
    ctx.beginPath();
    ctx.moveTo(drillLaneX - drillWidth/2, drillY - drillHeight);
    ctx.lineTo(drillLaneX, drillY - drillHeight - 20);
    ctx.lineTo(drillLaneX + drillWidth/2, drillY - drillHeight);
    ctx.stroke();
}

// ============= OSU-STYLE RHYTHM GAMES =============

const osuModes = {
    'osu-cars-cb': {
        name: 'CARS (C-B CLASS)',
        circleInterval: 900,
        shrinkTime: 1300,
        hitTolerance: 10,
        targetCircles: 10,
        speedProgression: 'consistent',
        description: 'Slow & steady - Relaxed pace'
    },
    'osu-cars-a': {
        name: 'CARS (A CLASS)',
        circleInterval: 600,
        shrinkTime: 1000,
        hitTolerance: 10,
        targetCircles: 10,
        speedProgression: 'consistent',
        description: 'Medium pace - Steady flow'
    },
    'osu-cars-s': {
        name: 'CARS (S CLASS)',
        circleInterval: 400,
        shrinkTime: 850,
        hitTolerance: 10,
        targetCircles: 15,
        speedProgression: 'consistent',
        description: 'Fast pace - Quick succession'
    },
    'osu-helicopter': {
        name: 'HELICOPTER',
        circleInterval: 200,      // FASTER - Same as old House
        shrinkTime: 650,
        hitTolerance: 10,
        targetCircles: 15,
        speedProgression: 'consistent',
        description: 'Extreme speed - Rapid fire'
    },
    'osu-house': {
        name: 'HOUSE',
        circleInterval: 250,      // SLOWER - Same as old Helicopter
        shrinkTime: 700,
        hitTolerance: 10,
        targetCircles: 30,
        speedProgression: 'consistent',
        description: 'Long endurance - Very fast stream'
    }
};

function initOsu(gameMode) {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    const mode = osuModes[gameMode];
    const targetCircles = getDefaultTargetCircles(gameMode);    

  gameState = {
    mode: gameMode,
    modeConfig: mode,
    circles: [],
    currentIndex: 0,
    score: 0,
    targetScore: targetCircles * 300,
    totalCircles: targetCircles,
    circlesHit: 0,  
    failed: false,
        failTime: null,
        lastSpawnTime: null,
        nextNumber: 1,
        failedCircle: null,
        settingsButtons: [],
        
        // Dynamic interval for gradual modes
        currentCircleInterval: mode.circleInterval,
        baseCircleInterval: mode.circleInterval,
        
        // Use mode-specific settings
        shrinkTime: mode.shrinkTime,
        hitTolerance: mode.hitTolerance,
        speedProgression: mode.speedProgression,
        speedupFactor: mode.speedupFactor || 1,
        minInterval: mode.minInterval || mode.circleInterval,
        
        // Game constants
        circleRadius: 45,
        approachRadius: 80,
        minCircleDistance: 140,
        
        // Game area
        boxWidth: 600,
        boxHeight: 400,
        boxX: (1200 - 600) / 2,
        boxY: (600 - 400) / 2 + 50,
        
        // Visual effects
        effects: []
    };
    
    if (settings.skipIntros) {
        currentScene = 'playing';
        gameState.startTime = Date.now();
        gameState.lastSpawnTime = Date.now();
    }
    
    updateUI();
}

function getDefaultTargetCircles(gameMode) {
    const defaults = {
        'osu-cars-cb': 10,
        'osu-cars-a': 15,
        'osu-cars-s': 15,
        'osu-helicopter': 15,
        'osu-house': 30
    };
    return defaults[gameMode] || 10;
}

function updateOsu() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
            gameState.lastSpawnTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
 // FREEZE on failure - don't update anything
    if (gameState.failed) {
        updateUI();
        return;
    }
    
    const currentTime = Date.now();
    
    // Count how many circles are currently active (not hit yet)
    const activeCircles = gameState.circles.filter(c => !c.hit && !c.fadeStart).length;
    
    // Spawn ONE circle at a time with mode-specific intervals
    if (gameState.circlesHit < gameState.totalCircles && 
        activeCircles < gameState.totalCircles &&
        gameState.lastSpawnTime && 
        currentTime - gameState.lastSpawnTime >= gameState.currentCircleInterval) {
        
        // Don't spawn more than we need total
        const circlesLeftToSpawn = gameState.totalCircles - (gameState.circlesHit + activeCircles);
        
        if (circlesLeftToSpawn > 0) {
            // Spawn ONE circle
            spawnSingleOsuCircle(currentTime);
            gameState.lastSpawnTime = currentTime;
        }
        
        // Update interval for gradual modes
        if (gameState.speedProgression === 'gradual') {
            const newInterval = gameState.currentCircleInterval * gameState.speedupFactor;
            gameState.currentCircleInterval = Math.max(gameState.minInterval, newInterval);
        }
    }
    
    // Check for failures
    checkOsuFailures(currentTime);
    
    // Update effects
    updateOsuEffects(currentTime);
    
    // Win condition - check if we hit all required circles
    if (gameState.circlesHit >= gameState.totalCircles) {
        gameState.gameOver = true;
        gameState.circles = [];
        setTimeout(() => {
            endGame('HACK COMPLETED', `Final Score: ${gameState.score}`);
        }, 100);
        return;
    }
    
    updateUI();
}

function spawnSingleOsuCircle(currentTime) {
    let attempts = 0;
    const maxAttempts = 20;
    let placed = false;
    
    // Get previous circle for organic placement
    const prevCircle = gameState.circles.length > 0 
        ? gameState.circles[gameState.circles.length - 1] 
        : null;
    
    while (attempts < maxAttempts && !placed) {
        const margin = gameState.approachRadius + 20;
        let x, y;
        
        if (prevCircle && Math.random() < 0.75) {
            // 75% chance to place near previous circle for flow
            const angle = Math.random() * Math.PI * 2;
            const distance = gameState.minCircleDistance * (0.9 + Math.random() * 0.3);
            x = prevCircle.x + Math.cos(angle) * distance;
            y = prevCircle.y + Math.sin(angle) * distance;
            
            // Clamp to bounds
            x = Math.max(gameState.boxX + margin, Math.min(x, gameState.boxX + gameState.boxWidth - margin));
            y = Math.max(gameState.boxY + margin, Math.min(y, gameState.boxY + gameState.boxHeight - margin));
        } else {
            // Random placement
            x = gameState.boxX + margin + Math.random() * (gameState.boxWidth - 2 * margin);
            y = gameState.boxY + margin + Math.random() * (gameState.boxHeight - 2 * margin);
        }
        
        // Check if too close to any existing circle
        let tooClose = false;
        for (let existingCircle of gameState.circles) {
            if (existingCircle.hit || existingCircle.fadeStart) continue; // Skip fading circles
            
            const dist = Math.sqrt((x - existingCircle.x) ** 2 + (y - existingCircle.y) ** 2);
            if (dist < gameState.minCircleDistance * 0.85) {
                tooClose = true;
                break;
            }
        }
        
        if (!tooClose) {
            const circle = {
                x: x,
                y: y,
                spawnTime: currentTime,
                number: gameState.nextNumber,
                shrinkTime: gameState.shrinkTime,
                hit: false,
                failedHit: false,
                fadeStart: null
            };
            
            gameState.circles.push(circle);
            gameState.nextNumber++;
            placed = true;
        }
        attempts++;
    }
}

function drawOsu() {
    if (currentScene === 'intro') {
        drawOsuIntro();
        return;
    }
    
    if (currentScene === 'countdown') {
        drawBoostingIntro(gameState.modeConfig.name, true);
        return;
    }
    
    const gameWidth = 600;
    const gameHeight = 500;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 50;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Game area background
    ctx.fillStyle = 'rgba(26, 32, 26, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(gameState.modeConfig.name, 600, 35);
    
    // Score display
    ctx.fillStyle = '#00ff00';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`SCORE: ${gameState.score}/${gameState.targetScore}`, offsetX + 20, offsetY + 30);
    
    const currentTime = Date.now();
    
    // Draw shooting lines
    drawOsuShootingLines(currentTime, offsetX, offsetY);
    
    // Draw circles
    for (let circle of gameState.circles) {
        drawOsuCircle(circle, currentTime, offsetX, offsetY);
    }
  // Back button
ctx.fillStyle = '#8ce023';
ctx.fillRect(offsetX + gameWidth - 120, offsetY + 15, 100, 30);
ctx.fillStyle = '#0a0e1a';
ctx.font = '10px "Press Start 2P", monospace';
ctx.textAlign = 'center';
ctx.fillText('BACK', offsetX + gameWidth - 70, offsetY + 32);

// Store button for click detection
if (!gameState.backButton) {
    gameState.backButton = {
        x: offsetX + gameWidth - 120,
        y: offsetY + 15,
        width: 100,
        height: 30
    };
}
    // Game over screen
    if (gameState.failed && gameState.failTime) {
        const elapsed = currentTime - gameState.failTime;
        if (elapsed >= 2000) {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, 1200, 600);
            
            ctx.fillStyle = '#ff0000';
            ctx.font = '32px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText('HACK FAILED', 600, 250);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = '16px "Press Start 2P", monospace';
            ctx.fillText(`Final Score: ${gameState.score}`, 600, 300);
            ctx.fillText('CLICK TO RESTART', 600, 350);
        }
    }
}

// ============= OSU AUTO-PILOT BOT =============
let autoPilotEnabled = false;
let autoPilotInterval = null;

function toggleAutoPilot() {
    autoPilotEnabled = !autoPilotEnabled;
    
    if (autoPilotEnabled) {
        startAutoPilot();
        console.log('Auto-pilot: ENABLED');
    } else {
        stopAutoPilot();
        console.log('Auto-pilot: DISABLED');
    }
}

function startAutoPilot() {
    if (autoPilotInterval) {
        clearInterval(autoPilotInterval);
    }
    
    autoPilotInterval = setInterval(() => {
        if (!autoPilotEnabled || !currentGame || !currentGame.startsWith('osu-') || currentScene !== 'playing' || gameState.failed) {
            return;
        }
        
        const currentTime = Date.now();
        let hitCircle = null;
        let earliestCircle = null;
        let earliestTime = Infinity;
        
        // Find the circle that's closest to being perfectly timed
        for (let circle of gameState.circles) {
            if (circle.hit || circle.fadeStart) continue;
            
            const timeUntilPerfect = circle.spawnTime + circle.shrinkTime - currentTime;
            
            // Track the earliest circle for emergency hitting
            if (timeUntilPerfect < earliestTime) {
                earliestTime = timeUntilPerfect;
                earliestCircle = circle;
            }
            
            // Perfect timing: hit when circle is about to reach target size
            if (timeUntilPerfect >= -50 && timeUntilPerfect <= 100) {
                hitCircle = circle;
                break;
            }
        }
        
        // If no perfect timing found, hit the earliest circle to avoid failure
        if (!hitCircle && earliestCircle && earliestTime < 200) {
            hitCircle = earliestCircle;
        }
        
        if (hitCircle) {
            // Simulate a click at the circle's position
            handleOsuClick(hitCircle.x, hitCircle.y);
        }
    }, 50); // Check every 50ms
}


function stopAutoPilot() {
    if (autoPilotInterval) {
        clearInterval(autoPilotInterval);
        autoPilotInterval = null;
    }
}

// Add auto-pilot toggle to the OSU intro screen
function drawOsuIntro() {
    const mode = gameState.modeConfig;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '24px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(mode.name, 600, 80);
    
    // Settings panel background
    const panelWidth = 500;
    const panelHeight = 350;
    const panelX = (1200 - panelWidth) / 2;
    const panelY = 150;
    
    ctx.fillStyle = 'rgba(20, 30, 48, 0.95)';
    ctx.strokeStyle = '#8ce023';
    ctx.lineWidth = 3;
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
    
    // Settings title
    ctx.fillStyle = '#8ce023';
    ctx.font = '18px "Press Start 2P", monospace';
    ctx.fillText('DIFFICULTY SETTINGS', 600, panelY + 40);
    
    // Current settings display
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    
    const settingsY = panelY + 80;
    const lineHeight = 35;
    
    // FIX: Initialize settingsButtons array at the start
    if (!gameState.settingsButtons) {
        gameState.settingsButtons = [];
    } else {
        // Clear existing buttons to avoid duplicates
        gameState.settingsButtons = [];
    }
    
  // Target circles (display only, no buttons)
ctx.fillText(`TARGET CIRCLES: ${gameState.totalCircles}`, panelX + 30, settingsY);
       
    // Difficulty description
    ctx.textAlign = 'center';
    ctx.fillStyle = '#8ce023';
    ctx.font = '14px "Press Start 2P", monospace';
    
    let difficultyText = '';
    const targetCircles = gameState.targetScore / 300;
    
    if (gameState.mode === 'osu-cars-cb') {
        difficultyText = `Slow lockpicking ‚Ä¢ ${targetCircles} circles`;
    } else if (gameState.mode === 'osu-cars-a') {
        difficultyText = `Medium lockpicking ‚Ä¢ ${targetCircles} circles`;
    } else if (gameState.mode === 'osu-cars-s') {
        difficultyText = `Fast lockpicking ‚Ä¢ ${targetCircles} circles`;
    } else if (gameState.mode === 'osu-helicopter') {
        difficultyText = `Very fast ‚Ä¢ ${targetCircles} circles`;
    } else if (gameState.mode === 'osu-house') {
        difficultyText = `Slow spawn ‚Ä¢ ${targetCircles} circles`;
    }
    
    ctx.fillText(difficultyText, 600, settingsY + lineHeight * 2);
    
    // Start button
    drawOsuStartButton(600, panelY + panelHeight - 50);
}

function drawOsuSettingButton(x, y, text, action) {
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(x, y, 40, 25);
    ctx.fillStyle = '#0a0e1a';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, x + 20, y + 12);
    
    // Store button info for click detection
    if (!gameState.settingsButtons) {
        gameState.settingsButtons = [];
    }
    gameState.settingsButtons.push({ x, y, width: 40, height: 25, action });
}

function drawOsuStartButton(x, y) {
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(x - 100, y - 20, 200, 40);
    ctx.fillStyle = '#0a0e1a';
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('START HACKING', x, y);
    
    // Store start button info
    if (!gameState.settingsButtons) {
        gameState.settingsButtons = [];
    }
    gameState.settingsButtons.push({ 
        x: x - 100, 
        y: y - 20, 
        width: 200, 
        height: 40, 
        action: 'start' 
    });
}



// Update the failure checking to handle multiple active circles
function checkOsuFailures(currentTime) {
    if (gameState.failed) return;
    
    // Check ALL active circles, not just the current index
    for (let i = 0; i < gameState.circles.length; i++) {
        const circle = gameState.circles[i];
        if (!circle.hit && !circle.fadeStart && 
            currentTime - circle.spawnTime >= circle.shrinkTime) {
            circle.failedHit = true;
            gameState.failed = true;
            gameState.failTime = currentTime;
            gameState.failedCircle = circle;
            break;
        }
    }
}


function updateOsuEffects(currentTime) {
    for (let i = gameState.effects.length - 1; i >= 0; i--) {
        const effect = gameState.effects[i];
        effect.radius += 2;
        effect.alpha -= 5;
        
        if (effect.alpha <= 0) {
            gameState.effects.splice(i, 1);
        }
    }
}

function drawOsuShootingLines(currentTime, offsetX, offsetY) {
    // Draw lines between consecutive circles
    for (let i = 0; i < gameState.circles.length - 1; i++) {
        const c1 = gameState.circles[i];
        const c2 = gameState.circles[i + 1];
        
        // Skip if either circle is hit or failed
        if (c1.hit || c2.hit || c1.fadeStart || c2.fadeStart) continue;
        
        // Skip circles that failed
        if (gameState.failed && gameState.failedCircle && 
            (c1.number > gameState.failedCircle.number || c2.number > gameState.failedCircle.number)) {
            continue;
        }
        
        // Only draw line if second circle has spawned
        if (currentTime < c2.spawnTime) continue;
        
        // Simple solid line with constant transparency
        ctx.strokeStyle = 'rgba(140, 224, 35, 0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(c1.x, c1.y);
        ctx.lineTo(c2.x, c2.y);
        ctx.stroke();
    }
}

function drawOsuCircle(circle, currentTime, offsetX, offsetY) {
    const elapsed = currentTime - circle.spawnTime;
    if (elapsed < 0) return;
    
    if (gameState.failed && gameState.failedCircle && circle.number > gameState.failedCircle.number) {
        return;
    }
    
    const alpha = circle.fadeStart ? 
        Math.max(0, 255 - Math.floor((currentTime - circle.fadeStart) / 500 * 255)) : 255;
    
    if (alpha <= 0) return;
    
    // Determine if this circle is the failed one
    const isFailed = circle.failedHit || (gameState.failed && gameState.failedCircle === circle);
    
    const circleRadius = gameState.circleRadius;
    
    // Approach circle - RED if failed, LIME GREEN otherwise
    const approachRadius = getOsuApproachRadius(circle, currentTime);
    if (approachRadius > circleRadius && !circle.hit) {
        ctx.strokeStyle = isFailed ? 'rgba(220, 50, 50, 0.8)' : 'rgba(140, 224, 35, 0.2)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, approachRadius, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Circle fill - ALWAYS BLACK TRANSPARENT
    ctx.fillStyle = `rgba(0, 0, 0, ${Math.min(0.2, alpha/255)})`;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circleRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Circle border - ALWAYS LIME GREEN
    ctx.strokeStyle = 'rgba(140, 224, 35, 0.6)';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(circle.x, circle.y, circleRadius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Inner glow effect - smaller circle inside
    if (isFailed) {
        // RED inner glow for failed circle
        ctx.fillStyle = 'rgba(220, 50, 50, 0.3)';
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, circleRadius - 3, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // LIME GREEN inner glow for normal circles
        ctx.fillStyle = 'rgba(140, 224, 35, 0.15)';
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, circleRadius - 3, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Number - WHITE TEXT with bold font
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(circle.number.toString(), circle.x, circle.y);
}

function getOsuApproachRadius(circle, currentTime) {
    // FREEZE on failure
    if (gameState.failed) {
        const elapsed = gameState.failTime - circle.spawnTime;
        const progress = Math.min(elapsed / circle.shrinkTime, 1);
        return gameState.approachRadius - (gameState.approachRadius - gameState.circleRadius) * progress;
    }
    
    const elapsed = currentTime - circle.spawnTime;
    if (elapsed >= circle.shrinkTime) {
        if (!circle.hit) {
            circle.failedHit = true;
        }
        return gameState.circleRadius;
    }
    const progress = elapsed / circle.shrinkTime;
    return gameState.approachRadius - (gameState.approachRadius - gameState.circleRadius) * progress;
}

function handleOsuClick(x, y) {
    if (!gameState || !gameState.circles) {
        return;
    }
    
   // Check for back button click
if (gameState.backButton && 
    x >= gameState.backButton.x && 
    x <= gameState.backButton.x + gameState.backButton.width &&
    y >= gameState.backButton.y && 
    y <= gameState.backButton.y + gameState.backButton.height) {
    
    // Reset and go back to OSU mode selection
    console.log('Back button clicked - returning to mode selection');
    
    // Show the OSU mode selection screen
    showOsuModeSelection();
    return;
}
    
    // Don't process game clicks if failed
    if (gameState.failed) {
        return;
    }
    
    const currentTime = Date.now();
    let hitCircle = null;
    let clickedWrongCircle = false;
    
    // Find the NEXT circle that should be hit (lowest number that's not hit yet)
    let nextCircle = null;
    for (let i = 0; i < gameState.circles.length; i++) {
        const circle = gameState.circles[i];
        if (!circle.hit && !circle.fadeStart) {
            if (!nextCircle || circle.number < nextCircle.number) {
                nextCircle = circle;
            }
        }
    }
    
    // Check ALL circles for hits
    for (let i = 0; i < gameState.circles.length; i++) {
        const circle = gameState.circles[i];
        if (circle.hit || circle.fadeStart) continue;
        
        const dist = Math.sqrt((x - circle.x) ** 2 + (y - circle.y) ** 2);
        const maxDistance = gameState.circleRadius + gameState.hitTolerance;
        
        if (dist <= maxDistance) {
            hitCircle = circle;
            
            // Check if this is the correct circle to hit (the next one in sequence)
            if (nextCircle && circle.number !== nextCircle.number) {
                clickedWrongCircle = true;
            }
            break;
        }
    }
    
    if (hitCircle) {
        if (clickedWrongCircle) {
            // Clicked a circle out of order - FAIL
            nextCircle.failedHit = true;
            gameState.failed = true;
            gameState.failTime = currentTime;
            gameState.failedCircle = nextCircle;
        } else {
            // Check timing - is the approach circle close enough?
            const approachRadius = getOsuApproachRadius(hitCircle, currentTime);
            const timingError = Math.abs(approachRadius - gameState.circleRadius);
            
            // If approach circle is too far from target, it's a timing failure
            if (timingError > gameState.hitTolerance) {
                hitCircle.failedHit = true;
                gameState.failed = true;
                gameState.failTime = currentTime;
                gameState.failedCircle = hitCircle;
            } else {
                // SUCCESS!
                hitCircle.hit = true;
                hitCircle.fadeStart = currentTime;
                gameState.score += 300;
                gameState.circlesHit++;
            }
        }
    } else {
        // MISS - clicked outside any circle, fail the game
        if (nextCircle) {
            nextCircle.failedHit = true;
            gameState.failedCircle = nextCircle;
        }
        gameState.failed = true;
        gameState.failTime = currentTime;
    }
}

// Update the settings click handler
function handleOsuSettingsClick(x, y) {
    if (!gameState.settingsButtons) return;
    
    for (let button of gameState.settingsButtons) {
        if (x >= button.x && x <= button.x + button.width &&
            y >= button.y && y <= button.y + button.height) {
            
            if (button.action === 'start') {
                // Start game without saving settings
                currentScene = 'countdown';
                countdownStart = Date.now();
                gameState.settingsButtons = []; // Clear buttons
            }
            
            break;
        }
    }
}

// ============= CUFF HACK MINIGAME =============

const cuffDifficulties = {
    'easy': {
        name: 'EASY',
        boxCount: 3,
        fillSpeed: 8.0,  
        boxWidth: 35,
        boxHeight: 35,  
        tolerance: 30,
        description: '3 boxes ‚Ä¢ Slow speed'
    },
    'medium': {
        name: 'MEDIUM',
        boxCount: 4,
        fillSpeed: 10.0, 
        boxWidth: 30,
        boxHeight: 30, 
        tolerance: 30,
        description: '4 boxes ‚Ä¢ Medium speed'
    },
    'hard': {
        name: 'HARD',
        boxCount: 5,
        fillSpeed: 12.0,  
        boxWidth: 25,
        boxHeight: 25,  
        tolerance: 30,
        description: '5 boxes ‚Ä¢ Fast speed'
    }
};


//Initialize game with difficulty (no intro)
function initCuffHackIntro() {
    // Start directly with easy difficulty
    initCuffHack('easy');
}

//Initialize actual game with difficulty
function initCuffHack(difficulty = 'easy') {
    // CLEAR any pending auto-restart timeout
    if (gameState && gameState.autoRestartTimeout) {
        clearTimeout(gameState.autoRestartTimeout);
    }
    
    currentScene = 'playing'; // START IMMEDIATELY, no intro
    const config = cuffDifficulties[difficulty];
    
    gameState = {
        difficulty: difficulty,
        config: config,
        
        // Progress bar
        barWidth: 600,
        barHeight: 30,
        barX: (1200 - 600) / 2,  // Center horizontally
        barY: (600 - 30) / 2,    // Center vertically
        
        // Green filler
        fillProgress: 0,
        fillSpeed: config.fillSpeed,
        isMoving: true, // START MOVING IMMEDIATELY
        
        // Target boxes
        boxes: [],
        boxesMatched: 0,
        totalBoxes: config.boxCount,
        currentTargetIndex: 0,
        boxHeight: config.boxHeight,
        
        // E button glow
        eGlowIntensity: 0,
        
        // Timing
        gameStartTime: Date.now(),
        autoRestartTimeout: null,
        
        // Game state
        failed: false,
        won: false,
        
        // Settings
        difficultyButtons: [],
        
        // Difficulty button (NEW)
        difficultyButton: null
    };
    
    // Generate random box positions
    generateCuffBoxes();
    
    updateUI();
}

// FUNCTION 3: Generate boxes
function generateCuffBoxes() {
    const margin = 80;
    const availableWidth = gameState.barWidth - 2 * margin;
    const boxWidth = gameState.config.boxWidth;
    const minGap = 40; // Minimum gap between boxes
    const totalBoxWidth = gameState.totalBoxes * boxWidth;
    const totalMinGaps = (gameState.totalBoxes - 1) * minGap;
    
    gameState.boxes = [];
    
    // Check if we have enough space for all boxes with minimum gaps
    if (totalBoxWidth + totalMinGaps > availableWidth) {
        // Fallback: use evenly spaced positions if not enough room
        const spacing = availableWidth / (gameState.totalBoxes + 1);
        for (let i = 0; i < gameState.totalBoxes; i++) {
            gameState.boxes.push({
                x: margin + spacing * (i + 1) - boxWidth/2,
                width: boxWidth,
                matched: false,
                failed: false
            });
        }
        gameState.boxes.sort((a, b) => a.x - b.x);
        return;
    }
    
    // Generate boxes with proper spacing
    for (let i = 0; i < gameState.totalBoxes; i++) {
        let attempts = 0;
        let placed = false;
        
        while (attempts < 300 && !placed) {
            const x = margin + Math.random() * (availableWidth - boxWidth);
            
            let tooClose = false;
            for (let box of gameState.boxes) {
                // Calculate the actual distance between box edges
                const distance = Math.abs(x - box.x);
                
                // If boxes would overlap or be too close
                if (distance < boxWidth + minGap) {
                    tooClose = true;
                    break;
                }
            }
            
            if (!tooClose) {
                gameState.boxes.push({
                    x: x,
                    width: boxWidth,
                    matched: false,
                    failed: false
                });
                placed = true;
            }
            attempts++;
        }
        
        // Fallback: if couldn't place randomly after many attempts
        if (!placed) {
            // Find the largest gap and place there
            if (gameState.boxes.length === 0) {
                gameState.boxes.push({
                    x: margin,
                    width: boxWidth,
                    matched: false,
                    failed: false
                });
            } else {
                gameState.boxes.sort((a, b) => a.x - b.x);
                
                let largestGap = margin;
                let largestGapSize = gameState.boxes[0].x - margin;
                
                for (let j = 0; j < gameState.boxes.length - 1; j++) {
                    const gapStart = gameState.boxes[j].x + boxWidth;
                    const gapEnd = gameState.boxes[j + 1].x;
                    const gapSize = gapEnd - gapStart;
                    
                    if (gapSize > largestGapSize) {
                        largestGapSize = gapSize;
                        largestGap = gapStart;
                    }
                }
                
                // Check gap at the end
                const lastBox = gameState.boxes[gameState.boxes.length - 1];
                const endGap = (gameState.barWidth - margin) - (lastBox.x + boxWidth);
                if (endGap > largestGapSize) {
                    largestGapSize = endGap;
                    largestGap = lastBox.x + boxWidth;
                }
                
                // Place in the center of the largest gap
                gameState.boxes.push({
                    x: largestGap + (largestGapSize - boxWidth) / 2,
                    width: boxWidth,
                    matched: false,
                    failed: false
                });
            }
        }
    }
    
    // Final sort
    gameState.boxes.sort((a, b) => a.x - b.x);
}

function updateCuffHack() {
    if (gameState.won) return;
    
    const currentTime = Date.now();
    
    if (currentScene !== 'playing') return;
    
    // Move the green filler
    if (gameState.isMoving) {
        gameState.fillProgress += gameState.fillSpeed;
        
        // Update E button glow based on proximity to current box
        const currentBox = gameState.boxes[gameState.currentTargetIndex];
        if (currentBox && !currentBox.matched) {
            const boxCenter = currentBox.x + currentBox.width / 2;
            const distanceToBox = Math.abs(gameState.fillProgress - boxCenter);
            const glowRange = 150; // Start glowing 150px away
            
            if (distanceToBox < glowRange) {
                gameState.eGlowIntensity = 1 - (distanceToBox / glowRange);
            } else {
                gameState.eGlowIntensity = 0;
            }
        } else {
            gameState.eGlowIntensity = 0;
        }
        
        // Check if player passed a box without hitting it - AUTO RESTART
        if (currentBox && !currentBox.matched) {
            const boxEnd = currentBox.x + currentBox.width;
            
            // If filler passed the box completely, mark as failed and restart
            if (gameState.fillProgress > boxEnd + gameState.config.tolerance) {
                currentBox.failed = true;
                
                // STORE the timeout ID so we can clear it if needed
                gameState.autoRestartTimeout = setTimeout(() => {
                    const currentDifficulty = gameState.difficulty;
                    initCuffHack(currentDifficulty);
                }, 1000);
                
                gameState.isMoving = false;
                return;
            }
        }
        
        // Check if all boxes matched - WIN
        if (gameState.boxesMatched >= gameState.totalBoxes) {
            if (gameState.fillProgress >= gameState.barWidth) {
                gameState.won = true;
                gameState.isMoving = false;
            }
        }
        
        // Check if filler reached the end without matching all boxes - AUTO RESTART
        if (gameState.fillProgress >= gameState.barWidth && gameState.boxesMatched < gameState.totalBoxes) {
            gameState.failed = true;
            gameState.isMoving = false;
            
            // STORE the timeout ID so we can clear it if needed
            gameState.autoRestartTimeout = setTimeout(() => {
                const currentDifficulty = gameState.difficulty;
                initCuffHack(currentDifficulty);
            }, 1000);
            
            return;
        }
    }
    
    updateUI();
}

function drawCuffHack() {
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS && backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Draw win screen if won
    if (gameState.won) {
        // Green checkmark
        ctx.shadowBlur = 40;
        ctx.shadowColor = '#00ff00';
        ctx.fillStyle = '#00ff00';
        ctx.font = '80px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('‚úì', 600, 240);
        ctx.shadowBlur = 0;
        
        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = '28px "Press Start 2P", monospace';
        ctx.fillText('ESCAPED!', 600, 320);
        
        // Subtitle
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.fillText('You picked the lock!', 600, 360);
        
        // Click to retry
        ctx.fillStyle = '#8ce023';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText('CLICK TO RETRY', 600, 420);           
        return;
    }
    
    // Normal game screen (playing)
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('LOCKPICK HANDCUFFS', 600, 80);
    
    // Instructions
    ctx.fillStyle = '#8ce023';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.fillText('Press E when green bar matches the boxes!', 600, 120);
    
    
    // Draw the progress bar container (transparent black)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
    ctx.fillRect(gameState.barX, gameState.barY, gameState.barWidth, gameState.barHeight);
    
    // Draw green filler FIRST (behind boxes)
    if (gameState.fillProgress > 0) {
        ctx.fillStyle = '#8ce023';
        ctx.fillRect(
            gameState.barX,
            gameState.barY,
            Math.min(gameState.fillProgress, gameState.barWidth),
            gameState.barHeight
        );
    }
    
    // Draw border around bar
    ctx.strokeStyle = '#8ce023';
    ctx.lineWidth = 3;
    ctx.strokeRect(gameState.barX, gameState.barY, gameState.barWidth, gameState.barHeight);
    
    // Draw target boxes AFTER (on top of filler)
    const boxWidth = gameState.config.boxWidth + 20;
    const boxHeight = gameState.config.boxWidth + 20;
    const boxYOffset = -10;

    for (let i = 0; i < gameState.boxes.length; i++) {
        const box = gameState.boxes[i];
        
        if (box.matched) {
            ctx.fillStyle = 'rgba(140, 224, 35, 0.9)';
        } else if (box.failed) {
            ctx.fillStyle = 'rgba(220, 50, 50, 0.9)';
        } else if (i === gameState.currentTargetIndex) {
            const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(255, 255, 255, ${pulse})`;
        } else {
            ctx.fillStyle = 'rgba(40, 40, 40, 0.9)';
        }
        
        ctx.fillRect(
            gameState.barX + box.x,
            gameState.barY + boxYOffset,
            boxWidth,
            boxHeight
        );
        
        if (box.matched) {
            ctx.strokeStyle = '#8ce023';
        } else if (box.failed) {
            ctx.strokeStyle = '#dc3232';
        } else {
            ctx.strokeStyle = '#ffffff';
        }
        ctx.lineWidth = 2;
        ctx.strokeRect(
            gameState.barX + box.x,
            gameState.barY + boxYOffset,
            boxWidth,
            boxHeight
        );
    }
    
    // Draw difficulty icon 
    const diffBoxSize = 50;
    const diffBoxX = gameState.barX + gameState.barWidth + 20; // 20px right of the bar // More left than E button
    const diffBoxY = gameState.barY + (gameState.barHeight - diffBoxSize) / 2;

    // Determine colors and icon based on difficulty
    let bgColor, iconColor, hoverBgColor;
    if (gameState.difficulty === 'easy') {
        bgColor = '#8ce023'; // green
        iconColor = '#2d5016';
        hoverBgColor = '#9ef033';
    } else if (gameState.difficulty === 'medium') {
        bgColor = '#fbbf24'; // yellow
        iconColor = '#92400e';
        hoverBgColor = '#fcd34d';
    } else {
        bgColor = '#ef4444'; // red
        iconColor = '#7f1d1d';
        hoverBgColor = '#f87171';
    }

    // Box background
    ctx.fillStyle = bgColor;
    ctx.fillRect(diffBoxX, diffBoxY, diffBoxSize, diffBoxSize);

    // Box border
    ctx.strokeStyle = iconColor;
    ctx.lineWidth = 3;
    ctx.strokeRect(diffBoxX, diffBoxY, diffBoxSize, diffBoxSize);

    // Draw face icon (SVG-like shapes)
    ctx.fillStyle = iconColor;
    const centerX = diffBoxX + diffBoxSize / 2;
    const centerY = diffBoxY + diffBoxSize / 2;

    // Face circle
    ctx.beginPath();
    ctx.arc(centerX, centerY, 20, 0, Math.PI * 2);
    ctx.stroke();

    // Eyes
    ctx.beginPath();
    ctx.arc(centerX - 8, centerY - 5, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(centerX + 8, centerY - 5, 3, 0, Math.PI * 2);
    ctx.fill();

    // Mouth based on difficulty
    if (gameState.difficulty === 'easy') {
        // Smile
        ctx.beginPath();
        ctx.arc(centerX, centerY + 5, 10, 0, Math.PI);
        ctx.stroke();
    } else if (gameState.difficulty === 'medium') {
        // Straight line
        ctx.beginPath();
        ctx.moveTo(centerX - 10, centerY + 8);
        ctx.lineTo(centerX + 10, centerY + 8);
        ctx.stroke();
    } else {
        // Angry frown with eyebrows
        ctx.beginPath();
        ctx.arc(centerX, centerY + 12, 10, Math.PI, 0);
        ctx.stroke();
        // Eyebrows
        ctx.beginPath();
        ctx.moveTo(centerX - 12, centerY - 10);
        ctx.lineTo(centerX - 5, centerY - 7);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(centerX + 12, centerY - 10);
        ctx.lineTo(centerX + 5, centerY - 7);
        ctx.stroke();
    }

    // Store button for click detection
    if (!gameState.difficultyButton) {
        gameState.difficultyButton = {
            x: diffBoxX,
            y: diffBoxY,
            width: diffBoxSize,
            height: diffBoxSize
        };
    }

    // Draw E letter in a box to the left of the black bar
    const eBoxSize = 50;
    const eBoxX = gameState.barX - eBoxSize - 20; // 20px left of the bar
    const eBoxY = gameState.barY + (gameState.barHeight - eBoxSize) / 2;

    // Determine color based on failed state and intensity
    const currentBox = gameState.boxes[gameState.currentTargetIndex];
    const isFailed = currentBox && currentBox.failed;
    const intensity = gameState.eGlowIntensity || 0;

    // Glow effect for the box
    if (intensity > 0) {
        ctx.shadowBlur = 40 * intensity;
        ctx.shadowColor = isFailed ? `rgba(220, 50, 50, ${intensity})` : `rgba(140, 224, 35, ${intensity})`;
    }

    // Draw the box for E with intensity-based colors
    const boxDarkColor = isFailed ? 'rgba(80, 20, 20, 0.3)' : 'rgba(40, 80, 40, 0.3)';
    const boxWhiteBlend = `rgba(${220 + (255-220) * intensity * 0.5}, ${50 + (255-50) * intensity * 0.5}, ${50 + (255-50) * intensity * 0.5}, ${0.3 + 0.7 * intensity})`;

    ctx.fillStyle = intensity > 0 ? (isFailed ? boxWhiteBlend : `rgba(${140 + (255-140) * intensity * 0.5}, ${224 + (255-224) * intensity * 0.5}, ${35 + (255-35) * intensity * 0.5}, ${0.3 + 0.7 * intensity})`) : boxDarkColor;
    ctx.fillRect(eBoxX, eBoxY, eBoxSize, eBoxSize);

    // Box border with intensity
    const borderColor = intensity > 0 ? (isFailed ? boxWhiteBlend : `rgba(${140 + (255-140) * intensity * 0.5}, ${224 + (255-224) * intensity * 0.5}, ${35 + (255-35) * intensity * 0.5}, 1)`) : (isFailed ? '#dc3232' : '#8ce023');
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 3;
    ctx.strokeRect(eBoxX, eBoxY, eBoxSize, eBoxSize);

    // Draw the E letter with intensity
    const letterDarkColor = isFailed ? 'rgba(80, 20, 20, 0.3)' : 'rgba(40, 80, 40, 0.3)';
    const letterWhiteBlend = `rgba(${220 + (255-220) * intensity * 0.5}, ${50 + (255-50) * intensity * 0.5}, ${50 + (255-50) * intensity * 0.5}, ${0.3 + 0.7 * intensity})`;

    ctx.fillStyle = intensity > 0 ? (isFailed ? letterWhiteBlend : `rgba(${140 + (255-140) * intensity * 0.5}, ${224 + (255-224) * intensity * 0.5}, ${35 + (255-35) * intensity * 0.5}, ${0.3 + 0.7 * intensity})`) : letterDarkColor;
    ctx.font = 'bold 36px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('E', eBoxX + eBoxSize/2, eBoxY + eBoxSize/2);

    ctx.shadowBlur = 0; // Reset shadow   
}

function drawCuffIntro() {
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS && backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '24px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('LOCKPICK HANDCUFFS', 600, 120);
    
    // Instructions panel
    const panelWidth = 600;
    const panelHeight = 300;
    const panelX = (1200 - panelWidth) / 2;
    const panelY = 180;
    
    ctx.fillStyle = 'rgba(20, 30, 48, 0.95)';
    ctx.strokeStyle = '#8ce023';
    ctx.lineWidth = 3;
    ctx.fillRect(panelX, panelY, panelWidth, panelHeight);
    ctx.strokeRect(panelX, panelY, panelWidth, panelHeight);
    
    // Instructions title
    ctx.fillStyle = '#8ce023';
    ctx.font = '18px "Press Start 2P", monospace';
    ctx.fillText('HOW TO PLAY', 600, panelY + 50);
    
    // Instructions text
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Press E when the green bar', 600, panelY + 100);
    ctx.fillText('matches the boxes!', 600, panelY + 130);
    
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.fillStyle = '#8ce023';
    ctx.fillText('Use the face icon to change difficulty', 600, panelY + 180);
    
    // Click to start
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.fillText('CLICK TO START', 600, panelY + 240);
}

function drawCuffCountdown() {
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS && backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    const elapsed = (Date.now() - gameState.countdownStart) / 1000;
    const remaining = Math.ceil(3 - elapsed);
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GET READY!', 600, 200);
    
    // Countdown number
    ctx.fillStyle = '#8ce023';
    ctx.font = '72px "Press Start 2P", monospace';
    ctx.fillText(remaining.toString(), 600, 320);
    
    // Instructions
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.fillText('Press E when green matches the boxes', 600, 400);
}

function handleCuffIntroClick(x, y) {
    if (!gameState.difficultyButtons) return;
    
    for (let button of gameState.difficultyButtons) {
        if (x >= button.x && x <= button.x + button.width &&
            y >= button.y && y <= button.y + button.height) {
            
            // Start game with selected difficulty
            initCuffHack(button.difficulty); // NOW this function exists!
            return;
        }
    }
}

// FUNCTION 8: Handle gameplay clicks
// FUNCTION 8: Handle gameplay clicks
function handleCuffClick(x, y) {
    // Check difficulty button click FIRST (always accessible)
    if (gameState.difficultyButton &&
        x >= gameState.difficultyButton.x &&
        x <= gameState.difficultyButton.x + gameState.difficultyButton.width &&
        y >= gameState.difficultyButton.y &&
        y <= gameState.difficultyButton.y + gameState.difficultyButton.height) {
        
        // Cycle difficulty: easy -> medium -> hard -> easy
        const nextDifficulty = {
            'easy': 'medium',
            'medium': 'hard',
            'hard': 'easy'
        };
        initCuffHack(nextDifficulty[gameState.difficulty]);
        return;
    }
    
    // Block ALL clicks during failed state
    if (gameState.failed && !gameState.won) {
        if (gameState.autoRestartTimeout) {
            clearTimeout(gameState.autoRestartTimeout);
            gameState.autoRestartTimeout = null;
        }
               
        // If not back button, restart with current difficulty
        const currentDifficulty = gameState.difficulty;
        initCuffHack(currentDifficulty);
        return;
    }
        
    // If game is won, clicking anywhere restarts same difficulty
    if (gameState.won) {
        const currentDifficulty = gameState.difficulty;
        initCuffHack(currentDifficulty);
        return;
    }
}

function handleCuffKeyPress(key) {
    if (currentScene !== 'playing' || !gameState.isMoving) return;
    if (gameState.failed || gameState.won) return;
    
    // E key to match
    if (key === 'e' || key === 'E') {
        const currentBox = gameState.boxes[gameState.currentTargetIndex];
        
        if (!currentBox || currentBox.matched) return;
        
        // Check if filler is within the box with tolerance
        const boxStart = currentBox.x - gameState.config.tolerance;
        const boxEnd = currentBox.x + currentBox.width + gameState.config.tolerance;
        
        if (gameState.fillProgress >= boxStart && gameState.fillProgress <= boxEnd) {
            // SUCCESS!
            currentBox.matched = true;
            gameState.boxesMatched++;
            gameState.currentTargetIndex++;
            gameState.eGlowIntensity = 0; // Reset glow after success
            
            // Check if all boxes matched
            if (gameState.boxesMatched >= gameState.totalBoxes) {
                gameState.isMoving = true; // Continue to fill bar
            }
        } else {
            // FAIL - pressed at wrong time
            currentBox.failed = true;
            gameState.failed = true;
            gameState.isMoving = false;
            
            // STORE the timeout ID so we can clear it if needed
            gameState.autoRestartTimeout = setTimeout(() => {
                const currentDifficulty = gameState.difficulty;
                initCuffHack(currentDifficulty);
            }, 1000);
        }
    }
}

// ============= GAME 13: CONNECT PIPES =============
function initConnectPipes() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    const gridWidth = 8;
    const gridHeight = 4;
    const pipeSize = 100;
    
    gameState = {
        gridWidth: gridWidth,
        gridHeight: gridHeight,
        pipeSize: pipeSize,
        gameWidth: gridWidth * pipeSize,
        gameHeight: gridHeight * pipeSize,
        
        pipes: [],
        startPos: { x: 0, y: 0 },
        endPos: { x: gridWidth - 1, y: gridHeight - 1 },
        
        timeLeft: 50,
        startTime: settings.skipIntros ? Date.now() : null,
        
        gameOver: false,
        won: false,

        showSolution: false,
        solutionPath: []
    };
    
    // Generate solvable pipe layout
    generatePipeGrid();
    
    if (settings.skipIntros) gameState.startTime = Date.now();
    updateUI();
}


function generatePipeGrid() {
    const { gridWidth, gridHeight } = gameState;

    // Initialize empty grid with random pipes
    gameState.pipes = Array(gridHeight).fill(null).map(() => 
        Array(gridWidth).fill(null).map(() => ({
            type: Math.random() < 0.5 ? 'straight' : 'corner',
            rotation: [0, 90, 180, 270][Math.floor(Math.random() * 4)],
            isStart: false,
            isEnd: false,
            locked: false
        }))
    );

    // Set start pipe (top-left) - must receive from top/left wall and send into grid
    const startType = Math.random() < 0.5 ? 'straight' : 'corner';
    let startRotation;

    if (startType === 'straight') {
        startRotation = Math.random() < 0.5 ? 0 : 90;
    } else {
        const validStartRotations = [90, 270]; 
        startRotation = validStartRotations[Math.floor(Math.random() * validStartRotations.length)];
    }

    gameState.pipes[0][0] = {
        type: startType,
        rotation: startRotation,
        isStart: true,
        isEnd: false,
        locked: true
    };

    // Set end pipe (bottom-right) - always corner pointing into grid
    gameState.pipes[gridHeight-1][gridWidth-1] = {
        type: 'corner',
        rotation: 0,
        isStart: false,
        isEnd: true,
        locked: true
    };
    
    // Create guaranteed valid solution path using BFS-based generation
    createSolutionPathBFS();
    
    // Scramble all non-solution pipes
    scrambleNonSolutionPipes();
}

// NEW: Generate solution using BFS to create random valid paths
function createSolutionPathBFS() {
    const { gridWidth, gridHeight } = gameState;
    
    let attempts = 0;
    let validPath = null;
    
    while (!validPath && attempts < 50) {
        attempts++;
        
        // Generate a random path from start to end
        const path = generateRandomValidPath();
        
        if (path && path.length >= 5) { // Ensure path is long enough
            validPath = path;
            break;
        }
    }
    
    if (!validPath) {
        // Fallback to simple path
        validPath = generateSimpleValidPath();
    }
    
    // Configure pipes along the path
    gameState.solutionPath = [];
    
    for (let i = 0; i < validPath.length; i++) {
        const pos = validPath[i];
        const pipe = gameState.pipes[pos.y][pos.x];
        
        // Determine connections this pipe needs
        const connections = [];
        
        // Connection to previous
        if (i > 0) {
            const prev = validPath[i - 1];
            connections.push({ dx: prev.x - pos.x, dy: prev.y - pos.y });
        } else {
            // Start pipe - add wall connection
            if (pipe.type === 'straight') {
                connections.push(pipe.rotation === 0 ? { dx: -1, dy: 0 } : { dx: 0, dy: -1 });
            } else {
                connections.push(pipe.rotation === 90 ? { dx: 0, dy: -1 } : { dx: -1, dy: 0 });
            }
        }
        
        // Connection to next
        if (i < validPath.length - 1) {
            const next = validPath[i + 1];
            connections.push({ dx: next.x - pos.x, dy: next.y - pos.y });
        }
        
        // Configure pipe for these connections (except start and end which are locked)
        if (!pipe.locked && connections.length === 2) {
            configurePipe(pipe, connections);
        }
        
        gameState.solutionPath.push({
            x: pos.x,
            y: pos.y,
            correctRotation: pipe.rotation,
            correctType: pipe.type,
            isLocked: pipe.locked
        });
    }
}

function generateRandomValidPath() {
    const { gridWidth, gridHeight } = gameState;
    const startPipe = gameState.pipes[0][0];
    
    // Get ACTUAL valid first moves based on start pipe outputs
    const startOutputs = getPipeOutputs(startPipe);
    const validFirstMoves = startOutputs.filter(output => {
        const nx = 0 + output.dx;
        const ny = 0 + output.dy;
        // Must be within grid bounds
        return nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight;
    });
    
    if (validFirstMoves.length === 0) {
        console.error('Start pipe has no valid outputs into grid!');
        return null;
    }
    
    // Use BFS with randomization to find a path
    const visited = Array(gridHeight).fill(null).map(() => Array(gridWidth).fill(false));
    const path = [{x: 0, y: 0}];
    visited[0][0] = true;
    
    // First move MUST respect start pipe's actual outputs
    const firstMove = validFirstMoves[Math.floor(Math.random() * validFirstMoves.length)];
    let current = {x: 0 + firstMove.dx, y: 0 + firstMove.dy};
    visited[current.y][current.x] = true;
    path.push(current);
    
    // Random walk with bias toward end
    while (current.x !== gridWidth - 1 || current.y !== gridHeight - 1) {
        const moves = [];
        
        // Check all four directions
        const directions = [
            {dx: 1, dy: 0},
            {dx: 0, dy: 1},
            {dx: -1, dy: 0},
            {dx: 0, dy: -1}
        ];
        
        for (let dir of directions) {
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            
            if (nx >= 0 && nx < gridWidth && ny >= 0 && ny < gridHeight && !visited[ny][nx]) {
                // Calculate distance to end
                const distToEnd = Math.abs(nx - (gridWidth - 1)) + Math.abs(ny - (gridHeight - 1));
                moves.push({x: nx, y: ny, dist: distToEnd, dir});
            }
        }
        
        if (moves.length === 0) {
            return null; // Dead end, retry
        }
        
        // Sort by distance and add randomness
        moves.sort((a, b) => a.dist - b.dist);
        
        // 70% chance to pick closest, 30% random
        let next;
        if (Math.random() < 0.7 && moves.length > 0) {
            next = moves[0];
        } else {
            next = moves[Math.floor(Math.random() * moves.length)];
        }
        
        visited[next.y][next.x] = true;
        path.push({x: next.x, y: next.y});
        current = next;
        
        // Prevent paths that are too long
        if (path.length > gridWidth * gridHeight / 2) {
            return null;
        }
    }
    
    return path;
}

function generateSimpleValidPath() {
    const { gridWidth, gridHeight } = gameState;
    const startPipe = gameState.pipes[0][0];
    const startOutputs = getPipeOutputs(startPipe);
    
    const path = [{x: 0, y: 0}];
    
    // Check if start pipe can go right
    const canGoRight = startOutputs.some(out => out.dx === 1 && out.dy === 0);
    // Check if start pipe can go down
    const canGoDown = startOutputs.some(out => out.dx === 0 && out.dy === 1);
    
    if (canGoRight) {
        // Go right then down
        for (let x = 1; x < gridWidth; x++) {
            path.push({x, y: 0});
        }
        for (let y = 1; y < gridHeight; y++) {
            path.push({x: gridWidth - 1, y});
        }
    } else if (canGoDown) {
        // Go down then right
        for (let y = 1; y < gridHeight; y++) {
            path.push({x: 0, y});
        }
        for (let x = 1; x < gridWidth; x++) {
            path.push({x, y: gridHeight - 1});
        }
    } else {
        // Fallback - should not happen
        console.error('Start pipe cannot go right or down!');
        for (let x = 1; x < gridWidth; x++) {
            path.push({x, y: 0});
        }
        for (let y = 1; y < gridHeight; y++) {
            path.push({x: gridWidth - 1, y});
        }
    }
    
    return path;
}

// NEW: Scramble all pipes that are NOT on the solution path
function scrambleNonSolutionPipes() {
    const solutionPositions = new Set(
        gameState.solutionPath.map(p => `${p.x},${p.y}`)
    );
    
    for (let y = 0; y < gameState.gridHeight; y++) {
        for (let x = 0; x < gameState.gridWidth; x++) {
            const key = `${x},${y}`;
            
            if (!solutionPositions.has(key)) {
                const pipe = gameState.pipes[y][x];
                // Randomize type and rotation
                pipe.type = Math.random() < 0.5 ? 'straight' : 'corner';
                pipe.rotation = [0, 90, 180, 270][Math.floor(Math.random() * 4)];
            } else if (!gameState.pipes[y][x].locked) {
                // Scramble solution pipes (rotate randomly)
                const pipe = gameState.pipes[y][x];
                const correctRotation = pipe.rotation;
                const rotations = [0, 90, 180, 270].filter(r => r !== correctRotation);
                pipe.rotation = rotations[Math.floor(Math.random() * rotations.length)];
            }
        }
    }
}


function getPipeOutputs(pipe) {
    const outputs = [];
    const rot = pipe.rotation;
    
    if (pipe.type === 'straight') {
        // Horizontal by default at 0¬∞
        if (rot === 0 || rot === 180) {
            outputs.push({ dx: -1, dy: 0 }, { dx: 1, dy: 0 });
        } else {
            outputs.push({ dx: 0, dy: -1 }, { dx: 0, dy: 1 });
        }
    } else {
        // Corner: connects two perpendicular directions
        if (rot === 0) {
            outputs.push({ dx: -1, dy: 0 }, { dx: 0, dy: -1 }); // left and up
        } else if (rot === 90) {
            outputs.push({ dx: 0, dy: -1 }, { dx: 1, dy: 0 });  // up and right
        } else if (rot === 180) {
            outputs.push({ dx: 1, dy: 0 }, { dx: 0, dy: 1 });   // right and down
        } else {
            outputs.push({ dx: 0, dy: 1 }, { dx: -1, dy: 0 });  // down and left
        }
    }
    
    return outputs;
}


function configurePipe(pipe, connections) {
    // connections is array of {dx, dy} that pipe must connect
    
    if (connections.length !== 2) return;
    
    const [conn1, conn2] = connections;
    
    // Check if straight pipe (opposite directions)
    if ((conn1.dx === -conn2.dx && conn1.dy === -conn2.dy)) {
        pipe.type = 'straight';
        // Horizontal or vertical
        pipe.rotation = (conn1.dx !== 0) ? 0 : 90;
    } else {
        // Corner pipe
        pipe.type = 'corner';
        
        // Determine rotation based on connection directions
        // Corner default: connects left (-1,0) and up (0,-1)
        
        if ((conn1.dx === -1 && conn2.dy === -1) || (conn2.dx === -1 && conn1.dy === -1)) {
            pipe.rotation = 0; // left and up
        } else if ((conn1.dx === 1 && conn2.dy === -1) || (conn2.dx === 1 && conn1.dy === -1)) {
            pipe.rotation = 90; // up and right
        } else if ((conn1.dx === 1 && conn2.dy === 1) || (conn2.dx === 1 && conn1.dy === 1)) {
            pipe.rotation = 180; // right and down
        } else if ((conn1.dx === -1 && conn2.dy === 1) || (conn2.dx === -1 && conn1.dy === 1)) {
            pipe.rotation = 270; // down and left
        }
    }
}

function updateConnectPipes() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Update timer
    if (gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        gameState.timeLeft = Math.max(0, 50 - elapsedSeconds);
        
        if (gameState.timeLeft <= 0) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK FAILED!', 'Time ran out!');
            }, 100);
            return;
        }
    }
    
    // Check if solution is complete
    if (checkConnection()) {
        gameState.gameOver = true;
        gameState.won = true;
        setTimeout(() => {
            endGame('HACK COMPLETED', 'All pipes connected!');
        }, 100);
        return;
    }
    
    updateUI();
}

function drawConnectPipes() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('CONNECT PIPES', currentScene === 'countdown');
        return;
    }
    
    const gameWidth = gameState.gameWidth;
    const gameHeight = gameState.gameHeight;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 120;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // trojanOS background
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Game area background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
    
    // Get connected pipes (pipes reachable from start)
    const connected = getConnectedPipes();
    
    // Draw grid squares with larger white texture
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
    ctx.lineWidth = 2;
    for (let y = 0; y < gameState.gridHeight; y++) {
        for (let x = 0; x < gameState.gridWidth; x++) {
            const px = offsetX + x * gameState.pipeSize;
            const py = offsetY + y * gameState.pipeSize;
            
            ctx.strokeRect(px, py, gameState.pipeSize, gameState.pipeSize);
        }
    }
    
    // Draw pipes
    for (let y = 0; y < gameState.gridHeight; y++) {
        for (let x = 0; x < gameState.gridWidth; x++) {
            const pipe = gameState.pipes[y][x];
            const px = offsetX + x * gameState.pipeSize + gameState.pipeSize / 2;
            const py = offsetY + y * gameState.pipeSize + gameState.pipeSize / 2;
            
            const isConnected = connected[y][x];
            
            // Check if this pipe is on solution path
            const isOnSolutionPath = gameState.showSolution && 
                gameState.solutionPath.some(p => p.x === x && p.y === y);

            // Draw highlight for solution path
            if (isOnSolutionPath) {
                ctx.fillStyle = 'rgba(255, 255, 0, 0.2)';
                ctx.fillRect(
                    offsetX + x * gameState.pipeSize, 
                    offsetY + y * gameState.pipeSize, 
                    gameState.pipeSize, 
                    gameState.pipeSize
                );
            }
            
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(pipe.rotation * Math.PI / 180);
            
            // Determine color based on connection state
            let coreColor, glowColor, highlightColor, outerGlowColor;

            if (isConnected) {
                // Connected to start pipe - NEON GREEN
                coreColor = '#8CE023';
                glowColor = '#AFFF3D';
                highlightColor = '#BFFF5C';
                outerGlowColor = '#8CE023';
            } else {
                // Not connected yet - GREY
                coreColor = '#9A9A9A';
                glowColor = '#B0B0B0';
                highlightColor = '#C8C8C8';
                outerGlowColor = '#787878';
            }
            
           ctx.lineCap = 'butt';
            ctx.lineJoin = 'miter';
            
            const halfSize = gameState.pipeSize / 2;
            
            if (pipe.type === 'straight') {
                // Draw rectangular pipe that spans full square width
                const pipeWidth = 14;
                
                if (isConnected) {
                    // Outer glow (neon effect) - only for connected pipes
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = coreColor;
                    ctx.fillStyle = outerGlowColor;
                    ctx.fillRect(-halfSize, -pipeWidth/2, gameState.pipeSize, pipeWidth);
                    ctx.shadowBlur = 0;
                }
                
                // Dark shadow/depth
                ctx.fillStyle = '#2A2A2A';
                ctx.fillRect(-halfSize, -pipeWidth/2, gameState.pipeSize, pipeWidth);
                
                // Core pipe
                ctx.fillStyle = coreColor;
                ctx.fillRect(-halfSize, -pipeWidth/2, gameState.pipeSize, pipeWidth);
                
                // Bright highlight
                ctx.fillStyle = glowColor;
                ctx.fillRect(-halfSize, -pipeWidth/2, gameState.pipeSize, pipeWidth/3);
                
            } else {
                // Draw L-shape corner that reaches both walls seamlessly
                const pipeWidth = 14;
                
                if (isConnected) {
                    // Outer glow (neon effect) - only for connected pipes
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = coreColor;
                    ctx.fillStyle = outerGlowColor;
                    // Horizontal part (same dimensions as core)
                    ctx.fillRect(-halfSize, -pipeWidth/2, halfSize + pipeWidth/2, pipeWidth);
                    // Vertical part (same dimensions as core)
                    ctx.fillRect(-pipeWidth/2, -halfSize, pipeWidth, halfSize + pipeWidth/2);
                    ctx.shadowBlur = 0;
                }
                
                // Dark shadow/depth
                ctx.fillStyle = '#2A2A2A';
                // Horizontal part
                ctx.fillRect(-halfSize, -pipeWidth/2, halfSize + pipeWidth/2, pipeWidth);
                // Vertical part
                ctx.fillRect(-pipeWidth/2, -halfSize, pipeWidth, halfSize + pipeWidth/2);
                
                // Core pipe
                ctx.fillStyle = coreColor;
                // Horizontal part (left edge to center + pipeWidth/2 for seamless corner)
                ctx.fillRect(-halfSize, -pipeWidth/2, halfSize + pipeWidth/2, pipeWidth);
                // Vertical part (top edge to center + pipeWidth/2 for seamless corner)
                ctx.fillRect(-pipeWidth/2, -halfSize, pipeWidth, halfSize + pipeWidth/2);
                
                // Bright highlight
                ctx.fillStyle = glowColor;
                // Horizontal part
                ctx.fillRect(-halfSize, -pipeWidth/2, halfSize + pipeWidth/2, pipeWidth/3);
                // Vertical part
                ctx.fillRect(-pipeWidth/2, -halfSize, pipeWidth, halfSize + pipeWidth/2);
            }
            
            ctx.restore();
        }
    }
    
 // Draw target square on end pipe
const endX = gameState.endPos.x;
const endY = gameState.endPos.y;
const endPx = offsetX + endX * gameState.pipeSize + gameState.pipeSize / 2;
const endPy = offsetY + endY * gameState.pipeSize + gameState.pipeSize / 2;

const squareSize = 50; // Small enough to see pipe corners

// Check if end pipe is connected
const connectedPipes = getConnectedPipes();
const isEndConnected = connectedPipes[endY][endX];

// Match the pipe color
const squareColor = isEndConnected ? '#8CE023' : '#9A9A9A';

ctx.fillStyle = squareColor; // Solid color matching pipe
ctx.fillRect(
    endPx - squareSize / 2,
    endPy - squareSize / 2,
    squareSize,
    squareSize
);


    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('CONNECT PIPES', 600, 30);
    
    // Timer
    const timerWidth = gameWidth;
    const timerX = offsetX;
    const timerY = offsetY + gameHeight + 10;
    const progress = Math.max(0, gameState.timeLeft / 50);
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 5);
    
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(timerX, timerY, timerWidth * progress, 5);
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1;
    ctx.strokeRect(timerX, timerY, timerWidth, 5);
    
    // Instructions
    ctx.fillStyle = '#8ce023';
    ctx.font = '12px "Press Start 2P", monospace';
    ctx.fillText('CLICK TO ROTATE ‚Ä¢ PRESS H FOR HINT', 600, offsetY + gameHeight + 30);
}

function handleConnectPipesClick(x, y) {
    if (currentScene !== 'playing' || gameState.gameOver) return;
    
    const gameWidth = gameState.gameWidth;
    const gameHeight = gameState.gameHeight;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 120; // Match the offsetY from drawConnectPipes
    
    // Check if click is within the game area
    if (x < offsetX || x > offsetX + gameWidth || y < offsetY || y > offsetY + gameHeight) {
        return;
    }
    
    // Calculate grid coordinates
    const gridX = Math.floor((x - offsetX) / gameState.pipeSize);
    const gridY = Math.floor((y - offsetY) / gameState.pipeSize);
    
    // Validate grid coordinates
    if (gridX >= 0 && gridX < gameState.gridWidth && 
        gridY >= 0 && gridY < gameState.gridHeight) {
        
        const pipe = gameState.pipes[gridY][gridX];
        
        if (!pipe.locked) {
            pipe.rotation = (pipe.rotation + 90) % 360;
        }
    }
}

function getConnectedPipes() {
    const connected = Array(gameState.gridHeight).fill(null).map(() => 
        Array(gameState.gridWidth).fill(false)
    );
    
    // BFS from start to find all pipes reachable from start
    const queue = [{ x: gameState.startPos.x, y: gameState.startPos.y }];
    const visited = new Set(['0,0']);
    connected[gameState.startPos.y][gameState.startPos.x] = true;
    
    // Track if we've reached the end
    let endReached = false;
    
    while (queue.length > 0) {
        const current = queue.shift();
        const pipe = gameState.pipes[current.y][current.x];
        const outputs = getPipeOutputs(pipe);
        
        for (let dir of outputs) {
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            const key = `${nx},${ny}`;
            
            // Check bounds
            if (nx < 0 || nx >= gameState.gridWidth || ny < 0 || ny >= gameState.gridHeight) continue;
            if (visited.has(key)) continue; // Already visited
            
            const neighbor = gameState.pipes[ny][nx];
            const neighborInputs = getPipeOutputs(neighbor);
            
            // Check if neighbor accepts connection from this direction
            const oppositeDir = { dx: -dir.dx, dy: -dir.dy };
            const accepts = neighborInputs.some(inp => inp.dx === oppositeDir.dx && inp.dy === oppositeDir.dy);
            
            if (accepts) {
                connected[ny][nx] = true;
                visited.add(key);
                queue.push({ x: nx, y: ny });
                
                // Check if we reached the end
                if (nx === gameState.endPos.x && ny === gameState.endPos.y) {
                    endReached = true;
                }
            }
        }
    }
    
    // If end is reached, trace back the actual solution path and mark only those as connected
    if (endReached) {
        const solutionPath = traceSolutionPath();
        
        // Reset all to false
        for (let y = 0; y < gameState.gridHeight; y++) {
            for (let x = 0; x < gameState.gridWidth; x++) {
                connected[y][x] = false;
            }
        }
        
        // Mark only solution path as connected
        for (let pos of solutionPath) {
            connected[pos.y][pos.x] = true;
        }
    }
    
    return connected;
}

// NEW FUNCTION: Trace the actual solution path from start to end
function traceSolutionPath() {
    const path = [];
    const parent = {};
    const queue = [{ x: gameState.startPos.x, y: gameState.startPos.y }];
    const visited = new Set(['0,0']);
    parent['0,0'] = null;
    
    let foundEnd = false;
    
    // BFS to find path to end
    while (queue.length > 0 && !foundEnd) {
        const current = queue.shift();
        const pipe = gameState.pipes[current.y][current.x];
        const outputs = getPipeOutputs(pipe);
        
        for (let dir of outputs) {
            const nx = current.x + dir.dx;
            const ny = current.y + dir.dy;
            const key = `${nx},${ny}`;
            
            if (nx < 0 || nx >= gameState.gridWidth || ny < 0 || ny >= gameState.gridHeight) continue;
            if (visited.has(key)) continue;
            
            const neighbor = gameState.pipes[ny][nx];
            const neighborInputs = getPipeOutputs(neighbor);
            
            const oppositeDir = { dx: -dir.dx, dy: -dir.dy };
            const accepts = neighborInputs.some(inp => inp.dx === oppositeDir.dx && inp.dy === oppositeDir.dy);
            
            if (accepts) {
                visited.add(key);
                parent[key] = { x: current.x, y: current.y };
                queue.push({ x: nx, y: ny });
                
                if (nx === gameState.endPos.x && ny === gameState.endPos.y) {
                    foundEnd = true;
                    break;
                }
            }
        }
    }
    
    // Trace back from end to start
    if (foundEnd) {
        let current = { x: gameState.endPos.x, y: gameState.endPos.y };
        
        while (current) {
            path.unshift(current);
            const key = `${current.x},${current.y}`;
            current = parent[key];
        }
    }
    
    return path;
}

function getPipeOutputs(pipe) {
    const outputs = [];
    const rot = pipe.rotation;
    
    if (pipe.type === 'straight') {
        // Horizontal by default at 0¬∞
        if (rot === 0 || rot === 180) {
            outputs.push({ dx: -1, dy: 0 }, { dx: 1, dy: 0 });
        } else {
            outputs.push({ dx: 0, dy: -1 }, { dx: 0, dy: 1 });
        }
    } else {
        // Corner: connects two perpendicular directions
        if (rot === 0) {
            outputs.push({ dx: -1, dy: 0 }, { dx: 0, dy: -1 }); // left and up
        } else if (rot === 90) {
            outputs.push({ dx: 0, dy: -1 }, { dx: 1, dy: 0 });  // up and right
        } else if (rot === 180) {
            outputs.push({ dx: 1, dy: 0 }, { dx: 0, dy: 1 });   // right and down
        } else {
            outputs.push({ dx: 0, dy: 1 }, { dx: -1, dy: 0 });  // down and left
        }
    }
    
    return outputs;
}

// NEW FUNCTION: Get valid directions a pipe can receive from (considering walls)
function getPipeInputs(pipe, x, y) {
    const outputs = getPipeOutputs(pipe);
    // Inputs are the opposite of outputs
    return outputs.map(out => ({
        dx: -out.dx,
        dy: -out.dy,
        // Check if this input comes from outside the grid (wall)
        fromWall: (x + (-out.dx) < 0 || x + (-out.dx) >= gameState.gridWidth || 
                   y + (-out.dy) < 0 || y + (-out.dy) >= gameState.gridHeight)
    }));
}

function checkConnection() {
    const connected = getConnectedPipes();
    return connected[gameState.endPos.y][gameState.endPos.x];
}

// GAME 14 : FIND PAIRS & FLOPPY BIRD
function initFindPairs() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    const pairs = [];
    const usedNumbers = new Set();
    
    // Generate 5 pairs
    for (let i = 0; i < 5; i++) {
        let num;
        do {
            num = Math.floor(Math.random() * 99) + 1;
        } while (usedNumbers.has(num));
        usedNumbers.add(num);
        pairs.push(num, num);
    }
    
    // Generate 39 unique numbers
    while (pairs.length < 49) {
        let num;
        do {
            num = Math.floor(Math.random() * 99) + 1;
        } while (usedNumbers.has(num));
        usedNumbers.add(num);
        pairs.push(num);
    }
    
    // Shuffle
    for (let i = pairs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pairs[i], pairs[j]] = [pairs[j], pairs[i]];
    }
    
    // Convert to 7x7 grid
    const grid = [];
    for (let i = 0; i < 7; i++) {
        grid.push(pairs.slice(i * 7, (i + 1) * 7));
    }
    
    gameState.findPairsGrid = grid;
    gameState.selectedCells = [];
    gameState.foundPairs = [];
    gameState.pairsFound = 0;
    gameState.timeLeft = 50;
    gameState.showHint = false;
    
    // Generate pair positions for hints
    gameState.pairPositions = [];
    const pairMap = new Map();
    
    // Find all pair positions
    for (let y = 0; y < 7; y++) {
        for (let x = 0; x < 7; x++) {
            const num = grid[y][x];
            if (!pairMap.has(num)) {
                pairMap.set(num, []);
            }
            pairMap.get(num).push({x, y});
        }
    }
    
    // Store only the actual pairs (numbers that appear exactly twice)
    const hintColors = ['#ff8800', '#ff00ff', '#00ff00', '#00ccff', '#ffff00'];
    let colorIndex = 0;
    
    for (let [num, positions] of pairMap) {
        if (positions.length === 2) {
            gameState.pairPositions.push({
                number: num,
                positions: positions,
                color: hintColors[colorIndex % hintColors.length]
            });
            colorIndex++;
        }
    }
    
    // ADD THIS LINE for skip intros
    if (settings.skipIntros) {
        currentScene = 'playing';
        gameState.startTime = Date.now();
    }
    
    updateUI();
}


function initBlockExternalSignal() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    // Smaller game area like Avoid Walls
    const gameWidth = 600;
    const gameHeight = 500;
    const offsetX = (1200 - gameWidth) / 2;
    const offsetY = 50;
    
    gameState = {
        birdY: gameHeight / 2,
        birdVelocity: 0,
        birdSize: 25,
        gravity: 0.5,
        jumpStrength: -10,
        walls: [],
        wallSpeed: 4,
        wallGap: 150,
        wallWidth: 40,
        wallSpawnTimer: 0,
        wallSpawnInterval: 90,
        timeLeft: 30,
        gameStarted: settings.skipIntros,
        
        // Game area dimensions
        gameWidth: gameWidth,
        gameHeight: gameHeight,
        offsetX: offsetX,
        offsetY: offsetY
    };
    
    if (settings.skipIntros) {
        currentScene = 'playing';
        gameState.startTime = Date.now();
        gameState.gameStarted = true;
    }
    
    updateUI();
}

function updateFindPairs() {
    if (gameState.gameOver) return;
    
    // Skip countdown if intro was skipped
    if (currentScene === 'countdown' && settings.skipIntros) {
        currentScene = 'playing';
        gameState.startTime = Date.now();
        return;
    }
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Update timer
    if (gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        gameState.timeLeft = Math.max(0, 50 - elapsedSeconds);
        
        if (gameState.timeLeft <= 0) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('TIME\'S UP!', `Pairs Found: ${gameState.pairsFound}/5`);
            }, 100);
            return;
        }
    }
    
    if (gameState.pairsFound >= 5) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK COMPLETED', 'All pairs found!');
        }, 100);
    }
    
    updateUI();
}


function updateBlockExternalSignal() {
    if (gameState.gameOver) return;
    
    // Skip countdown if intro was skipped
    if (currentScene === 'countdown' && settings.skipIntros) {
        currentScene = 'playing';
        gameState.startTime = Date.now();
        gameState.gameStarted = true;
        return;
    }
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
            gameState.gameStarted = true;
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    if (!gameState.gameStarted) return;
    
    // Update timer
    if (gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        gameState.timeLeft = Math.max(0, 30 - elapsedSeconds);
        
        if (gameState.timeLeft <= 0) {
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK COMPLETED', 'Signal blocked successfully!');
            }, 100);
            return;
        }
    }
    
    gameState.birdVelocity += gameState.gravity;
    gameState.birdY += gameState.birdVelocity;
    
    // Boundary checking within game area
    if (gameState.birdY < 0) {
        gameState.birdY = 0;
        gameState.birdVelocity = 0;
    }
    if (gameState.birdY > gameState.gameHeight - gameState.birdSize) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED!', 'Hit the ground!');
        }, 100);
        return;
    }
    
    gameState.wallSpawnTimer++;
    if (gameState.wallSpawnTimer >= gameState.wallSpawnInterval) {
        gameState.wallSpawnTimer = 0;
        
        const minHeight = 40;
        const maxHeight = gameState.gameHeight - gameState.wallGap - 40;
        const topHeight = Math.floor(Math.random() * (maxHeight - minHeight)) + minHeight;
        
        gameState.walls.push({
            x: gameState.gameWidth,
            topHeight: topHeight,
            bottomY: topHeight + gameState.wallGap
        });
    }
    
    for (let i = gameState.walls.length - 1; i >= 0; i--) {
        const wall = gameState.walls[i];
        wall.x -= gameState.wallSpeed;
        
        if (wall.x + gameState.wallWidth < 0) {
            gameState.walls.splice(i, 1);
            continue;
        }
        
        const birdX = 80; // Bird position within game area
        const absoluteBirdX = gameState.offsetX + birdX;
        const absoluteBirdY = gameState.offsetY + gameState.birdY;
        const absoluteWallX = gameState.offsetX + wall.x;
        
        if (absoluteBirdX + gameState.birdSize > absoluteWallX && 
            absoluteBirdX < absoluteWallX + gameState.wallWidth) {
            
            const wallTopEnd = gameState.offsetY + wall.topHeight;
            const wallBottomStart = gameState.offsetY + wall.bottomY;
            
            if (absoluteBirdY < wallTopEnd || absoluteBirdY + gameState.birdSize > wallBottomStart) {
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK FAILED!', 'Hit a pipe!');
                }, 100);
                return;
            }
        }
    }
    
    updateUI();
}

function drawFindPairs() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('FIND PAIRS', currentScene === 'countdown');
        return;
    }
    
    const cellSize = 58;
    const gridSize = 7;
    const totalWidth = cellSize * gridSize;
    const totalHeight = cellSize * gridSize;
    const offsetX = (1200 - totalWidth) / 2;
    const offsetY = 120;
    
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('FIND PAIRS', 600, 30);
    
    // Draw the main grid background (transparent black rounded square)
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    roundRect(ctx, offsetX - 10, offsetY - 10, totalWidth + 20, totalHeight + 20, 15);
    ctx.fill();
    
    // Draw hint highlights if enabled
    if (gameState.showHint) {
        for (let pair of gameState.pairPositions) {
            // Skip already found pairs
            const isFound = pair.positions.every(pos => 
                gameState.foundPairs.some(cell => cell.x === pos.x && cell.y === pos.y)
            );
            
            if (!isFound) {
                for (let pos of pair.positions) {
                    const px = offsetX + pos.x * cellSize;
                    const py = offsetY + pos.y * cellSize;
                    
                    // Draw colored background for hint
                    ctx.fillStyle = pair.color + '80'; 
                    roundRect(ctx, px + 8, py + 8, cellSize - 16, cellSize - 16, 5);
                    ctx.fill();
                    
                }
            }
        }
    }
    
    // Draw grid cells
    for (let y = 0; y < gridSize; y++) {
        for (let x = 0; x < gridSize; x++) {
            const px = offsetX + x * cellSize;
            const py = offsetY + y * cellSize;
            const num = gameState.findPairsGrid[y][x];
            
            const isFound = gameState.foundPairs.some(cell => cell.x === x && cell.y === y);
            const isSelected = gameState.selectedCells.some(cell => cell.x === x && cell.y === y);
            
            // Draw cell background (transparent white squares like in the image)
            if (!gameState.showHint || !isCellInHint(x, y)) {
                if (isFound) {
                    ctx.fillStyle = 'rgba(140, 224, 35, 0.7)'; // Semi-transparent green
                } else if (isSelected) {
                    ctx.fillStyle = 'rgba(100, 100, 100, 0.7)'; // Semi-transparent gray
                } else {
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)'; // Semi-transparent white like in the image
                }
                
                // Draw rounded rectangle for cell with 2px spacing
                roundRect(ctx, px + 8, py + 8, cellSize - 16, cellSize - 16, 5);
                ctx.fill();
                
            }
            
            // Draw number with the font style from the image
            ctx.fillStyle = isFound ? '#000000' : '#ffffff';
            ctx.font = 'bold 16px Arial, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(num.toString(), px + cellSize / 2, py + cellSize / 2);
        }
    }
    
    // Pairs found counter
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 16px Arial, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`${gameState.pairsFound} / 5`, 600, offsetY + totalHeight + 30);
    
    // Timer bar
    const timerWidth = totalWidth;
    const timerX = offsetX;
    const timerY = offsetY + totalHeight + 50;
    const progress = Math.max(0, gameState.timeLeft / 50);
    
    ctx.fillStyle = 'rgba(42, 42, 42, 0.7)';
    roundRect(ctx, timerX, timerY, timerWidth, 8, 4);
    ctx.fill();
    
    ctx.fillStyle = '#8ce023';
    roundRect(ctx, timerX, timerY, timerWidth * progress, 8, 4);
    ctx.fill();
    
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.lineWidth = 1;
    roundRect(ctx, timerX, timerY, timerWidth, 8, 4);
    ctx.stroke();
    
    // Hint instruction
    ctx.fillStyle = '#8ce023';
    ctx.font = 'bold 12px Arial, sans-serif';
    ctx.fillText('PRESS H FOR HINT', 600, offsetY + totalHeight + 80);
}

// Helper function to draw rounded rectangles
function roundRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
}

function isCellInHint(x, y) {
    if (!gameState.showHint) return false;
    
    for (let pair of gameState.pairPositions) {
        const isFound = pair.positions.every(pos => 
            gameState.foundPairs.some(cell => cell.x === pos.x && cell.y === pos.y)
        );
        
        if (!isFound) {
            for (let pos of pair.positions) {
                if (pos.x === x && pos.y === y) {
                    return true;
                }
            }
        }
    }
    return false;
}


function drawBlockExternalSignal() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('BLOCK EXTERNAL SIGNAL', currentScene === 'countdown');
        return;
    }
    
    const { gameWidth, gameHeight, offsetX, offsetY } = gameState;
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Game area background (semi-transparent)
    ctx.fillStyle = 'rgba(26, 26, 26, 0.7)';
    ctx.fillRect(offsetX, offsetY, gameWidth, gameHeight);
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('BLOCK EXTERNAL SIGNAL', 600, 30);
    
    // Draw walls within game area
    ctx.fillStyle = '#4a4a4a';
    for (const wall of gameState.walls) {
        // Top wall
        ctx.fillRect(
            offsetX + wall.x, 
            offsetY, 
            gameState.wallWidth, 
            wall.topHeight
        );
        // Bottom wall
        ctx.fillRect(
            offsetX + wall.x, 
            offsetY + wall.bottomY, 
            gameState.wallWidth, 
            gameHeight - wall.bottomY
        );
    }
    
    // Draw bird with glow effect
    ctx.fillStyle = '#8ce023';
    ctx.shadowBlur = 20;
    ctx.shadowColor = '#8ce023';
    ctx.fillRect(
        offsetX + 80, 
        offsetY + gameState.birdY, 
        gameState.birdSize, 
        gameState.birdSize
    );
    ctx.shadowBlur = 0;
    
    // Timer bar at bottom of game area
    const timerWidth = gameWidth;
    const timerX = offsetX;
    const timerY = offsetY + gameHeight + 10;
    const progress = Math.max(0, gameState.timeLeft / 30);
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 5);
    
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(timerX, timerY, timerWidth * progress, 5);
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1;
    ctx.strokeRect(timerX, timerY, timerWidth, 5);
    
    // Instructions
    if (!gameState.gameStarted) {
        ctx.fillStyle = '#8ce023';
        ctx.font = '12px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS SPACE TO JUMP', 600, offsetY + gameHeight / 2 - 20);
        ctx.fillText('Avoid pipes until the time runs out!', 600, offsetY + gameHeight / 2 + 10);
    } else {
        ctx.fillStyle = '#8ce023';
        ctx.font = '10px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PRESS SPACE TO JUMP', 600, offsetY + gameHeight + 30);
    }
}

function handleFindPairsClick(x, y) {
    if (currentScene !== 'playing') return;
    
    const cellSize = 58; // Match the cellSize from drawFindPairs
    const gridSize = 7;
    const totalWidth = cellSize * gridSize;
    const offsetX = (1200 - totalWidth) / 2;
    const offsetY = 120;
    
    // Check if click is within the grid area (including the spacing)
    if (x < offsetX || x > offsetX + totalWidth || y < offsetY || y > offsetY + totalWidth) {
        return;
    }
    

    const gridX = Math.floor((x - offsetX) / cellSize);
    const gridY = Math.floor((y - offsetY) / cellSize);
    

    const cellStartX = offsetX + gridX * cellSize;
    const cellStartY = offsetY + gridY * cellSize;
    

    if (x < cellStartX + 8 || x > cellStartX + cellSize - 8 || 
        y < cellStartY + 8 || y > cellStartY + cellSize - 8) {
        return; // Clicked in the spacing area, not the actual cell
    }
    
    if (gameState.foundPairs.some(cell => cell.x === gridX && cell.y === gridY)) {
        return;
    }
    
    const alreadySelected = gameState.selectedCells.findIndex(cell => cell.x === gridX && cell.y === gridY);
    if (alreadySelected !== -1) {
        gameState.selectedCells.splice(alreadySelected, 1);
        return;
    }
    
    gameState.selectedCells.push({ x: gridX, y: gridY });
    
    if (gameState.selectedCells.length === 2) {
        const cell1 = gameState.selectedCells[0];
        const cell2 = gameState.selectedCells[1];
        const num1 = gameState.findPairsGrid[cell1.y][cell1.x];
        const num2 = gameState.findPairsGrid[cell2.y][cell2.x];
        
        if (num1 === num2) {
            gameState.foundPairs.push(cell1, cell2);
            gameState.pairsFound++;
            gameState.selectedCells = [];
        } else {
            setTimeout(() => {
                gameState.selectedCells = [];
            }, 300);
        }
    }
}

// ============= GAME 15: ELECTRICITY PANEL =============
function initElectricityPanel() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    gameState = {
        // Pattern generation
        currentPattern: [],
        playerPattern: Array(12).fill(false), // false = off, true = on
        
        // Display state
        displayPhase: 'showing', 
        currentBreaker: 1, // Changed from 0 to 1 - start showing breaker 1 immediately
        lastBreakerTime: 0,
        breakerDelay: 1000, // 1 second between breakers
        
        // Progress tracking
        correctRounds: 0,
        totalRounds: 4,
        
        // Timing
        phaseStartTime: 0,
        checkStartTime: 0,
        checkDuration: 2000, // 2 second progress bar
        checkResult: null, // 'correct' or 'incorrect'
        
        gameOver: false,
        gameWon: false
    };
    
    // Generate first pattern
    generatePattern();
    
    if (settings.skipIntros) {
        gameState.lastBreakerTime = Date.now();
    }
    
    updateUI();
}

function generatePattern() {
    gameState.currentPattern = [];
    for (let i = 0; i < 12; i++) {
        gameState.currentPattern.push(Math.random() > 0.5);
    }
    gameState.playerPattern = Array(12).fill(false);
}

function updateElectricityPanel() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.lastBreakerTime = Date.now();
            gameState.currentBreaker = 1; // Start showing breaker 1
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    const now = Date.now();
    
    // SHOWING PHASE - Display breakers 1-12 one by one
    if (gameState.displayPhase === 'showing') {
        if (now - gameState.lastBreakerTime >= gameState.breakerDelay) {
            gameState.currentBreaker++;
            gameState.lastBreakerTime = now;
            
            // After showing all 12 breakers, wait 1 second then show progress bar
            if (gameState.currentBreaker > 12) {
                gameState.displayPhase = 'waiting';
                gameState.phaseStartTime = now;
            }
        }
    }
    
    // WAITING PHASE - 1 second after breaker 12 before progress bar
    else if (gameState.displayPhase === 'waiting') {
        if (now - gameState.phaseStartTime >= 1000) {
            gameState.displayPhase = 'checking';
            gameState.checkStartTime = now;
        }
    }
    
    // CHECKING PHASE - 2 second progress bar (player can still toggle)
    else if (gameState.displayPhase === 'checking') {
        const elapsed = now - gameState.checkStartTime;
        
        // After 2 second progress bar completes
        if (elapsed >= gameState.checkDuration) {
            // Check if pattern matches
            let isCorrect = true;
            for (let i = 0; i < 12; i++) {
                if (gameState.playerPattern[i] !== gameState.currentPattern[i]) {
                    isCorrect = false;
                    break;
                }
            }
            
            gameState.checkResult = isCorrect ? 'correct' : 'incorrect';
            gameState.displayPhase = 'result';
            gameState.phaseStartTime = now;
        }
    }
    
    // RESULT PHASE - Show CORRECT or INCORRECT for 1 second
    else if (gameState.displayPhase === 'result') {
        if (now - gameState.phaseStartTime >= 1000) {
            if (gameState.checkResult === 'correct') {
                gameState.correctRounds++;
            } else {
                gameState.correctRounds = 0;
            }
            
            gameState.displayPhase = 'progress';
            gameState.phaseStartTime = now;
        }
    }
    
    // PROGRESS PHASE - Show X/4 for 1 second
    else if (gameState.displayPhase === 'progress') {
        if (now - gameState.phaseStartTime >= 1000) {
            // Check win/lose conditions
            if (gameState.correctRounds >= gameState.totalRounds) {
                // Won at 4/4!
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK COMPLETED', 'All circuits matched!');
                }, 100);
                return;
            } else if (gameState.checkResult === 'incorrect') {
                // Failed on incorrect!
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK FAILED!', 'Circuit mismatch detected');
                }, 100);
                return;
            } else {
                // Continue to next round - regenerate pattern and reset
                generatePattern();
                gameState.displayPhase = 'showing';
                gameState.currentBreaker = 1; // Reset to breaker 1
                gameState.lastBreakerTime = now;
                gameState.checkResult = null;
            }
        }
    }
    
    updateUI();
}

function drawElectricityPanel() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('ELECTRICITY PANEL', currentScene === 'countdown');
        return;
    }
    
    // If game is over, let the endGame function handle the display
    if (gameState.gameOver) {
        return;
    }
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('ELECTRICITY PANEL', 600, 50);
    
    // Draw metal texture panels
    drawMetalPanel(80, 90, 200, 120); // Top left panel
    drawMetalPanel(80, 280, 200, 200); // Bottom left panel
    drawMetalPanel(560, 90, 380, 470); // Right panel 
    
    // LEFT PANELS - Current breaker display
    drawLeftPanel();
    
    // RIGHT PANEL - Player Input
    drawRightPanel();
}



function drawMetalPanel(x, y, width, height) {
    // Base dark metal
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x, y, width, height);
    
    // Add noise texture
    for (let i = 0; i < 200; i++) {
        const noiseX = x + Math.random() * width;
        const noiseY = y + Math.random() * height;
        const brightness = Math.random() * 30;
        ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, 0.3)`;
        ctx.fillRect(noiseX, noiseY, 1, 1);
    }
    
    // Add subtle gradient for depth
    const gradient = ctx.createLinearGradient(x, y, x, y + height);
    gradient.addColorStop(0, 'rgba(50, 50, 50, 0.1)');
    gradient.addColorStop(0.5, 'rgba(0, 0, 0, 0)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0.3)');
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, width, height);
    
    // Outer white border
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.strokeRect(x, y, width, height);
    
    // Inner shadow for depth
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 3, y + 3, width - 6, height - 6);
    
    // Draw rivets at corners
    const rivetPositions = [
        [x + 10, y + 10],
        [x + width - 10, y + 10],
        [x + 10, y + height - 10],
        [x + width - 10, y + height - 10]
    ];
    
    rivetPositions.forEach(([rx, ry]) => {
        // Rivet shadow
        ctx.fillStyle = '#000000';
        ctx.beginPath();
        ctx.arc(rx + 1, ry + 1, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Rivet body
        ctx.fillStyle = '#2a2a2a';
        ctx.beginPath();
        ctx.arc(rx, ry, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Rivet highlight
        ctx.fillStyle = '#444444';
        ctx.beginPath();
        ctx.arc(rx - 1, ry - 1, 2, 0, Math.PI * 2);
        ctx.fill();
    });
}

function drawLeftPanel() {
    const startX = 100;
    const startY = 150;
    
    // Top panel - Pattern display screen
    const screenX = 100;
    const screenY = 120;
    const screenWidth = 160;
    const screenHeight = 60;
    
    // Screen recess
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(screenX, screenY, screenWidth, screenHeight);
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(screenX, screenY, screenWidth, screenHeight);
    
    // Only show CURRENT breaker during showing phase
    if (gameState.displayPhase === 'showing' && gameState.currentBreaker > 0 && gameState.currentBreaker <= 12) {
        const i = gameState.currentBreaker - 1;
        
        // Draw BREAKER text first (on the left)
        ctx.fillStyle = '#8ce023';
        ctx.font = '10px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`BREAKER ${gameState.currentBreaker}`, screenX + 10, screenY + 35);
        
        // Then draw yellow box to the RIGHT of the text
        const boxSize = 30;
        const boxX = screenX + 120; // Position to the right of the text
        const boxY = screenY + 15;
        
        // Inner fill (yellow if ON, empty if OFF)
        if (gameState.currentPattern[i]) {
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(boxX + 4, boxY + 4, boxSize - 8, boxSize - 8);
        }
        
        // Add glow effect for the box
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#ffd700';
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 4;
        ctx.strokeRect(boxX, boxY, boxSize, boxSize);
        ctx.shadowBlur = 0;
        
    } else if (gameState.displayPhase === 'waiting') {
        ctx.fillStyle = '#ffffff';
        ctx.font = '8px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PATTERN COMPLETE', screenX + screenWidth/2, screenY + 35);
    }
    
    
    // Bottom panel - Warning triangle and status
    const triX = 180;
    const triY = 340;
    const triSize = 50;
    
    // Triangle background (darker recess)
    ctx.fillStyle = '#0a0a0a';
    ctx.beginPath();
    ctx.moveTo(triX, triY - triSize/2);
    ctx.lineTo(triX - triSize/2, triY + triSize/2);
    ctx.lineTo(triX + triSize/2, triY + triSize/2);
    ctx.closePath();
    ctx.fill();
    
    // Triangle glow
    ctx.shadowBlur = 25;
    ctx.shadowColor = '#ffd700';
    
    // Triangle border
    ctx.strokeStyle = '#ffd700';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(triX, triY - triSize/2);
    ctx.lineTo(triX - triSize/2, triY + triSize/2);
    ctx.lineTo(triX + triSize/2, triY + triSize/2);
    ctx.closePath();
    ctx.stroke();
    
    ctx.shadowBlur = 0;
    
    // Exclamation mark
    ctx.fillStyle = '#ffd700';
    ctx.fillRect(triX - 3, triY - 12, 6, 18);
    ctx.fillRect(triX - 3, triY + 12, 6, 6);
    
    // Status display
    const displayY = 420;
    
    if (gameState.displayPhase === 'checking') {
        const barWidth = 160;
        const barHeight = 20;
        const barX = 100;
        const barY = displayY;
        
        const elapsed = Date.now() - gameState.checkStartTime;
        const progress = Math.min(elapsed / gameState.checkDuration, 1);
        
        // Progress bar background
        ctx.fillStyle = '#0a0a0a';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Progress fill
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(barX, barY, barWidth * progress, barHeight);
        
        // Progress bar border
        ctx.strokeStyle = '#ffd700';
        ctx.lineWidth = 2;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        
        // Label
        ctx.fillStyle = '#ffffff';
        ctx.font = '7px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('VERIFYING CIRCUIT', 180, barY + 35);
    } else if (gameState.displayPhase === 'result') {
        ctx.fillStyle = gameState.checkResult === 'correct' ? '#8ce023' : '#ff0000';
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        
        // Glow for result
        ctx.shadowBlur = 20;
        ctx.shadowColor = ctx.fillStyle;
        ctx.fillText(gameState.checkResult === 'correct' ? 'CORRECT' : 'INCORRECT', 180, displayY + 15);
        ctx.shadowBlur = 0;
    } else if (gameState.displayPhase === 'progress') {
        ctx.fillStyle = '#666666';
        ctx.font = '10px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('PROGRESS', 180, displayY);
        
        // Set color based on result and progress
        let progressColor = '#ffffff'; // Default white for correct but not complete
        let shadowColor = '#ffffff';
        
        if (gameState.checkResult === 'incorrect') {
            progressColor = '#ff0000'; // Red when incorrect
            shadowColor = '#ff0000';
        } else if (gameState.correctRounds >= gameState.totalRounds) {
            progressColor = '#8ce023'; // Green when completed (4/4)
            shadowColor = '#8ce023';
        }
        
        ctx.fillStyle = progressColor;
        ctx.font = '30px "Press Start 2P", monospace';
        ctx.shadowBlur = 20;
        ctx.shadowColor = shadowColor;
        ctx.fillText(`${gameState.correctRounds}/4`, 180, displayY + 40);
        ctx.shadowBlur = 0;
    }
}

function drawRightPanel() {
    const startX = 600;
    const startY = 103;
    const cols = 3;
    const rows = 4;
    const breakerWidth = 80;
    const breakerHeight = 100;
    const spacingX = 105;
    const spacingY = 115;
          
    // Draw 12 breakers in 3x4 grid
    for (let i = 0; i < 12; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = startX + col * spacingX;
        const y = startY + row * spacingY;
        
        drawBreaker(x, y, breakerWidth, breakerHeight, i, gameState.playerPattern[i]);
    }
}

function drawBreaker(x, y, width, height, index, isOn) {
    // Breaker housing recess
    ctx.fillStyle = '#0a0a0a';
    ctx.fillRect(x, y, width, height);
    
    // Housing border
    ctx.strokeStyle = '#333333';
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, width, height);
    
    // Inner panel
    ctx.fillStyle = '#1a1a1a';
    ctx.fillRect(x + 5, y + 5, width - 10, height - 10);
    
    // Number label at top
    ctx.fillStyle = '#666666';
    ctx.font = '8px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`${index + 1}`, x + width/2, y + 15);
    
    // Status light
    const lightRadius = 10;
    const lightX = x + width/2;
    const lightY = y + 40;
    
    // Light recess
    ctx.fillStyle = '#000000';
    ctx.beginPath();
    ctx.arc(lightX, lightY, lightRadius + 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Light glow
    if (isOn) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#8ce023';
    } else {
        ctx.shadowBlur = 10;
        ctx.shadowColor = '#ff0000';
    }
    
    // Light
    ctx.fillStyle = isOn ? '#8ce023' : '#ff0000';
    ctx.beginPath();
    ctx.arc(lightX, lightY, lightRadius, 0, Math.PI * 2);
    ctx.fill();
    
    // Light highlight
    ctx.shadowBlur = 0;
    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.beginPath();
    ctx.arc(lightX - 3, lightY - 3, 4, 0, Math.PI * 2);
    ctx.fill();
    
    // Switch housing
    const switchY = y + 65;
    const switchWidth = 35;
    const switchHeight = 25;
    const switchX = x + width/2 - switchWidth/2;
    
    // Switch recess
    ctx.fillStyle = '#000000';
    ctx.fillRect(switchX, switchY, switchWidth, switchHeight);
    
    // Switch border
    ctx.strokeStyle = '#222222';
    ctx.lineWidth = 2;
    ctx.strokeRect(switchX, switchY, switchWidth, switchHeight);
    
    // Switch handle
    const handleHeight = 8;
    const handleY = isOn ? switchY + 3 : switchY + switchHeight - handleHeight - 3;
    
    ctx.fillStyle = isOn ? '#8ce023' : '#555555';
    ctx.fillRect(switchX + 4, handleY, switchWidth - 8, handleHeight);
    
    // Handle highlight
    ctx.fillStyle = isOn ? 'rgba(255, 255, 255, 0.2)' : 'rgba(255, 255, 255, 0.1)';
    ctx.fillRect(switchX + 4, handleY, switchWidth - 8, 2);
}

function handleElectricityPanelClick(x, y) {
    if (currentScene !== 'playing') return;
    
    // Can click during showing, waiting, and checking phases
    if (gameState.displayPhase !== 'showing' && 
        gameState.displayPhase !== 'waiting' && 
        gameState.displayPhase !== 'checking') return;
    
    // Right panel coordinates - CORRECTED
    const startX = 600;  
    const startY = 120;
    const cols = 3;      
    const breakerWidth = 80;
    const breakerHeight = 100;
    const spacingX = 105;
    const spacingY = 115;
    
    // Check if clicked on any breaker
    for (let i = 0; i < 12; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const bx = startX + col * spacingX;
        const by = startY + row * spacingY;
        
        if (x >= bx && x <= bx + breakerWidth && y >= by && y <= by + breakerHeight) {
            // Toggle breaker
            gameState.playerPattern[i] = !gameState.playerPattern[i];
            return;
        }
    }
}

// ============= GAME 16: MEMORY SEQUENCE =============
function initMemorySequence() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    // Generate initial random sequence (3 letters)
    const letters = ['X', 'Y', 'Z'];
    const randomSequence = [
        letters[Math.floor(Math.random() * 3)],
        letters[Math.floor(Math.random() * 3)],
        letters[Math.floor(Math.random() * 3)]
    ];
    
    // Generate SEPARATE random visible letter (independent from sequence)
    const randomVisibleLetter = letters[Math.floor(Math.random() * 3)];
    
    gameState = {
        sequence: randomSequence,
        visibleLetter: randomVisibleLetter,  // Completely separate from sequence
        currentQuestion: 0,
        totalQuestions: 10,
        gameWon: false,
        gameOver: false,
        answered: false,
        keys: { left: false, right: false },
        
        // Timer for GET READY countdown (5 seconds)
        countdownTime: 5,
        countdownStart: settings.skipIntros ? Date.now() : null,
        gameStarted: false
    };
    
    console.log('Initial sequence:', gameState.sequence);
    console.log('Initial visible letter (separate):', gameState.visibleLetter);
    
    if (settings.skipIntros) {
        currentScene = 'countdown';
        gameState.countdownStart = Date.now();
    }
    
    updateUI();
}

function updateMemorySequence() {
    if (gameState.gameOver || gameState.gameWon) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - gameState.countdownStart) / 1000;
        const timeLeft = Math.max(0, 5 - elapsed);
        gameState.countdownTime = timeLeft;
        
        if (timeLeft <= 0) {
            currentScene = 'question';
            gameState.gameStarted = true;
        }
        return;
    }
    
    updateUI();
}

function handleAnswer(answer) {
    if (gameState.answered) return;
    
    gameState.answered = true;
    
    console.log('Answer submitted:', answer);
    
    // Compare CURRENT visible letter with SECOND cell of sequence (index 1)
    const secondCell = gameState.sequence[1];
    const visibleCell = gameState.visibleLetter;
    const correctAnswer = (secondCell === visibleCell);
    
    const isCorrect = (answer === 'yes' && correctAnswer) || (answer === 'no' && !correctAnswer);
    
    console.log('Sequence:', gameState.sequence);
    console.log('Second cell (index 1):', secondCell);
    console.log('Visible letter:', visibleCell);
    console.log('Are they the same?', correctAnswer);
    console.log('Player answered:', answer);
    console.log('Is correct:', isCorrect);
    
    if (!isCorrect) {
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED', `Questions: ${gameState.currentQuestion + 1}/${gameState.totalQuestions}`);
        }, 100);
        return;
    }
    
    // Move to next question
    const nextQuestion = gameState.currentQuestion + 1;
    
    if (nextQuestion >= gameState.totalQuestions) {
        gameState.gameWon = true;
        setTimeout(() => {
            endGame('HACK COMPLETED', 'All questions correct!');
        }, 100);
        return;
    }
    
    // CORRECT: Build new sequence BEFORE generating new visible letter
    // New sequence = [2nd from current, 3rd from current, visible from current question]
    const newSequence = [
        gameState.sequence[1],      // Second becomes first
        gameState.sequence[2],      // Third becomes second  
        gameState.visibleLetter     // CURRENT visible letter becomes third
    ];
    
    // NOW generate a new random visible letter for the NEXT question
    const letters = ['X', 'Y', 'Z'];
    const newVisibleLetter = letters[Math.floor(Math.random() * 3)];
    
    gameState.sequence = newSequence;
    gameState.visibleLetter = newVisibleLetter;
    gameState.currentQuestion = nextQuestion;
    gameState.answered = false;
    
    console.log('New sequence:', newSequence);
    console.log('New visible letter for next question:', newVisibleLetter);
}
function drawMemorySequence() {
    if (currentScene === 'intro') {
        drawMemoryIntro();
        return;
    }
    
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Dark blue overlay
    ctx.fillStyle = 'rgba(26, 58, 74, 0.8)';
    ctx.fillRect(0, 0, 1200, 600);
    
    if (currentScene === 'countdown') {
        drawCountdownScene();
    } else if (currentScene === 'question') {
        drawQuestionScene();
    }
}

function drawMemoryIntro() {
    // Black background
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Draw trojanOS background with transparency
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    // Dark blue overlay
    ctx.fillStyle = 'rgba(26, 58, 74, 0.8)';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '32px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('MEMORY SEQUENCE', 600, 250);
    
    // Instructions
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.fillText('Press SPACE to start', 600, 350);
}

function drawCountdownScene() {
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('GET READY', 600, 80);
    
    // Draw three letter boxes
    const boxWidth = 120;
    const boxHeight = 100;
    const spacing = 40;
    const startX = 600 - (boxWidth * 1.5 + spacing);
    const y = 200;
    
    gameState.sequence.forEach((letter, index) => {
        const x = startX + index * (boxWidth + spacing);
        
        // Number label (small, top left)
        ctx.fillStyle = '#8ce023';
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText((index + 1).toString(), x + 10, y - 10);
        
        // Box background
        ctx.fillStyle = '#2a3f4f';
        ctx.fillRect(x, y, boxWidth, boxHeight);
        
        // Box border
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, boxWidth, boxHeight);
        
        // Letter
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(letter, x + boxWidth / 2, y + boxHeight / 2 + 15);
    });
    
    // Countdown timer
    ctx.fillStyle = '#ffffff';
    ctx.font = '24px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(Math.ceil(gameState.countdownTime).toString(), 600, 400);
    
    // Progress bar (depleting left to right)
    const barWidth = 480;
    const barX = 360;
    const barY = 450;
    const progress = (5 - gameState.countdownTime) / 5;
    
    // Bar background
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(barX, barY, barWidth, 20);
    
    // Bar progress
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(barX, barY, barWidth * progress, 20);
    
    // Bar border
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, barY, barWidth, 20);
}

function drawQuestionScene() {
    // Question text
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('Is the value of the visible cell', 600, 50);
    ctx.fillText('the same as the first left cell?', 600, 75);
    ctx.fillText('A/‚Üê = NO | D/‚Üí = YES', 600, 105);
    
    // Draw three boxes
    const boxWidth = 120;
    const boxHeight = 100;
    const spacing = 40;
    const startX = 600 - (boxWidth * 1.5 + spacing);
    const y = 220;
    
    for (let index = 0; index < 3; index++) {
        const x = startX + index * (boxWidth + spacing);
        
        // Number label
        ctx.fillStyle = '#8ce023';
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText((index + 1).toString(), x + 10, y - 10);
        
        if (index < 2) {
            // First two boxes - filled with neon green glow (hidden)
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#8ce023';
            ctx.fillStyle = '#8ce023';
            ctx.fillRect(x, y, boxWidth, boxHeight);
            ctx.shadowBlur = 0;
            
            // Border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, boxWidth, boxHeight);
        } else {
            // Third box - show the SEPARATE visible letter
            ctx.fillStyle = '#2a3f4f';
            ctx.fillRect(x, y, boxWidth, boxHeight);
            
            // Border
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, boxWidth, boxHeight);
            
            // Letter - USE gameState.visibleLetter NOT sequence[2]
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(gameState.visibleLetter, x + boxWidth / 2, y + boxHeight / 2 + 15);
        }
    }
    
    // Question progress
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`Question ${gameState.currentQuestion + 1} / ${gameState.totalQuestions}`, 600, 450);
    
    // Progress bar
    const barWidth = 480;
    const barX = 360;
    const barY = 500;
    const progress = (gameState.currentQuestion + 1) / gameState.totalQuestions;
    
    // Bar background
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(barX, barY, barWidth, 20);
    
    // Bar progress
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(barX, barY, barWidth * progress, 20);
    
    // Bar border
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, barY, barWidth, 20);
}

// ============= GAME 15: UNLOCK GARAGE =============
function initUnlockGarage() {
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    gameState = {
        blocks: [],
        currentRound: 0,
        totalRounds: 4,
        memorizeTime: 10,
        inputTime: 5,
        timeLeft: 10,
        startTime: null,
        phase: 'memorize', // 'memorize' or 'input'
        targetBlock: null,
        userInput: '',
        correctAnswers: 0
    };
    
    generateBlocks();
    
    if (settings.skipIntros) {
        currentScene = 'playing';
        gameState.startTime = Date.now();
    }
    
    updateUI();
}

function generateBlocks() {
    const colors = [
        { name: 'RED', color: '#ff1744', bgColor: 'rgba(255, 23, 68, 0.3)' },
        { name: 'GREEN', color: '#8ce023', bgColor: 'rgba(140, 224, 35, 0.3)' },
        { name: 'CYAN', color: '#00ccff', bgColor: 'rgba(0, 204, 255, 0.3)' },
        { name: 'GREY', color: '#999999', bgColor: 'rgba(153, 153, 153, 0.3)' }
    ];
    
    gameState.blocks = colors.map((color, index) => {
        const typeChoice = Math.random();
        let code = '';
        
        if (typeChoice < 0.33) {
            // All letters
            for (let i = 0; i < 4; i++) {
                code += String.fromCharCode(65 + Math.floor(Math.random() * 26)); // A-Z
            }
        } else if (typeChoice < 0.66) {
            // All numbers
            for (let i = 0; i < 4; i++) {
                code += Math.floor(Math.random() * 10).toString();
            }
        } else {
            // Mixed letters and numbers
            for (let i = 0; i < 4; i++) {
                if (Math.random() < 0.5) {
                    code += String.fromCharCode(65 + Math.floor(Math.random() * 26)); // Letter
                } else {
                    code += Math.floor(Math.random() * 10).toString(); // Number
                }
            }
        }
        
        return {
            ...color,
            code: code,
            x: 300 + (index % 2) * 400,
            y: 100 + Math.floor(index / 2) * 150
        };
    });
}
function updateUnlockGarage() {
    if (gameState.gameOver) return;
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'playing';
            gameState.startTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'playing') return;
    
    // Update timer
    if (gameState.startTime) {
        const elapsedMs = Date.now() - gameState.startTime;
        const elapsedSeconds = elapsedMs / 1000;
        
        if (gameState.phase === 'memorize') {
            gameState.timeLeft = Math.max(0, gameState.memorizeTime - elapsedSeconds);
            
            if (gameState.timeLeft <= 0) {
                // Switch to input phase
                gameState.phase = 'input';
                gameState.startTime = Date.now();
                gameState.timeLeft = gameState.inputTime;
                gameState.userInput = '';
                
                // Pick random block as target
                gameState.targetBlock = gameState.blocks[Math.floor(Math.random() * 4)];
            }
        } else if (gameState.phase === 'input') {
            gameState.timeLeft = Math.max(0, gameState.inputTime - elapsedSeconds);
            
            if (gameState.timeLeft <= 0) {
                // Time's up - fail
                gameState.gameOver = true;
                setTimeout(() => {
                    endGame('HACK FAILED!', `Correct: ${gameState.correctAnswers}/4`);
                }, 100);
            }
        }
    }
    
    updateUI();
}

function drawUnlockGarage() {
    if (currentScene === 'intro' || currentScene === 'countdown') {
        drawBoostingIntro('UNLOCK GARAGE', currentScene === 'countdown');
        return;
    }
    
    // Dark blue gradient background (like in the images)
    const gradient = ctx.createLinearGradient(0, 0, 0, 600);
    gradient.addColorStop(0, '#1a2332');    // Dark blue-grey top
    gradient.addColorStop(0.5, '#1e2a3a');  // Medium dark blue
    gradient.addColorStop(1, '#243342');    // Darker blue bottom
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 1200, 600);
    
    // Title
    ctx.fillStyle = '#ffffff';
    ctx.font = '20px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('UNLOCK GARAGE', 600, 40);
    
    if (gameState.phase === 'memorize') {
        // Draw all 4 blocks
        for (let block of gameState.blocks) {
            // Block background
            ctx.fillStyle = block.bgColor;
            ctx.fillRect(block.x, block.y, 200, 80);
            
            // Block border
            ctx.strokeStyle = block.color;
            ctx.lineWidth = 3;
            ctx.strokeRect(block.x, block.y, 200, 80);
            
            // Block code
            ctx.fillStyle = block.color;
            ctx.font = 'bold 32px "Press Start 2P", monospace';
            ctx.textAlign = 'center';
            ctx.fillText(block.code, block.x + 100, block.y + 55);
        }
        
        // Instruction
        ctx.fillStyle = '#ffffff';
        ctx.font = '14px "Press Start 2P", monospace';
        ctx.fillText('MEMORIZE THE CODES', 600, 400);
        
    } else if (gameState.phase === 'input') {
        // Show target color instruction
        ctx.fillStyle = gameState.targetBlock.color;
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText(`// ${gameState.targetBlock.name} PASSWORD`, 250, 120);
        
        // Show round counter
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'right';
        ctx.fillText(`${gameState.correctAnswers + 1}/4`, 950, 120);
        
        // Draw input box
        const boxX = 250;
        const boxY = 150;
        const boxWidth = 700;
        const boxHeight = 80;
        
        // Box background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
        ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
        
        // Box border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
        
        // User input
        ctx.fillStyle = '#ffffff';
        ctx.font = 'bold 32px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(gameState.userInput, 600, boxY + 55);
        
        // Instruction
        ctx.fillStyle = '#8ce023';
        ctx.font = '12px "Press Start 2P", monospace';
        ctx.fillText('TYPE THE CODE', 600, 350);
    }
    
    // Timer bar (depleting right to left)
    const timerWidth = 700;
    const timerX = 250;
    const timerY = 500;
    const maxTime = gameState.phase === 'memorize' ? gameState.memorizeTime : gameState.inputTime;
    const progress = Math.max(0, gameState.timeLeft / maxTime);
    
    // Timer background
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 10);
    
    // Timer progress (yellow)
    const currentWidth = timerWidth * progress;
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(timerX, timerY, currentWidth, 10);
    
    // Timer border
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 2;
    ctx.strokeRect(timerX, timerY, timerWidth, 10);
}

function handleUnlockGarageKey(key) {
    if (currentScene !== 'playing' || gameState.phase !== 'input') return;
    
    if (key === 'BACKSPACE') {
        gameState.userInput = gameState.userInput.slice(0, -1);
    } else if (key === 'ENTER') {
        if (gameState.userInput.length === 4) {
            checkUnlockGarageAnswer();
        }
    } else if (/^[A-Z0-9]$/.test(key) && gameState.userInput.length < 4) {
        gameState.userInput += key;
    }
}

function checkUnlockGarageAnswer() {
    if (gameState.userInput === gameState.targetBlock.code) {
        // Correct!
        gameState.correctAnswers++;
        
        if (gameState.correctAnswers >= 4) {
            // Win!
            gameState.gameOver = true;
            setTimeout(() => {
                endGame('HACK COMPLETED', 'Garage unlocked!');
            }, 100);
        } else {
            // Next round - generate new blocks
            generateBlocks();
            gameState.phase = 'memorize';
            gameState.startTime = Date.now();
            gameState.timeLeft = gameState.memorizeTime;
            gameState.userInput = '';
        }
    } else {
        // Wrong!
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED!', `Correct: ${gameState.correctAnswers}/4`);
        }, 100);
    }
}

// ============= GAME 17: COLOR MEMORY =============
function initColorMemory() {
    currentScene = settings.skipIntros ? 'memorize' : 'intro';
    
    gameState = {
        circles: [],
        currentRound: 0,
        correctAnswers: 0,
        totalRounds: 5,
        memorizationTime: 5,
        phaseStartTime: null,
        currentQuestion: null,
        selectedAnswer: null,
        answerOptions: [],
        gameOver: false,
        gameWon: false
    };
    
    // Generate circles ONCE for the entire game
    generateCircles();
    
    if (settings.skipIntros) {
        currentScene = 'countdown';
        countdownStart = Date.now();
    }
    
    updateUI();
}

function generateCircles() {
    const colors = [
        { name: 'red', hex: '#ff0000' },
        { name: 'blue', hex: '#00bfff' },
        { name: 'yellow', hex: '#ffff00' },
        { name: 'green', hex: '#00ff00' }
    ];
    
    // Generate random counts for each color (1-8 each, total must be 25)
    let counts = {};
    let remaining = 25;
    
    // Randomly distribute circles
    for (let i = 0; i < colors.length; i++) {
        if (i === colors.length - 1) {
            // Last color gets whatever is left
            counts[colors[i].name] = remaining;
        } else {
            // Random count between 1 and min(8, remaining - (colors.length - i - 1))
            const maxPossible = Math.min(8, remaining - (colors.length - i - 1));
            const minPossible = Math.max(1, remaining - (8 * (colors.length - i - 1)));
            counts[colors[i].name] = Math.floor(Math.random() * (maxPossible - minPossible + 1)) + minPossible;
            remaining -= counts[colors[i].name];
        }
    }
    
    // Create circle objects
    let circles = [];
    colors.forEach(color => {
        for (let i = 0; i < counts[color.name]; i++) {
            circles.push({ color: color.name, hex: color.hex });
        }
    });
    
    // Shuffle circles
    for (let i = circles.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [circles[i], circles[j]] = [circles[j], circles[i]];
    }
    
    gameState.circles = circles;
    gameState.colorCounts = counts;
    
    // Generate and shuffle positions ONCE
    let allPositions = [];
    for (let row = 0; row < 7; row++) {
        for (let col = 0; col < 10; col++) {
            allPositions.push({ row, col });
        }
    }
    
    // Shuffle positions
    for (let i = allPositions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
    }
    
    gameState.circlePositions = allPositions;
}

function generateQuestion() {
    const colors = ['red', 'blue', 'yellow', 'green'];
    const questionColor = colors[Math.floor(Math.random() * colors.length)];
    
    // Use the color counts from when circles were generated
    const correctAnswer = gameState.colorCounts[questionColor];
    
    // Generate 2 other random wrong answers (1-8, but not the correct answer)
    let wrongAnswers = [];
    while (wrongAnswers.length < 2) {
        const wrong = Math.floor(Math.random() * 8) + 1;
        if (wrong !== correctAnswer && !wrongAnswers.includes(wrong)) {
            wrongAnswers.push(wrong);
        }
    }
    
    // Shuffle answers
    let allAnswers = [correctAnswer, ...wrongAnswers];
    for (let i = allAnswers.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [allAnswers[i], allAnswers[j]] = [allAnswers[j], allAnswers[i]];
    }
    
    gameState.currentQuestion = {
        color: questionColor,
        correctAnswer: correctAnswer,
        options: allAnswers
    };
    gameState.selectedAnswer = null;
// DEBUG: Show correct answer in console
    console.log('=== COLOR MEMORY DEBUG ===');
    console.log('Question: How many', questionColor, 'circles?');
    console.log('Correct answer:', correctAnswer);
    console.log('All options:', allAnswers);
    console.log('Color counts:', gameState.colorCounts);
    console.log('======================');
}

function updateColorMemory() {
    if (gameState.gameOver || gameState.gameWon) {
        // Don't update if game is over
        return;
    }
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'memorize';
            gameState.phaseStartTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'memorize' && currentScene !== 'question') return;
    
    if (currentScene === 'memorize') {
        // Update memorization timer
        const elapsedMs = Date.now() - gameState.phaseStartTime;
        const elapsedSeconds = elapsedMs / 1000;
        const timeLeft = Math.max(0, gameState.memorizationTime - elapsedSeconds);
        
        if (timeLeft <= 0) {
            // Switch to question phase
            currentScene = 'question';
            generateQuestion();
            gameState.phaseStartTime = Date.now();
        }
    } else if (currentScene === 'question') {
        // Update question timer
        const elapsedMs = Date.now() - gameState.phaseStartTime;
        const elapsedSeconds = elapsedMs / 1000;
        const timeLeft = Math.max(0, 5 - elapsedSeconds);
        
        if (timeLeft <= 0 && gameState.selectedAnswer === null) {
            // Time ran out without answering - fail with standard end game
gameState.gameOver = true;
            endGame('HACK FAILED', `Time's up! Correct answers: ${gameState.correctAnswers}/${gameState.totalRounds}`);
            return;
        }
    }
    
    updateUI();
}

function handleColorMemoryClick(x, y) {
    // Handle success/failed screen clicks
    if ((currentScene === 'success' || currentScene === 'failed') && currentGame === 'color-memory') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            restartGame();
        }
        return;
    }
    
    // Handle intro screen click (DISABLE_SECURITY button)
    if (currentScene === 'intro') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            currentScene = 'countdown';
            countdownStart = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'question') return;
    
    const gameAreaX = (1200 - 600) / 2;
    const gameAreaY = (600 - 400) / 2;
    
    // Check answer option clicks
    const optionY = gameAreaY + 200;
    const optionSpacing = 150;
    const startX = gameAreaX + 360 - (optionSpacing * 1.5);
    
    for (let i = 0; i < 3; i++) {
        const optionX = startX + i * optionSpacing;
        if (x >= optionX - 40 && x <= optionX + 40 &&
            y >= optionY - 30 && y <= optionY + 30) {
            gameState.selectedAnswer = gameState.currentQuestion.options[i];
            return;
        }
    }
    
    // Check confirm button click
    const confirmY = gameAreaY + 280;
    if (gameState.selectedAnswer !== null &&
        x >= gameAreaX + 300 - 80 && x <= gameAreaX + 300 + 80 &&
        y >= confirmY - 25 && y <= confirmY + 25) {
        handleConfirm();
    }
}


function handleConfirm() {
    if (gameState.selectedAnswer === null) return;
    
    const correct = gameState.selectedAnswer === gameState.currentQuestion.correctAnswer;
    
    if (correct) {
        gameState.correctAnswers++;
        gameState.currentRound++;
        
        console.log('Correct! Progress:', gameState.correctAnswers, '/', gameState.totalRounds);
        
        if (gameState.correctAnswers >= gameState.totalRounds) {
            // Won! - Use standard end game
            endGame('HACK COMPLETED', 'Memory pattern matched!');
            return;
        } else {
            // Next round
            console.log('Next round starting...');
            currentScene = 'memorize';
            gameState.phaseStartTime = Date.now();
        }
    } else {
        // Failed - Use standard end game
        endGame('HACK FAILED', `Correct answers: ${gameState.correctAnswers}/${gameState.totalRounds}`);
        return;
    }
    
    updateUI();
}

function drawColorMemory() {
    // Success screen
    if (currentScene === 'success') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//SUCCESS', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Failed screen  
    if (currentScene === 'failed') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//FAILED', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Intro screen (JEWEL HEIST with DISABLE_SECURITY)
    if (currentScene === 'intro') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('DISABLE_SECURITY', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Countdown screen (green squared texture like Hanoi)
    if (currentScene === 'countdown') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.strokeStyle = '#00ff0030';
        ctx.lineWidth = 1;
        for (let x = 0; x < 1200; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, 600);
            ctx.stroke();
        }
        for (let y = 0; y < 600; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(1200, y);
            ctx.stroke();
        }
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GET READY', 600, 280);
        
        const elapsed = (Date.now() - countdownStart) / 1000;
        const progress = Math.max(0, 1 - (elapsed / 5));
        
        const barWidth = 800;
        const barX = 200;
        const barY = 350;
        
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(barX, barY, barWidth, 25);
        
        const currentWidth = barWidth * progress;
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, currentWidth, 25);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(barX, barY, barWidth, 25);
        
        return;
    }
    
    // Lime green background for gameplay
    ctx.fillStyle = '#272710';
    ctx.fillRect(0, 0, 1200, 600);
    
    const gameAreaX = (1200 - 600) / 2;
    const gameAreaY = (600 - 400) / 2;
    
    if (currentScene === 'memorize') {
        drawMemorizePhase(gameAreaX, gameAreaY);
    } else if (currentScene === 'question') {
        drawQuestionPhase(gameAreaX, gameAreaY);
    }
}
function drawMemorizePhase(gameAreaX, gameAreaY) {
       
    // Title
    ctx.fillStyle = '#ffff00';
    ctx.font = 'bold 18px "Montserrat", Arial';
    ctx.textAlign = 'center';
    ctx.fillText('REMEMBER', 600, gameAreaY - 20);
    
const circleRadius = 20;
const gridStartX = gameAreaX + 50;
const gridStartY = gameAreaY + 40;
const spacingX = 50;
const spacingY = 48;

const allPositions = gameState.circlePositions;

// Draw all 70 circles (first 25 are colored, rest are empty)
for (let i = 0; i < allPositions.length; i++) {
    const pos = allPositions[i];
    const x = gridStartX + pos.col * spacingX;
    const y = gridStartY + pos.row * spacingY;
    
    if (i < gameState.circles.length) {
        // Colored circle
        const circle = gameState.circles[i];
        ctx.fillStyle = circle.hex;
        ctx.beginPath();
        ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
        ctx.fill();
    } else {
        // Empty circle with white outline and transparent fill
        ctx.fillStyle = 'rgba(80, 89, 42, 0.5)';
        ctx.beginPath();
        ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, circleRadius, 0, Math.PI * 2);
        ctx.stroke();
    }
    }
    
    // Progress counter at bottom
    ctx.fillStyle = '#ffff00';
    ctx.font = 'bold 18px "Montserrat", Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`${gameState.correctAnswers} / 5`, 600, gameAreaY + 450);
    
    // Timer bar
    const elapsedMs = Date.now() - gameState.phaseStartTime;
    const elapsedSeconds = elapsedMs / 1000;
    const timeLeft = Math.max(0, gameState.memorizationTime - elapsedSeconds);
    const progress = timeLeft / gameState.memorizationTime;
    
    const timerWidth = 600;
    const timerX = gameAreaX;
    const timerY = gameAreaY + 470;
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 5);
    
    const currentWidth = timerWidth * progress;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(timerX, timerY, currentWidth, 5);
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1;
    ctx.strokeRect(timerX, timerY, timerWidth, 5);
}

function drawQuestionPhase(gameAreaX, gameAreaY) {
   
// Question text - combined into one line
ctx.fillStyle = '#ffff00';
ctx.font = 'bold 18px "Montserrat", Arial';
ctx.textAlign = 'center';

const questionText = `HOW MANY ${gameState.currentQuestion.color.toUpperCase()}`;
ctx.fillText(questionText, 600, gameAreaY + 80);
    
    ctx.fillStyle = '#ffff00';
    ctx.fillText('TILES WERE THERE?', 600, gameAreaY + 110);
    
    // Answer options (rounded squares with yellow border)
    const optionY = gameAreaY + 200;
    const optionSpacing = 150;
    const startX = gameAreaX + 360 - (optionSpacing * 1.5);
    
    for (let i = 0; i < 3; i++) {
        const option = gameState.currentQuestion.options[i];
        const x = startX + i * optionSpacing;
        const isSelected = gameState.selectedAnswer === option;
        
        // Rounded square
        ctx.fillStyle = isSelected ? '#ffff00' : 'rgba(0, 0, 0, 0.5)';
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        roundRect(ctx, x - 40, optionY - 30, 80, 60, 10);
        ctx.fill();
        ctx.stroke();
        
        // Number
        ctx.fillStyle = isSelected ? '#000000' : '#ffff00';
        ctx.font = 'bold 24px "Montserrat", Arial';
        ctx.textAlign = 'center';
        ctx.fillText(option.toString(), x, optionY + 10);
    }
    
    // Confirm button
    const confirmY = gameAreaY + 280;
    ctx.fillStyle = gameState.selectedAnswer !== null ? '#ffff00' : 'rgba(100, 100, 100, 0.5)';
    ctx.strokeStyle = '#ffff00';
    ctx.lineWidth = 2;
    roundRect(ctx, gameAreaX + 300 - 80, confirmY - 25, 160, 50, 10);
    ctx.fill();
    ctx.stroke();
    
    ctx.fillStyle = '#000000';
    ctx.font = 'bold 18px "Montserrat", Arial';
    ctx.textAlign = 'center';
    ctx.fillText('CONFIRM', 600, confirmY + 5);
    
    // Progress counter
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 18px "Montserrat", Arial';
    ctx.fillText(`${gameState.correctAnswers} / 5`, 600, gameAreaY + 340);
    
    // Timer bar
    const elapsedMs = Date.now() - gameState.phaseStartTime;
    const elapsedSeconds = elapsedMs / 1000;
    const timeLeft = Math.max(0, 5 - elapsedSeconds);
    const progress = timeLeft / 5;
    
    const timerWidth = 600;
    const timerX = gameAreaX;
    const timerY = gameAreaY + 360;
    
    ctx.fillStyle = '#2a2a2a';
    ctx.fillRect(timerX, timerY, timerWidth, 5);
    
    const currentWidth = timerWidth * progress;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(timerX, timerY, currentWidth, 5);
    
    ctx.strokeStyle = '#000000';
    ctx.lineWidth = 1;
    ctx.strokeRect(timerX, timerY, timerWidth, 5);
}

// ============= GAME 18: MATH COMPARE =============
function initMathCompare() {
    currentScene = settings.skipIntros ? 'question' : 'intro';
    
    gameState = {
        correctAnswers: 0,
        totalRounds: 5,
        totalTime: 20,
        gameStartTime: null,
        currentQuestion: null,
        selectedAnswer: null,
        gameOver: false,
        gameWon: false
    };
    
    if (settings.skipIntros) {
        gameState.gameStartTime = Date.now();
        generateMathQuestion();
    }
}

function generateMathQuestion() {
    let leftResult, rightResult;
    let num1, num2, num3, num4, num5, num6, op1, op2, op3, op4;
    
    // Keep generating until both results are <= 25
    do {
        // Generate random numbers (0-10 for simpler math with 3 numbers)
        num1 = Math.floor(Math.random() * 11);
        num2 = Math.floor(Math.random() * 11);
        num3 = Math.floor(Math.random() * 11);
        num4 = Math.floor(Math.random() * 11);
        num5 = Math.floor(Math.random() * 11);
        num6 = Math.floor(Math.random() * 11);
        
        // Generate operators
        const operators = ['+', '-', '*'];
        op1 = operators[Math.floor(Math.random() * operators.length)];
        op2 = operators[Math.floor(Math.random() * operators.length)];
        op3 = operators[Math.floor(Math.random() * operators.length)];
        op4 = operators[Math.floor(Math.random() * operators.length)];
        
        // Calculate left side: (num1 op1 num2) op2 num3
        let leftPart;
        if (op1 === '+') leftPart = num1 + num2;
        else if (op1 === '-') leftPart = num1 - num2;
        else leftPart = num1 * num2;
        
        if (op2 === '+') leftResult = leftPart + num3;
        else if (op2 === '-') leftResult = leftPart - num3;
        else leftResult = leftPart * num3;
        
        // Calculate right side: (num4 op3 num5) op4 num6
        let rightPart;
        if (op3 === '+') rightPart = num4 + num5;
        else if (op3 === '-') rightPart = num4 - num5;
        else rightPart = num4 * num5;
        
        if (op4 === '+') rightResult = rightPart + num6;
        else if (op4 === '-') rightResult = rightPart - num6;
        else rightResult = rightPart * num6;
        
    } while (leftResult > 25 || leftResult < 0 || rightResult > 25 || rightResult < 0);
    
    // Determine correct answer
    let correctAnswer;
    if (leftResult < rightResult) correctAnswer = '<';
    else if (leftResult === rightResult) correctAnswer = '=';
    else correctAnswer = '>';
    
    gameState.currentQuestion = {
        leftNum1: num1,
        leftNum2: num2,
        leftNum3: num3,
        leftOp1: op1,
        leftOp2: op2,
        rightNum1: num4,
        rightNum2: num5,
        rightNum3: num6,
        rightOp1: op3,
        rightOp2: op4,
        leftResult: leftResult,
        rightResult: rightResult,
        correctAnswer: correctAnswer
    };
    gameState.selectedAnswer = null;
    
    console.log('=== MATH COMPARE DEBUG ===');
    console.log(`Question: (${num1} ${op1} ${num2}) ${op2} ${num3} ? (${num4} ${op3} ${num5}) ${op4} ${num6}`);
    console.log(`Left calculation: (${num1} ${op1} ${num2}) ${op2} ${num3} = ${leftResult}`);
    console.log(`Right calculation: (${num4} ${op3} ${num5}) ${op4} ${num6} = ${rightResult}`);
    console.log(`Correct answer: ${correctAnswer}`);
    console.log('======================');
}

function updateMathCompare() {
    if (gameState.gameOver || gameState.gameWon) {
        return;
    }
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'question';
            gameState.gameStartTime = Date.now();
            generateMathQuestion();
        }
        return;
    }
    
    if (currentScene !== 'question') return;
    
    // Check if total time has elapsed
    const totalElapsedMs = Date.now() - gameState.gameStartTime;
    const totalElapsedSeconds = totalElapsedMs / 1000;
    
    if (totalElapsedSeconds >= gameState.totalTime) {
        // Time's up - fail
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED', `Time's up! Correct answers: ${gameState.correctAnswers}/${gameState.totalRounds}`);
        }, 100);
        return;
    }
    
    updateUI();
}

function handleMathCompareClick(x, y) {
    // Handle success/failed screen clicks
    if ((currentScene === 'success' || currentScene === 'failed') && currentGame === 'math-compare') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            restartGame();
        }
        return;
    }
    
    if (currentScene !== 'question') return;
    
    const gameAreaX = (1200 - 600) / 2;
    const gameAreaY = (600 - 400) / 2;
    
    // Check answer option clicks (<, =, >)
    const optionY = gameAreaY + 200;
    const optionSpacing = 150;
    const startX = gameAreaX + 300 - optionSpacing;
    const options = ['<', '=', '>'];
    
    for (let i = 0; i < 3; i++) {
        const optionX = startX + i * optionSpacing;
        if (x >= optionX - 40 && x <= optionX + 40 &&
            y >= optionY - 30 && y <= optionY + 30) {
            handleAnswerSelection(options[i]);
            return;
        }
    }
}

function handleAnswerSelection(answer) {
    console.log('=== ANSWER SELECTION DEBUG ===');
    console.log(`Player selected: ${answer}`);
    console.log(`Correct answer: ${gameState.currentQuestion.correctAnswer}`);
    console.log(`Left result: ${gameState.currentQuestion.leftResult}`);
    console.log(`Right result: ${gameState.currentQuestion.rightResult}`);
    
    const correct = answer === gameState.currentQuestion.correctAnswer;
    console.log(`Is correct? ${correct}`);
    console.log('============================');
    
    if (correct) {
        gameState.correctAnswers++;
        
        console.log('‚úì CORRECT! Progress:', gameState.correctAnswers, '/', gameState.totalRounds);
        
        if (gameState.correctAnswers >= gameState.totalRounds) {
            // Won! - force update UI to show 5/5 before winning
            gameState.gameWon = true;
            updateUI();
            setTimeout(() => {
                endGame('HACK COMPLETED', 'All equations solved!');
            }, 500);
            return;
        } else {
            // Next question
            console.log('‚Üí Generating next question...');
            generateMathQuestion();
        }
    } else {
        // Failed
        console.log('‚úó INCORRECT - Game Over');
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED', `Correct answers: ${gameState.correctAnswers}/${gameState.totalRounds}`);
        }, 100);
        return;
    }
    
    updateUI();
}

function drawMathCompare() {
    // Success screen
    if (currentScene === 'success') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//SUCCESS', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Failed screen  
    if (currentScene === 'failed') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//FAILED', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Intro screen (JEWEL HEIST with OPEN GATE A)
    if (currentScene === 'intro') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('OPEN GATE A', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Countdown screen (green squared texture)
    if (currentScene === 'countdown') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.strokeStyle = '#00ff0030';
        ctx.lineWidth = 1;
        for (let x = 0; x < 1200; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, 600);
            ctx.stroke();
        }
        for (let y = 0; y < 600; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(1200, y);
            ctx.stroke();
        }
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GET READY', 600, 280);
        
        const elapsed = (Date.now() - countdownStart) / 1000;
        const progress = Math.max(0, 1 - (elapsed / 5));
        
        const barWidth = 800;
        const barX = 200;
        const barY = 350;
        
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(barX, barY, barWidth, 25);
        
        const currentWidth = barWidth * progress;
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, currentWidth, 25);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(barX, barY, barWidth, 25);
        
        return;
    }
    
    // Gameplay screen
    ctx.fillStyle = '#35330f';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Matrix rain effect background
    ctx.strokeStyle = '#00ff0030';
    ctx.lineWidth = 1;
    for (let x = 0; x < 1200; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 600);
        ctx.stroke();
    }
    for (let y = 0; y < 600; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(1200, y);
        ctx.stroke();
    }
    
    if (currentScene === 'question') {
        drawMathQuestion();
    }
}

function drawMathQuestion() {
    const q = gameState.currentQuestion;
    
    // Top instruction with progress counter
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText(`PICK THE CORRECT SIGN (${gameState.correctAnswers}/5)`, 600, 120);
    
    // ===== FIRST EQUATION BOX =====
    const boxY = 180;
    const boxX = 350;
    const boxWidth = 450;
    const boxHeight = 80;

    // Black transparent background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);

    // Gradient border (white to green) - WITHOUT LEFT SIDE
    const borderGradient = ctx.createLinearGradient(boxX, boxY, boxX + boxWidth, boxY);
    borderGradient.addColorStop(0, '#ffffff');
    borderGradient.addColorStop(1, '#00ff00');
    ctx.strokeStyle = borderGradient;
    ctx.lineWidth = 3;

    // Draw top border
    ctx.beginPath();
    ctx.moveTo(boxX, boxY);
    ctx.lineTo(boxX + boxWidth, boxY);
    ctx.stroke();

    // Draw right border
    ctx.beginPath();
    ctx.moveTo(boxX + boxWidth, boxY);
    ctx.lineTo(boxX + boxWidth, boxY + boxHeight);
    ctx.stroke();

    // Draw bottom border
    ctx.beginPath();
    ctx.moveTo(boxX + boxWidth, boxY + boxHeight);
    ctx.lineTo(boxX, boxY + boxHeight);
    ctx.stroke();

    // Draw equation: ( num op num ) op num
    ctx.font = '30px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';
    
    const equationY = boxY + 52;
    let xPos = boxX + 60;
    
    function getNumberSpacing(number) {
        const digitCount = number.toString().length;
        return digitCount === 1 ? 45 : 60; // More spacing for 2-digit numbers
    }
    
    function getParenthesisSpacing(number) {
        const digitCount = number.toString().length;
        return digitCount === 1 ? 45 : 60; // More spacing before 2-digit numbers
    }
    
    // (
    ctx.fillText('(', xPos, equationY);
    xPos += getParenthesisSpacing(q.leftNum1); // Dynamic spacing after (
    
    // num1
    ctx.fillText(q.leftNum1, xPos, equationY);
    xPos += getNumberSpacing(q.leftNum1); // Dynamic spacing after number
    
    // op1 (no box)
    ctx.fillText(q.leftOp1, xPos, equationY);
    xPos += 70; // 3px spacing after operator
    
    // num2
    ctx.fillText(q.leftNum2, xPos, equationY);
    xPos += getNumberSpacing(q.leftNum2); // Dynamic spacing before )
    
    // )
    ctx.fillText(')', xPos, equationY);
    xPos += getParenthesisSpacing(q.leftNum3); // Dynamic spacing after )
    
    // op2 (no box)
    ctx.fillText(q.leftOp2, xPos, equationY);
    xPos += 70; // 3px spacing after operator
    
    // num3
    ctx.fillText(q.leftNum3, xPos, equationY);
    
    // Vertical gradient lines to the RIGHT of first equation box
    const lines1X = boxX + boxWidth + 10;
    const lineHeights = [70, 55, 65, 50, 60, 45, 55, 40];
    let lineX = lines1X;
    
    for (let i = 0; i < lineHeights.length; i++) {
        const lineHeight = lineHeights[i];
        const lineY = boxY + (boxHeight - lineHeight) / 2;
        
        const lineGradient = ctx.createLinearGradient(lineX, lineY, lineX, lineY + lineHeight);
        lineGradient.addColorStop(0, '#ffffff');
        lineGradient.addColorStop(1, '#00ff00');
        ctx.strokeStyle = lineGradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(lineX, lineY);
        ctx.lineTo(lineX, lineY + lineHeight);
        ctx.stroke();
        
        lineX += 5;
    }
    
    // ===== ANSWER OPTION BUTTONS =====
    const optionsY = 320;
    const optionSpacing = 150;
    const startX = 450;
    const options = ['<', '=', '>'];
    
    for (let i = 0; i < 3; i++) {
        const x = startX + i * optionSpacing;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        roundRect(ctx, x - 40, optionsY - 30, 80, 60, 5);
        ctx.fill();
        
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        roundRect(ctx, x - 40, optionsY - 30, 80, 60, 5);
        ctx.stroke();
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '32px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText(options[i], x, optionsY + 10);
    }
    
    // ===== SECOND EQUATION BOX =====
    const box2Y = 400;
    
    // Vertical gradient lines to the LEFT of second equation box
    const lines2X = boxX - 50;
    lineX = lines2X;
    
    for (let i = 0; i < lineHeights.length; i++) {
        const lineHeight = lineHeights[i];
        const lineY = box2Y + (boxHeight - lineHeight) / 2;
        
        const lineGradient = ctx.createLinearGradient(lineX, lineY, lineX, lineY + lineHeight);
        lineGradient.addColorStop(0, '#ffffff');
        lineGradient.addColorStop(1, '#00ff00');
        ctx.strokeStyle = lineGradient;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(lineX, lineY);
        ctx.lineTo(lineX, lineY + lineHeight);
        ctx.stroke();
        
        lineX += 5;
    }
    
    // Black transparent background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.fillRect(boxX, box2Y, boxWidth, boxHeight);

    // Gradient border (white to green) - WITHOUT RIGHT SIDE
    const borderGradient2 = ctx.createLinearGradient(boxX, box2Y, boxX + boxWidth, box2Y);
    borderGradient2.addColorStop(0, '#ffffff');
    borderGradient2.addColorStop(1, '#00ff00');
    ctx.strokeStyle = borderGradient2;
    ctx.lineWidth = 3;

    // Draw top border
    ctx.beginPath();
    ctx.moveTo(boxX, box2Y);
    ctx.lineTo(boxX + boxWidth, box2Y);
    ctx.stroke();

    // Draw left border
    ctx.beginPath();
    ctx.moveTo(boxX, box2Y);
    ctx.lineTo(boxX, box2Y + boxHeight);
    ctx.stroke();

    // Draw bottom border
    ctx.beginPath();
    ctx.moveTo(boxX, box2Y + boxHeight);
    ctx.lineTo(boxX + boxWidth, box2Y + boxHeight);
    ctx.stroke();

    // Draw equation 2: ( num op num ) op num
    ctx.font = '30px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ffffff';  

    const equation2Y = box2Y + 52;
    xPos = boxX + 60;
    
    // (
    ctx.fillText('(', xPos, equation2Y);
    xPos += getParenthesisSpacing(q.rightNum1); // Dynamic spacing after (
    
    // num1
    ctx.fillText(q.rightNum1, xPos, equation2Y);
    xPos += getNumberSpacing(q.rightNum1); // Dynamic spacing after number
    
    // op1 (no box)
    ctx.fillText(q.rightOp1, xPos, equation2Y);
    xPos += 70; // 3px spacing after operator
    
    // num2
    ctx.fillText(q.rightNum2, xPos, equation2Y);
    xPos += getNumberSpacing(q.rightNum2); // Dynamic spacing before )
    
    // )
    ctx.fillText(')', xPos, equation2Y);
    xPos += getParenthesisSpacing(q.rightNum3); // Dynamic spacing after )
    
    // op2 (no box)
    ctx.fillText(q.rightOp2, xPos, equation2Y);
    xPos += 70; // 3px spacing after operator
    
    // num3
    ctx.fillText(q.rightNum3, xPos, equation2Y);
    
    // ===== TIME LEFT PROGRESS BAR =====
    const totalElapsedMs = Date.now() - gameState.gameStartTime;
    const totalElapsedSeconds = totalElapsedMs / 1000;
    const timeLeft = Math.max(0, gameState.totalTime - totalElapsedSeconds);
    const progress = timeLeft / gameState.totalTime;
    
    // Time left text
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('// TIME LEFT', 100, 550);
    
    // Progress bar (depleting from right to left)
    const barX = 280;
    const barY = 535;
    const barWidth = 800;
    const barHeight = 20;
    
    // Background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    // White progress bar (depleting)
    const currentWidth = barWidth * progress;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(barX, barY, currentWidth, barHeight);
}
// ============= GAME 19: LOCK PICKING =============
function initLockPicking() {
    currentScene = settings.skipIntros ? 'question' : 'intro';
    
    // Generate random sequence of P and Q (8 steps)
    const sequence = [];
    for (let i = 0; i < 8; i++) {
        sequence.push(Math.random() < 0.5 ? 'P' : 'Q');
    }
    
    gameState = {
        sequence: sequence,
        currentStep: 0,
        totalTime: 15,
        gameStartTime: null,
        gameOver: false,
        gameWon: false,
        wrongBlocks: [] // Track wrong attempts: [{step: 0, side: 'left'}, ...]
    };
    
    console.log('=== LOCK PICKING DEBUG ===');
    console.log('Correct sequence:', sequence.join(' -> '));
    console.log('========================');
    
    if (settings.skipIntros) {
        gameState.gameStartTime = Date.now();
    }
}

function updateLockPicking() {
    if (gameState.gameOver || gameState.gameWon) {
        return;
    }
    
    if (currentScene === 'countdown') {
        const elapsed = (Date.now() - countdownStart) / 1000;
        if (elapsed >= 5) {
            currentScene = 'question';
            gameState.gameStartTime = Date.now();
        }
        return;
    }
    
    if (currentScene !== 'question') return;
    
    // Check if total time has elapsed
    const totalElapsedMs = Date.now() - gameState.gameStartTime;
    const totalElapsedSeconds = totalElapsedMs / 1000;
    
    if (totalElapsedSeconds >= gameState.totalTime) {
        // Time's up - fail
        gameState.gameOver = true;
        setTimeout(() => {
            endGame('HACK FAILED', 'Time\'s up!');
        }, 100);
        return;
    }
    
    updateUI();
}

function handleLockPickingClick(x, y) {
    // Handle success/failed screen clicks
    if ((currentScene === 'success' || currentScene === 'failed') && currentGame === 'lock-picking') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            restartGame();
        }
        return;
    }
}

function handleLockPickingKeyPress(key) {
    if (currentScene !== 'question') return;
    if (gameState.gameOver || gameState.gameWon) return;
    
    const upperKey = key.toUpperCase();
    if (upperKey !== 'P' && upperKey !== 'Q') return;
    
    console.log('=== KEY PRESS DEBUG ===');
    console.log(`Key pressed: ${upperKey}`);
    console.log(`Current step: ${gameState.currentStep}`);
    console.log(`Expected: ${gameState.sequence[gameState.currentStep]}`);
    
    if (upperKey === gameState.sequence[gameState.currentStep]) {
        // Correct key!
        gameState.currentStep++;
        console.log('‚úì CORRECT! Moving to step', gameState.currentStep);
        
        if (gameState.currentStep >= gameState.sequence.length) {
            // Won!
            console.log('üéâ SEQUENCE COMPLETE - YOU WIN!');
            gameState.gameWon = true;
            setTimeout(() => {
                endGame('HACK COMPLETED', 'Lock picked!');
            }, 500);
        }
    } else {
        // Wrong key - mark this block as wrong and RESET to step 1
        console.log('‚úó WRONG! Resetting to step 0');
        const wrongSide = upperKey === 'P' ? 'right' : 'left';
        gameState.wrongBlocks.push({
            step: gameState.currentStep,
            side: wrongSide
        });
        gameState.currentStep = 0; // Reset to block 1
    }
    console.log('=====================');
    
    updateUI();
}

function drawLockPicking() {
    // Success screen
    if (currentScene === 'success') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//SUCCESS', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Failed screen  
    if (currentScene === 'failed') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('//FAILED', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Intro screen
    if (currentScene === 'intro') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('JEWEL __HEIST__', 30, 50);
        
        ctx.textAlign = 'right';
        ctx.fillText('1.127322_SF_FIFARAFA', 1170, 50);
        
        const buttonX = 60;
        const buttonY = 230;
        
        ctx.fillStyle = '#00ff00';
        ctx.beginPath();
        ctx.arc(buttonX, buttonY, 20, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = '#00ff00';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'left';
        ctx.fillText('OPEN GATE B', buttonX + 40, buttonY + 8);
        
        return;
    }
    
    // Countdown screen
    if (currentScene === 'countdown') {
        ctx.fillStyle = '#35330f';
        ctx.fillRect(0, 0, 1200, 600);
        
        ctx.strokeStyle = '#00ff0030';
        ctx.lineWidth = 1;
        for (let x = 0; x < 1200; x += 20) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, 600);
            ctx.stroke();
        }
        for (let y = 0; y < 600; y += 20) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(1200, y);
            ctx.stroke();
        }
        
        ctx.fillStyle = '#ffffff';
        ctx.font = '20px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GET READY', 600, 280);
        
        const elapsed = (Date.now() - countdownStart) / 1000;
        const progress = Math.max(0, 1 - (elapsed / 5));
        
        const barWidth = 800;
        const barX = 200;
        const barY = 350;
        
        ctx.fillStyle = '#2a2a2a';
        ctx.fillRect(barX, barY, barWidth, 25);
        
        const currentWidth = barWidth * progress;
        ctx.fillStyle = '#00ff00';
        ctx.fillRect(barX, barY, currentWidth, 25);
        
        ctx.strokeStyle = '#00ff00';
        ctx.lineWidth = 3;
        ctx.strokeRect(barX, barY, barWidth, 25);
        
        return;
    }
    
    // Gameplay screen
    ctx.fillStyle = '#35330f';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Matrix rain effect background
    ctx.strokeStyle = '#00ff0030';
    ctx.lineWidth = 1;
    for (let x = 0; x < 1200; x += 20) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, 600);
        ctx.stroke();
    }
    for (let y = 0; y < 600; y += 20) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(1200, y);
        ctx.stroke();
    }
    
    if (currentScene === 'question') {
        drawLockPickingGame();
    }
}

function drawLockPickingGame() {
    // Top instruction - only one line
    ctx.fillStyle = '#ffffff';
    ctx.font = '16px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('FIND THE CORRECT BLOCK', 600, 80);
    
    // Draw P and Q labels - moved up
    ctx.fillStyle = '#ffffff';
    ctx.font = '32px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('//Q', 300, 130); // Q = left
    ctx.fillText('//P', 800, 130); // P = right
    
    // Draw the 16 horizontal lines (8 on left for Q, 8 on right for P) - moved up
    const startY = 150;
    const lineHeight = 40;
    const lineSpacing = 5;
    const leftX = 150;
    const rightX = 650;
    const lineWidth = 300;
    
    for (let i = 0; i < 8; i++) {
        const y = startY + i * (lineHeight + lineSpacing);
        const isCurrentStep = i === gameState.currentStep;
        const isPassed = i < gameState.currentStep;
        
        // Check if blocks are marked as wrong
        const isLeftWrong = gameState.wrongBlocks.some(wb => wb.step === i && wb.side === 'left');
        const isRightWrong = gameState.wrongBlocks.some(wb => wb.step === i && wb.side === 'right');
        
        // LEFT BLOCK (Q)
        if (isLeftWrong) {
            // Wrong block - red
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        } else if (isPassed && gameState.sequence[i] === 'Q') {
            // Passed correct block - solid green
            ctx.fillStyle = '#8ce023';
        } else {
            // Unpassed block - transparent green
            ctx.fillStyle = 'rgba(140, 224, 35, 0.2)';
        }
        ctx.fillRect(leftX, y, lineWidth, lineHeight);
        
        // Draw white border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(leftX, y, lineWidth, lineHeight);
        
        // Highlight current step
        if (isCurrentStep) {
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.strokeRect(leftX - 2, y - 2, lineWidth + 4, lineHeight + 4);
        }
        
        // RIGHT BLOCK (P)
        if (isRightWrong) {
            // Wrong block - red
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        } else if (isPassed && gameState.sequence[i] === 'P') {
            // Passed correct block - solid green
            ctx.fillStyle = '#8ce023';
        } else {
            // Unpassed block - transparent green
            ctx.fillStyle = 'rgba(140, 224, 35, 0.2)';
        }
        ctx.fillRect(rightX, y, lineWidth, lineHeight);
        
        // Draw white border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.strokeRect(rightX, y, lineWidth, lineHeight);
        
        // Highlight current step
        if (isCurrentStep) {
            ctx.strokeStyle = '#ffff00';
            ctx.lineWidth = 4;
            ctx.strokeRect(rightX - 2, y - 2, lineWidth + 4, lineHeight + 4);
        }
    }
    
    // Draw the finish line - smaller height
    const finishY = startY + 8 * (lineHeight + lineSpacing);
    ctx.fillStyle = '#8ce023';
    ctx.fillRect(150, finishY, 800, 20); // Smaller height (20px instead of lineHeight)
    

    
    // ===== TIME LEFT PROGRESS BAR =====
    const totalElapsedMs = Date.now() - gameState.gameStartTime;
    const totalElapsedSeconds = totalElapsedMs / 1000;
    const timeLeft = Math.max(0, gameState.totalTime - totalElapsedSeconds);
    const progress = timeLeft / gameState.totalTime;
    
    // Time left text
    ctx.fillStyle = '#ffffff';
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.textAlign = 'left';
    ctx.fillText('// TIME LEFT', 100, 565);
    
    // Progress bar (depleting from right to left)
    const barX = 280;
    const barY = 550;
    const barWidth = 800;
    const barHeight = 20;
    
    // Background
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    // White progress bar (depleting)
    const currentWidth = barWidth * progress;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(barX, barY, currentWidth, barHeight);
    
    // Border
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 2;
    ctx.strokeRect(barX, barY, barWidth, barHeight);
}
   // ============= UI MANAGEMENT =============
function updateUI() {
    gameUI.innerHTML = '';
    const livesDisplay = document.getElementById('lives-display');
    
    if (currentGame === 'breakout') {
        // Lives display only
        if (spritesLoaded && sprites.earth.complete) {
            let earthsHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                earthsHTML += `<img src="assets/earth.png" style="width: 35px; height: 35px;">`;
            }
            livesDisplay.innerHTML = earthsHTML;
        } else {
            livesDisplay.innerHTML = '<span style="color: #00ff00;">' + 'üåç '.repeat(gameState.lives).trim() + '</span>';
        }
    } else if (currentGame === 'asteroids') {
        // Ammo display
        const ammoElement = document.createElement('div');
        ammoElement.className = 'ui-element';
        ammoElement.innerHTML = `<span style="color: white;">AMMO:</span> <span style="color: #00ff00;">${gameState.ammo}</span>`;
        gameUI.appendChild(ammoElement);
        
        // Lives display
        if (spritesLoaded && sprites.heart.complete) {
            let heartsHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                heartsHTML += `<img src="assets/life.png" style="width: 50px; height: 40px;">`;
            }
            livesDisplay.innerHTML = heartsHTML;
        } else {
            livesDisplay.innerHTML = '<span style="color: #ff0000;">' + 'X '.repeat(gameState.lives).trim() + '</span>';
        }
    } else {
        livesDisplay.innerHTML = '';
    }
}
function showOsuModeSelection() {
    menu.style.display = 'none';
    gameScreen.style.display = 'flex';
    currentGame = 'osu-selection';
    
    // Initialize gameState for mode selection
    gameState = { modeButtons: [] };
    
    drawOsuModeSelection();
}

function drawOsuModeSelection() {
    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, 1200, 600);
    
    ctx.globalAlpha = 0.3;
    if (backgrounds.trojanOS.complete) {
        ctx.drawImage(backgrounds.trojanOS, 0, 0, 1200, 600);
    }
    ctx.globalAlpha = 1.0;
    
    ctx.fillStyle = '#ffffff';
    ctx.font = '24px "Press Start 2P", monospace';
    ctx.textAlign = 'center';
    ctx.fillText('SELECT DIFFICULTY', 600, 80);
    
    const modes = [
        { id: 'osu-cars-cb', name: 'CARS (C-B CLASS)', y: 160 },
        { id: 'osu-cars-a', name: 'CARS (A CLASS)', y: 220 },
        { id: 'osu-cars-s', name: 'CARS (S CLASS)', y: 280 },
        { id: 'osu-helicopter', name: 'HELICOPTER', y: 340 },
        { id: 'osu-house', name: 'HOUSE', y: 400 }
    ];
    
    modes.forEach(mode => {
        ctx.fillStyle = '#8ce023';
        ctx.fillRect(300, mode.y - 20, 600, 40);
        ctx.fillStyle = '#0a0e1a';
        ctx.font = '16px "Press Start 2P", monospace';
        ctx.fillText(mode.name, 600, mode.y + 5);
    });
    
    gameState.modeButtons = modes;
}

        // ============= GAME MANAGEMENT =============
function startGame(game) {
    currentGame = game;
    menu.style.display = 'none';
    gameScreen.style.display = 'flex';
    document.querySelectorAll('section').forEach(section => {
        section.style.display = 'none';
    });
    gameState = {}; // Reset game state
    currentScene = settings.skipIntros ? 'playing' : 'intro';
    
    // Focus canvas for keyboard input FIRST
    canvas.focus();
    canvas.setAttribute('tabindex', '0');
    
    console.log('Starting game:', game, 'Canvas focused');
    
    if (game === 'brick-demolisher') {
        initBreakout();
    } else if (game === 'asteroid-hunter') {
        initAsteroids();
    } else if (game === 'hanoi') {
        initHanoi();
    } else if (game === 'wordle') {
        initWordle();
    } else if (game === 'firewall') {
        initFirewall();
    } else if (game === 'power') {
        initPower();
    } else if (game === 'bypass') {
        initBypass();
    } else if (game === 'block-signal') {
        initBlockSignal();
    } else if (game === 'avoid-obstacles') {
        initAvoidObstacles();
    } else if (game === 'avoid-walls') {
        initAvoidWalls();
    } else if (game === 'avoid-safety') {
        initAvoidSafety();
    } else if (game === 'gather-blocks') {
        initGatherBlocks();
    } else if (game === 'osu') {
        currentGame = 'osu-selection';
        gameState = { modeButtons: [] };
        drawOsuModeSelection();
    } else if (game.startsWith('osu-')) {
        initOsu(game);
    } else if (game === 'cuff-hack') {
        initCuffHackIntro();
    } else if (game === 'connect-pipes') {
        initConnectPipes();
    } else if (game === 'memory-sequence') {
        currentGame = 'memory-sequence';
        currentScene = 'intro';
        initMemorySequence();
    } else if (game === 'unlock-garage') {
        initUnlockGarage();
    } else if (game === 'color-memory') {
        initColorMemory();
    } else if (game === 'find-pairs') {
        currentGame = 'find-pairs';
        currentScene = 'intro';
        initFindPairs();
    } else if (game === 'block-external-signal') {
        currentGame = 'block-external-signal';
        currentScene = 'intro';
        initBlockExternalSignal();
    } else if (game === 'electricity-panel') { 
        currentGame = 'electricity-panel';
        currentScene = 'intro';
        initElectricityPanel();
    } else if (game === 'math-compare') {
        initMathCompare();
    } else if (game === 'lock-picking') {
        initLockPicking();
    }
    
    if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
    }
    gameLoop();
}

        function backToMenu() {
            currentGame = null;
            gameScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            menu.style.display = 'block';
            
            // Stop game loop
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
        }

function restartGame() {
    gameOverScreen.style.display = 'none';
    
    // Store the current game before resetting
    const gameToRestart = currentGame;
    
    // CLEAR any pending auto-restart timeout before resetting state
    if (gameState && gameState.autoRestartTimeout) {
        clearTimeout(gameState.autoRestartTimeout);
    }
    
    // Stop auto-pilot if running
    if (autoPilotEnabled) {
        stopAutoPilot();
        autoPilotEnabled = false;
    }
    
    // For OSU games, restart the SAME difficulty, not mode selection
    if (gameToRestart && gameToRestart.startsWith('osu-') && gameToRestart !== 'osu-selection') {
        // Directly initialize the same OSU game mode
        initOsu(gameToRestart);
        // Restart game loop
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
        }
        gameLoop();
    } else if (gameToRestart === 'cuff-hack' && gameState.difficulty) {
        // For Cuff Hack, restart with same difficulty
        const savedDifficulty = gameState.difficulty;
        initCuffHack(savedDifficulty);
        // Restart game loop
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
        }
        gameLoop();
    } else {
        // For all other games, use normal restart flow
        gameState = {};
        currentScene = 'intro';
        startGame(gameToRestart);
    }
    
    // Auto-focus canvas for Wordle
    if (gameToRestart === 'wordle') {
        canvas.focus();
    }
}

function endGame(title, subtitle) {
    gameState.gameOver = true;
    
    if (gameLoopId) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
    }
    
    // Now set up our end game screen completely independently
    ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
    ctx.fillRect(0, 0, 1200, 600);
    
    // Check if win or lose
    const isWin = (title === 'YOU WIN!' || title === 'HACK COMPLETED' || title === 'ESCAPED!');
    
    if (isWin) {
        // Green glowing checkmark
        ctx.shadowBlur = 40;
        ctx.shadowColor = '#00ff00';
        ctx.fillStyle = '#00ff00';
        ctx.font = '80px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('‚úì', 600, 240);
        ctx.shadowBlur = 0;
        
        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = '28px "Press Start 2P", monospace';
        ctx.fillText(title, 600, 320);

    } else {
        // Red glowing X
        ctx.shadowBlur = 40;
        ctx.shadowColor = '#ff0000';
        ctx.fillStyle = '#ff0000';
        ctx.font = '80px "Press Start 2P", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('‚úó', 600, 240);
        ctx.shadowBlur = 0;
        
        // Title
        ctx.fillStyle = '#ffffff';
        ctx.font = '28px "Press Start 2P", monospace';
        ctx.fillText(title, 600, 320);
    }
    
    // Subtitle
    ctx.font = '14px "Press Start 2P", monospace';
    ctx.fillText(subtitle, 600, 360);

}

function gameLoop() {
    if (!currentGame || gameState.gameOver) return;
    
    // Handle OSU mode selection screen
    if (currentGame === 'osu-selection') {
        drawOsuModeSelection();
        gameLoopId = requestAnimationFrame(gameLoop);
        return;
    }
    if (currentGame === 'breakout') {
        updateBreakout();
        drawBreakout();
    } else if (currentGame === 'asteroids') {
        updateAsteroids();
        drawAsteroids();
    } else if (currentGame === 'hanoi') {
        updateHanoi();
        drawHanoi();
    } else if (currentGame === 'wordle') {
        updateWordle();
        drawWordle();
    } else if (currentGame === 'firewall') {
        updateFirewall();
        drawFirewall();
    } else if (currentGame === 'power') {
        updatePower();
        drawPower();
    } else if (currentGame === 'bypass') {
        updateBypass();
        drawBypass();
    } else if (currentGame === 'block-signal') {
        updateBlockSignal();
        drawBlockSignal();
    } else if (currentGame === 'avoid-obstacles') {
        updateAvoidObstacles();
        drawAvoidObstacles();
    } else if (currentGame === 'avoid-walls') {
        updateAvoidWalls();
        drawAvoidWalls();
    } else if (currentGame === 'avoid-safety') {
        updateAvoidSafety();
        drawAvoidSafety();
    } else if (currentGame === 'gather-blocks') {
        updateGatherBlocks();
        drawGatherBlocks();
    } else if (currentGame === 'find-pairs') {
        updateFindPairs();
        drawFindPairs();
    } else if (currentGame === 'block-external-signal') {
        updateBlockExternalSignal();
        drawBlockExternalSignal();
    } else if (currentGame && currentGame.startsWith('osu-')) {
        updateOsu();
        drawOsu();
    } else if (currentGame === 'cuff-hack') {  
        updateCuffHack();
        drawCuffHack();
    } else if (currentGame === 'connect-pipes') {
        updateConnectPipes();
        drawConnectPipes();
    } else if (currentGame === 'electricity-panel') { 
        updateElectricityPanel();
        drawElectricityPanel();
    } else if (currentGame === 'memory-sequence') {
        updateMemorySequence();
        drawMemorySequence();
    } else if (currentGame === 'unlock-garage') {
        updateUnlockGarage();
        drawUnlockGarage();
    } else if (currentGame === 'color-memory') {
        updateColorMemory();
        drawColorMemory();
    } else if (currentGame === 'math-compare') {
        updateMathCompare();
        drawMathCompare();
    } else if (currentGame === 'lock-picking') {
        updateLockPicking();
        drawLockPicking();
    }
    
    gameLoopId = requestAnimationFrame(gameLoop);
}

        // ============= SETTINGS MANAGEMENT =============
function loadSettings() {
    // Determine which scheme is being used for heist games
    const heistScheme = (settings.breakout.left === 'ArrowLeft') ? 'arrows' : 'wasd';
    document.getElementById('heist-controls').value = heistScheme;
    
    // Determine which scheme is being used for boosting games
    const boostingScheme = (settings.boosting.left === 'ArrowLeft') ? 'arrows' : 'wasd';
    document.getElementById('boosting-controls').value = boostingScheme;
    
    document.getElementById('skip-intros').value = settings.skipIntros ? 'true' : 'false';
}
        
function saveSettings() {
    // Heist games control scheme
    const heistScheme = document.getElementById('heist-controls').value;
    if (heistScheme === 'arrows') {
        settings.breakout.left = 'ArrowLeft';
        settings.breakout.right = 'ArrowRight';
        settings.asteroids.up = 'ArrowUp';
        settings.asteroids.down = 'ArrowDown';
        settings.asteroids.shoot = 'Space';
    } else {
        settings.breakout.left = 'KeyA';
        settings.breakout.right = 'KeyD';
        settings.asteroids.up = 'KeyW';
        settings.asteroids.down = 'KeyS';
        settings.asteroids.shoot = 'Space';
    }
    
    // Boosting games control scheme
    const boostingScheme = document.getElementById('boosting-controls').value;
    if (boostingScheme === 'arrows') {
        settings.boosting.left = 'ArrowLeft';
        settings.boosting.right = 'ArrowRight';
        settings.boosting.up = 'ArrowUp';
        settings.boosting.down = 'ArrowDown';
        settings.boosting.shoot = 'Space';
    } else {
        settings.boosting.left = 'KeyA';
        settings.boosting.right = 'KeyD';
        settings.boosting.up = 'KeyW';
        settings.boosting.down = 'KeyS';
        settings.boosting.shoot = 'Space';
    }
    
    settings.skipIntros = document.getElementById('skip-intros').value === 'true';
}

        // ============= EVENT LISTENERS =============
document.addEventListener('DOMContentLoaded', function() {
    // Load settings
    loadSettings();
    
    // Game card click handlers
    document.querySelectorAll('.game-card').forEach(card => {
        card.addEventListener('click', function() {
            const gameType = this.getAttribute('data-game');
            if (gameType) {
                startGame(gameType);
            }
        });
    });
    
    // Button handlers
    document.getElementById('back-btn').addEventListener('click', backToMenu);
    document.getElementById('play-again-inline-btn').addEventListener('click', restartGame); // NEW LINE
    document.getElementById('play-again-btn').addEventListener('click', restartGame);
    document.getElementById('menu-btn').addEventListener('click', backToMenu);
            document.getElementById('settings-btn').addEventListener('click', function() {
                settingsMenu.style.display = 'block';
            });
            document.getElementById('close-settings').addEventListener('click', function() {
                saveSettings();
                settingsMenu.style.display = 'none';
            });
            
            // Improved Hanoi drag and drop
            let isDragging = false;

canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    //Cuff Game
    if (currentGame === 'cuff-hack') {
        if (currentScene === 'intro') {
            handleCuffIntroClick(x, y);
        } else {
            handleCuffClick(x, y);
        }
        e.preventDefault(); 
        return; 
    }
 // Connect Pipes - INTRO check first
    if (currentGame === 'connect-pipes' && currentScene === 'intro') {
        currentScene = 'countdown';
        countdownStart = Date.now();
        return;
    }

    // Connect Pipes gameplay clicks
    if (currentGame === 'connect-pipes' && currentScene === 'playing') {
        handleConnectPipesClick(x, y);
        return;
    }

    // Find Pairs - INTRO check
    if (currentGame === 'find-pairs' && currentScene === 'intro') {
        currentScene = 'countdown';
        countdownStart = Date.now();
        return;
    }

    // Find Pairs gameplay clicks
    if (currentGame === 'find-pairs' && currentScene === 'playing') {
        handleFindPairsClick(x, y);
        return;
    }

    // Block External Signal - INTRO check
    if (currentGame === 'block-external-signal' && currentScene === 'intro') {
        currentScene = 'countdown';
        countdownStart = Date.now();
        return;
    }

// Electricity Panel - INTRO check first
if (currentGame === 'electricity-panel' && currentScene === 'intro') {
    currentScene = 'countdown';
    countdownStart = Date.now();
    return;
}

// Electricity Panel gameplay clicks
if (currentGame === 'electricity-panel' && currentScene === 'playing') {
    handleElectricityPanelClick(x, y);
    return;
}

// Memory Sequence - INTRO check first
if (currentGame === 'memory-sequence' && currentScene === 'intro') {
    currentScene = 'countdown';
    countdownStart = Date.now();
    gameState.countdownStart = Date.now();
    return;
}

// Memory Sequence - INTRO check first
if (currentGame === 'unlock-garage' && currentScene === 'intro') {
    currentScene = 'countdown';
    countdownStart = Date.now();
    return;
}
// Color Memory - INTRO check first
if (currentGame === 'color-memory' && currentScene === 'intro') {
    currentScene = 'countdown';
    countdownStart = Date.now();
    return;
}

// Color Memory gameplay clicks
if (currentGame === 'color-memory' && (currentScene === 'memorize' || currentScene === 'question')) {
    handleColorMemoryClick(x, y);
    return;
}

 // Math Compare - INTRO check first
    if (currentGame === 'math-compare' && currentScene === 'intro') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            currentScene = 'countdown';
            countdownStart = Date.now();
        }
        return;
    }

    // Math Compare gameplay clicks
    if (currentGame === 'math-compare' && currentScene === 'question') {
        handleMathCompareClick(x, y);
        return;
    }

// Lock Picking - INTRO check first
if (currentGame === 'lock-picking' && currentScene === 'intro') {
    const buttonX = 60;
    const buttonY = 230;
    const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
    
    if (distance <= 20) {
        currentScene = 'countdown';
        countdownStart = Date.now();
    }
    return;
}

// Lock Picking gameplay clicks
if (currentGame === 'lock-picking' && currentScene === 'question') {
    handleLockPickingClick(x, y);
    return;
}
    // OSU mode selection
    if (currentGame === 'osu-selection' && gameState.modeButtons) {
        for (let mode of gameState.modeButtons) {
            if (x >= 300 && x <= 900 && y >= mode.y - 20 && y <= mode.y + 20) {
                currentGame = null;
                startGame(mode.id);
                return;
            }
        }
        return;
    }
    
    // OSU settings screen clicks
    if (currentGame && currentGame.startsWith('osu-') && currentScene === 'intro') {
        handleOsuSettingsClick(x, y);
        return;
    }
    
    // OSU gameplay clicks - THIS MUST COME BEFORE OTHER GAME CHECKS
    if (currentGame && currentGame.startsWith('osu-') && currentScene === 'playing') {
        console.log('OSU gameplay click detected!');
        if (gameState.failed && gameState.failTime && Date.now() - gameState.failTime >= 2000) {
            // Click to restart after failure
            restartGame();
        } else {
            handleOsuClick(x, y);
        }
        return;
    }
    
    // Check for button click in intro screen (heist games)
    if ((currentGame === 'hanoi' || currentGame === 'wordle') && currentScene === 'intro') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            currentScene = 'countdown';
            countdownStart = Date.now();
        }
        return;
    }
    
    // Check for click in intro screen (boosting games)
    if ((currentGame === 'firewall' || currentGame === 'power' || currentGame === 'bypass' || 
         currentGame === 'block-signal' || currentGame === 'avoid-obstacles' || 
         currentGame === 'avoid-walls' || currentGame === 'avoid-safety' || 
         currentGame === 'gather-blocks') && currentScene === 'intro') {
        currentScene = 'countdown';
        countdownStart = Date.now();
        return;
    }

    if (currentGame === 'hanoi' && currentScene === 'playing') {
        startDragHanoi(x, y);
        isDragging = true;
    }
});
            
            canvas.addEventListener('mousemove', (e) => {
                if (currentGame === 'hanoi' && gameState.dragging && isDragging) {
                    const rect = canvas.getBoundingClientRect();
                    gameState.dragging.x = e.clientX - rect.left;
                    gameState.dragging.y = e.clientY - rect.top;
                }
            });
            
            canvas.addEventListener('mouseup', (e) => {
                if (currentGame === 'hanoi' && gameState.dragging && isDragging) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    dropHanoi(x, y);
                    isDragging = false;
                }
            });
            
canvas.addEventListener('touchstart', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.touches[0].clientX - rect.left;
    const y = e.touches[0].clientY - rect.top;
    
  // Lock Picking Game - ADD THIS
    if (currentGame === 'lock-picking') {
        handleLockPickingClick(x, y);
        e.preventDefault();
        return;
    }
    // Check for button click in intro screen
    if ((currentGame === 'hanoi' || currentGame === 'wordle') && currentScene === 'intro') {
        const buttonX = 60;
        const buttonY = 230;
        const distance = Math.sqrt((x - buttonX) ** 2 + (y - buttonY) ** 2);
        
        if (distance <= 20) {
            currentScene = 'countdown';
            countdownStart = Date.now();
        }
        e.preventDefault();
        return;
    }
    
    if (currentGame === 'hanoi' && currentScene === 'playing') {
        startDragHanoi(x, y);
        isDragging = true;
        e.preventDefault();
    }
});
            canvas.addEventListener('touchmove', (e) => {
                if (currentGame === 'hanoi' && gameState.dragging && isDragging) {
                    const rect = canvas.getBoundingClientRect();
                    gameState.dragging.x = e.touches[0].clientX - rect.left;
                    gameState.dragging.y = e.touches[0].clientY - rect.top;
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('touchend', (e) => {
                if (currentGame === 'hanoi' && gameState.dragging && isDragging) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.changedTouches[0].clientX - rect.left;
                    const y = e.changedTouches[0].clientY - rect.top;
                    dropHanoi(x, y);
                    isDragging = false;
                    e.preventDefault();
                }
            });
            
            // Keyboard controls with settings
window.addEventListener('keydown', (e) => {
 console.log('Key pressed:', e.key, 'Code:', e.code, 'Current game:', currentGame);
    if (currentGame === 'lock-picking') {
        handleLockPickingKeyPress(e.key);
    }
  if (currentGame === 'cuff-hack') {
        handleCuffKeyPress(e.key);
    }
    if (currentGame === 'breakout') {
        if (e.code === settings.breakout.left) gameState.keys.left = true;
        if (e.code === settings.breakout.right) gameState.keys.right = true;
        if (e.code === 'Space') {
            gameState.keys.launch = true;
            e.preventDefault();
        }
    } else if (currentGame === 'asteroids') {
        if (e.code === settings.asteroids.up) gameState.keys.up = true;
        if (e.code === settings.asteroids.down) gameState.keys.down = true;
        if (e.code === settings.asteroids.shoot) {
            gameState.keys.shoot = true;
            e.preventDefault();
        }
    } else if (currentGame === 'wordle' && currentScene === 'playing') {
        handleWordleKey(e.key.toUpperCase());
    } else if (currentGame === 'firewall' && currentScene === 'playing') {
        if (e.code === settings.boosting.left) {
            gameState.keys.left = true;
            e.preventDefault();
        }
        if (e.code === settings.boosting.right) {
            gameState.keys.right = true;
            e.preventDefault();
        }
        if (e.code === settings.boosting.shoot) {
            gameState.keys.shoot = true;
            e.preventDefault();
        }
    } else if (currentGame === 'power' && currentScene === 'playing') {
        const dir = gameState.direction;
        if (e.code === settings.boosting.up && dir.y === 0) {
            gameState.nextDirection = { x: 0, y: -1 };
            e.preventDefault();
        }
        if (e.code === settings.boosting.down && dir.y === 0) {
            gameState.nextDirection = { x: 0, y: 1 };
            e.preventDefault();
        }
        if (e.code === settings.boosting.left && dir.x === 0) {
            gameState.nextDirection = { x: -1, y: 0 };
            e.preventDefault();
        }
        if (e.code === settings.boosting.right && dir.x === 0) {
            gameState.nextDirection = { x: 1, y: 0 };
            e.preventDefault();
        }
   } else if (currentGame === 'bypass' && currentScene === 'playing') {
        // Check if it's one of the game keys
        if (e.code === 'KeyA' || e.code === 'KeyS' || e.code === 'KeyK' || e.code === 'KeyL') {
            // Check if there's a block in the hit zone
            const gameHeight = 500;
            const offsetY = (600 - gameHeight) / 2;
            const targetY = offsetY + gameHeight - 50;
            let hitSuccess = false;
            
            for (let i = gameState.blocks.length - 1; i >= 0; i--) {
                const scaledY = offsetY + (gameState.blocks[i].y / 600) * gameHeight;
                
                if (gameState.blocks[i].key === e.code && 
                    Math.abs(scaledY - targetY) < 25) {
                    gameState.score++;
                    gameState.blocks.splice(i, 1);
                    hitSuccess = true;
                    
                    if (gameState.score >= 50) {
                        endGame('HACK COMPLETED', 'Perfect bypass!');
                        return;
                    }
                    break;
                }
            }
            
            // Wrong timing - lose
            if (!hitSuccess) {
                endGame('HACK FAILED!', `Blocks Hit: ${gameState.score}/50`);
                return;
            }
            
            e.preventDefault();
        } else {
            // Any other key during bypass game = instant lose
            e.preventDefault();
            endGame('HACK FAILED!', `Blocks Hit: ${gameState.score}/50`);
        }
// ===============================
// NEW GAME: BLOCK SIGNAL
// ===============================

} else if (currentGame === 'block-signal' && currentScene === 'playing') {
    if (e.code === settings.boosting.left && !gameState.keys.left) {
        gameState.targetAngle = (gameState.targetAngle - 90 + 360) % 360;
        gameState.keys.left = true;
        e.preventDefault();
    }
    if (e.code === settings.boosting.right && !gameState.keys.right) {
        gameState.targetAngle = (gameState.targetAngle + 90) % 360;
        gameState.keys.right = true;
        e.preventDefault();
    }


  // ===============================
// NEW GAME: AVOID OBSTACLES (L/R)
// ===============================
} else if (currentGame === 'avoid-obstacles' && currentScene === 'playing') {
    if (e.code === settings.boosting.left) {
        gameState.keys.left = true;
        e.preventDefault();
    }
    if (e.code === settings.boosting.right) {
        gameState.keys.right = true;
        e.preventDefault();
    }
    if (e.code === settings.boosting.shoot) {
        gameState.keys.shoot = true;
        e.preventDefault();
    }

    // ===============================
    // NEW GAME: AVOID WALLS (U/D/L/R)
    // ===============================
    } else if (currentGame === 'avoid-walls' && currentScene === 'playing') {
        if (e.code === settings.boosting.up) {
            gameState.keys.up = true;
            e.preventDefault();
        }
        if (e.code === settings.boosting.down) {
            gameState.keys.down = true;
            e.preventDefault();
        }
        if (e.code === settings.boosting.left) {
            gameState.keys.left = true;
            e.preventDefault();
        }
        if (e.code === settings.boosting.right) {
            gameState.keys.right = true;
            e.preventDefault();
        }

    // ===============================
    // NEW GAME: AVOID SAFETY (L/R)
    // ===============================
    } else if (currentGame === 'avoid-safety' && currentScene === 'playing') {
        if (e.code === settings.boosting.left) {
            gameState.keys.left = true;
            e.preventDefault();
        }
        if (e.code === settings.boosting.right) {
            gameState.keys.right = true;
            e.preventDefault();
        }
} else if (currentGame === 'gather-blocks' && currentScene === 'playing') {
    if (e.code === settings.boosting.left) {
        gameState.keys.left = true;
        e.preventDefault();
    }
    if (e.code === settings.boosting.right) {
        gameState.keys.right = true;
        e.preventDefault();
    }
} else if (currentGame === 'find-pairs' && currentScene === 'playing') {
    if (e.code === 'KeyH') {
        gameState.showHint = !gameState.showHint;
        e.preventDefault();
    }
} else if (currentGame === 'block-external-signal' && currentScene === 'playing') {
    if (e.code === 'Space') {
        if (!gameState.gameStarted) {
            gameState.gameStarted = true;
        }
        gameState.birdVelocity = gameState.jumpStrength;
        e.preventDefault();
    }
} else if (currentGame === 'connect-pipes' && currentScene === 'playing') {
    if (e.code === 'KeyH') {
        gameState.showSolution = true;
        e.preventDefault();
   }

} else if (currentGame === 'memory-sequence' && currentScene === 'question') {
    if (e.code === settings.boosting.left || e.code === 'KeyA' || e.code === 'ArrowLeft') {
        if (!gameState.answered && !gameState.gameOver && !gameState.gameWon) {
            console.log('NO pressed');
            handleAnswer('no');
        }
        e.preventDefault();
    }
    if (e.code === settings.boosting.right || e.code === 'KeyD' || e.code === 'ArrowRight') {
        if (!gameState.answered && !gameState.gameOver && !gameState.gameWon) {
            console.log('YES pressed');
            handleAnswer('yes');
        }
        e.preventDefault();
    }
} else if (currentGame === 'memory-sequence' && currentScene === 'intro') {
    if (e.code === 'Space') {
        currentScene = 'countdown';
        countdownStart = Date.now();
        gameState.countdownStart = Date.now();
        e.preventDefault();
    }
}  else if (currentGame === 'unlock-garage' && currentScene === 'playing') {
    handleUnlockGarageKey(e.key.toUpperCase());
    e.preventDefault();
}else if (currentGame === 'osu' && gameState.failed) {
    if (e.code === 'KeyR' || e.code === 'Space') {
        initOsu();
        e.preventDefault();
    }
    }
});

window.addEventListener('keyup', (e) => {

    if (currentGame === 'breakout') {
        if (e.code === settings.breakout.left) gameState.keys.left = false;
        if (e.code === settings.breakout.right) gameState.keys.right = false;
        if (e.code === 'Space') gameState.keys.launch = false;

    } else if (currentGame === 'asteroids') {
        if (e.code === settings.asteroids.up) gameState.keys.up = false;
        if (e.code === settings.asteroids.down) gameState.keys.down = false;

    } else if (currentGame === 'firewall') {
        if (e.code === settings.boosting.left) gameState.keys.left = false;
        if (e.code === settings.boosting.right) gameState.keys.right = false;
        if (e.code === settings.boosting.shoot) gameState.keys.shoot = false;

  //BLOCK SIGNAL
} else if (currentGame === 'block-signal') {
    if (e.code === settings.boosting.left) gameState.keys.left = false;
    if (e.code === settings.boosting.right) gameState.keys.right = false;

//AVOID OBSTACLES
} else if (currentGame === 'avoid-obstacles') {
    if (e.code === settings.boosting.left) gameState.keys.left = false;
    if (e.code === settings.boosting.right) gameState.keys.right = false;
    if (e.code === settings.boosting.shoot) gameState.keys.shoot = false;

    //AVOID WALLS
    } else if (currentGame === 'avoid-walls') {
        if (e.code === settings.boosting.up) gameState.keys.up = false;
        if (e.code === settings.boosting.down) gameState.keys.down = false;
        if (e.code === settings.boosting.left) gameState.keys.left = false;
        if (e.code === settings.boosting.right) gameState.keys.right = false;

    //AVOID SAFETY
    } else if (currentGame === 'avoid-safety') {
        if (e.code === settings.boosting.left) gameState.keys.left = false;
        if (e.code === settings.boosting.right) gameState.keys.right = false;
     //GATHER BLOCKS
 } else if (currentGame === 'gather-blocks') {
    if (e.code === settings.boosting.left) gameState.keys.left = false;
    if (e.code === settings.boosting.right) gameState.keys.right = false;
} else if (currentGame === 'connect-pipes') {
    if (e.code === 'KeyH') gameState.showSolution = false;
} else if (currentGame === 'memory-sequence') {
    if (e.code === settings.boosting.left || e.code === 'KeyA') gameState.keys.left = false;
    if (e.code === settings.boosting.right || e.code === 'KeyD') gameState.keys.right = false;
}

});

        });
    </script>
    <!-- Your game canvas or container -->
    <canvas id="gameCanvas"></canvas>
</video>
</body>
</html>

